<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++ 类成员函数与内联函数</title>
      <link href="/2022/05/10/cpp_class_mem_func_and_inline_func/"/>
      <url>/2022/05/10/cpp_class_mem_func_and_inline_func/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>类定义的内联函数分为以下3种：</p><h2 id="1-隐式内联"><a href="#1-隐式内联" class="headerlink" title="1. 隐式内联"></a>1. 隐式内联</h2><p>类里面定义的函数隐式内联，有利于类内部实现细节的隐藏。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person(<span class="keyword">const</span> <span class="built_in">string</span> &amp;name)</span><br><span class="line">&#123;</span><br><span class="line">Name = name;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printName</span><span class="params">()</span><span class="comment">//printName 定义在类里面是隐式内联函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; Name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">string</span> Name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="2-在类里面显示声明，在类外面定义"><a href="#2-在类里面显示声明，在类外面定义" class="headerlink" title="2. 在类里面显示声明，在类外面定义"></a>2. 在类里面显示声明，在类外面定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person(<span class="keyword">const</span> <span class="built_in">string</span> &amp;name)</span><br><span class="line">&#123;</span><br><span class="line">Name = name;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">printName</span><span class="params">()</span></span>;<span class="comment">//成员被函数前加了inline是显式内联函数</span></span><br><span class="line"><span class="comment">//在类里面显式声明</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">string</span> Name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> Person::printName()</span><br><span class="line">&#123;<span class="comment">//在类外面定义</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; Name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-“追加”内联"><a href="#3-“追加”内联" class="headerlink" title="3. “追加”内联"></a>3. “追加”内联</h2><p>表示在类里面没有显式声明，在类外显示定义了内联。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person(<span class="keyword">const</span> <span class="built_in">string</span> &amp;name)</span><br><span class="line">&#123;</span><br><span class="line">Name = name;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printName</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//在类里面没有显式声明</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">string</span> Name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> Person::printName()<span class="comment">//成员被函数前加了inline是显式内联函数</span></span><br><span class="line">&#123;<span class="comment">//在类外面显式定义</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; Name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-常见的成员函数不是内联函数"><a href="#4-常见的成员函数不是内联函数" class="headerlink" title="4. 常见的成员函数不是内联函数"></a>4. 常见的成员函数不是内联函数</h2><p>定义不在类里面，且声明和定义都没有<code>inline</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person(<span class="keyword">const</span> <span class="built_in">string</span> &amp;name)</span><br><span class="line">&#123;</span><br><span class="line">Name = name;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printName</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//在类里面没有显式声明</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">string</span> Name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> Person::printName()<span class="comment">//不是内联函数</span></span><br><span class="line">&#123;<span class="comment">//在类外面也没有显式定义</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; Name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>注：内联函数仅仅是对编译器的内联建议，编译器是否觉得采取你的建议取决于函数是否符合内联的有利条件。如何函数体非常大，那么编译器将忽略函数的内联声明，而将内联函数作为普通函数处理。</strong></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://blog.csdn.net/qq_18343569/article/details/83755202" target="_blank" rel="noopener">C++类里面的哪些成员函数是内联函数？</a></p><p><a href="https://www.cnblogs.com/qg-whz/p/4641479.html" target="_blank" rel="noopener">C++内联函数</a></p><h2 id="相关文献"><a href="#相关文献" class="headerlink" title="相关文献"></a>相关文献</h2><p><a href="https://blog.csdn.net/Apollon_krj/article/details/82911180" target="_blank" rel="noopener">C语言宏定义、宏函数、内置宏与常用宏</a></p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内联函数 </tag>
            
            <tag> 成员函数 </tag>
            
            <tag> 类 </tag>
            
            <tag> 隐式内联 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 含有可变形参的函数</title>
      <link href="/2022/05/09/cpp_func_with_variable_parameters/"/>
      <url>/2022/05/09/cpp_func_with_variable_parameters/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>有时我们无法提前预知应该向函数传递几个实参。例如，我们想要编写代码输出程序产生的错误信息，此时最好用同一个函数实现该项功能，以便对所有的错误处理能够整齐划一。然而，错误信息的种类不同，所以调用错误输出函数时传递的实参也各不相同。</p><p>为了编写能处理不同数量实参的函数，c++11新标准提供了两种主要的方法：如果所有的实参类型相同，可以一个名为<code>initializer_list</code>的标准库类型；如果实参的类型不同，我们可以编写一种特殊的函数，也就是所谓的可变参数模板。</p><p>c++还有一种特殊的形参类型（即省略符），可以用它传递可变数量的实参，不过需要注意，此功能<strong>一般只用于与c函数交互的接口程序</strong>。</p><a id="more"></a><h2 id="1-initializer-list形参"><a href="#1-initializer-list形参" class="headerlink" title="1. initializer_list形参"></a>1. initializer_list形参</h2><p>如果函数的实参数量未知，但是实参类型均相同，我们可以用<code>initializer_list</code>类型的形参。<code>initializer_list</code>是一种标准库类型，用于表示某种特定类型的值的数组。<code>initializer_list</code>定义在同名的头文件中，它提供的操作如下所示。</p><p><code>initializer_list&lt;T&gt; lst;</code> ——&gt; 默认初始化，T类型元素的空列表；</p><p><code>initializer_list&lt;T&gt; lst{a, b, c...};</code> ——&gt; lst初始化，lst的元素是const；</p><p><code>lst2(lst); lst2 = lst;</code> ——&gt; 拷贝初始化或者赋值初始化；</p><p><code>lst.size();</code> ——&gt; 列表中的元素数量；</p><p><code>lst.begin();</code> ——&gt; 列表首元素指针；</p><p><code>lst.end();</code> ——&gt; 列表尾后元素指针；</p><p>类似<code>vector</code>，<code>initializer_list</code>也是一种模板类型，定义<code>initializer_list</code>时，必须说明列表中所含元素的类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">initializer_list</span>&lt;<span class="built_in">string</span>&gt; ls;   <span class="comment">// initializer_list的元素类型是string</span></span><br><span class="line"><span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt; li;      <span class="comment">// initializer_list的元素类型是int</span></span><br></pre></td></tr></table></figure><p>与<code>vector</code>不同的是，<code>initializer_list</code>更加轻量，且<code>initializer_list</code>对象中的元素均为常量，不可更改。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_msg</span><span class="params">(<span class="built_in">initializer_list</span>&lt;<span class="built_in">string</span>&gt; ls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = ls.<span class="built_in">begin</span>(); it != ls.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">error_msg(&#123;<span class="string">"functionX"</span>, <span class="string">"expected"</span>, <span class="string">"actual"</span>&#125;);    <span class="comment">// 调用</span></span><br><span class="line"><span class="comment">// output: functionX expected actual</span></span><br></pre></td></tr></table></figure><h2 id="2-可变参数模板"><a href="#2-可变参数模板" class="headerlink" title="2. 可变参数模板"></a>2. 可变参数模板</h2><p>待写。</p><h2 id="3-省略符形参"><a href="#3-省略符形参" class="headerlink" title="3. 省略符形参"></a>3. 省略符形参</h2><p>省略符形参是为了便于c++程序访问某些特殊的c代码而设置的，这些代码使用了名为<code>varargs</code>的c标准库功能。</p><p><strong>注：省略符形参应该仅仅用于c和c++通用的类型。特别注意的是，大多数类类型的对象在传递给省略符形参时都无法正确拷贝。</strong></p><p>示例程序如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> count, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//为了实现可变参数列表，首先需要声明一个va_list类型的指针</span></span><br><span class="line">    <span class="comment">// va_list类型是在cstdarg头文件里面定义的，该指针用来依次</span></span><br><span class="line">    <span class="comment">//指向各个参数</span></span><br><span class="line">    <span class="comment">// va_start是一个宏，用来初始化arg_ptr，使其指向列表的第一个</span></span><br><span class="line">    <span class="comment">//参数，这个宏的第二个参数是sum函数参数列表省略号前得固定参</span></span><br><span class="line">    <span class="comment">//数的名称，用来确定第一个参数的位置</span></span><br><span class="line">    va_list arg_ptr;</span><br><span class="line">    va_start(arg_ptr, count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> CountSum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// va_arg是一个宏，返回arg_ptr指向的</span></span><br><span class="line">    <span class="comment">//参数位置，并使arg_ptr递增来指向下一个参数值</span></span><br><span class="line">    <span class="comment">// va_arg宏的第二个参数是需要统计的第</span></span><br><span class="line">    <span class="comment">//一个参数的类型，如果类型不正确，</span></span><br><span class="line">    <span class="comment">//程序也可能会执行，但得到的是无用的</span></span><br><span class="line">    <span class="comment">//数据，arg_ptr将被错误地递增</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        CountSum += va_arg(arg_ptr, <span class="keyword">int</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将va_list类型的指针复位成空值</span></span><br><span class="line">    <span class="comment">//就是清空可变参数列表</span></span><br><span class="line">    va_end(arg_ptr);</span><br><span class="line">    <span class="keyword">return</span> CountSum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum1(<span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);     <span class="comment">// 调用</span></span><br><span class="line"><span class="comment">// output: 15</span></span><br></pre></td></tr></table></figure><ul><li><code>valist</code> 定义在cstdarg，stdarg.h头文件中，用来存储实参列表；</li><li><code>va_start(arg_ptr, count);</code> 用来设置首个实参，表示取参数的时候从count的下一个参数开始（不包括count），因此，上例中第一个实参表示后面实参的个数；</li><li><code>va_arg(arg_ptr, int);</code> 用来获取实参列表中的实参，<code>int</code> 是实参的类型。它从首个实参依次获取，将获取到的结果作为返回值返回；</li><li><code>va_end(arg_ptr);</code> 表示用完arg_ptr，释放内存；</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>《Primer c++》第5版 page 197;</p><p><a href="https://blog.csdn.net/C1550153993/article/details/91625615" target="_blank" rel="noopener">c++ 含有可变形参的函数</a></p><p><a href="https://zhuanlan.zhihu.com/p/369181555" target="_blank" rel="noopener">c++ 可变参数详解</a></p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 可变形参 </tag>
            
            <tag> initializer_list </tag>
            
            <tag> 省略符形参 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ main函数处理命令行选项</title>
      <link href="/2022/05/07/cpp_main_function_parameters/"/>
      <url>/2022/05/07/cpp_main_function_parameters/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>一般情况下，我们定义的main函数都只有空的形参列表：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>然而，有时我们确实需要给main函数传递实参，一种常见的情况就是用户需要设置一组选项来确定函数所要执行的操作。此时，main函数定义为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argc[])</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>其中第二个形参argc是一个数组，它的元素是指向C风格字符串的指针；第一个形参argc表示数组中字符串的数量。因为第二个形参是数组，所以main函数也可以定义为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>其中argv指向char*。</p><p>当实参传给main函数之后，argv的第一个元素指向<strong>程序的名字或者一个空字符串</strong>，接下来的元素依次传递命令行提供的实参。</p><p>编写一个简单的测试程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(argc-- &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"argc = %d, argv[%d] = %s\n"</span>, argc, argc, argv[argc]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在cmd中运行生成的测试程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PS D:\xxx&gt; .&#x2F;mainfunpara.exe</span><br><span class="line">argc &#x3D; 0, argv[0] &#x3D; D:\xxx\mainfunpara.exe</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PS D:\xxx&gt; .&#x2F;mainfunpara.exe 我 你 他</span><br><span class="line">argc &#x3D; 3, argv[3] &#x3D; 他</span><br><span class="line">argc &#x3D; 2, argv[2] &#x3D; 你</span><br><span class="line">argc &#x3D; 1, argv[1] &#x3D; 我</span><br><span class="line">argc &#x3D; 0, argv[0] &#x3D; D:\xxx\mainfunpara.exe</span><br></pre></td></tr></table></figure><p>argc的实参数组中第一个字符串均为程序的名字，后续的字符串为传入main函数的字符串（以空格分隔），如果没有向main函数传入字符串，则argc为0。</p><h3 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h3><p>《Primer c++》第5版 page196</p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 函数 </tag>
            
            <tag> 参数传递 </tag>
            
            <tag> main形参 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习静态库和动态库</title>
      <link href="/2022/03/18/Static_and_dynamic_libraries/"/>
      <url>/2022/03/18/Static_and_dynamic_libraries/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="一、什么是库？"><a href="#一、什么是库？" class="headerlink" title="一、什么是库？"></a>一、什么是库？</h2><p>在windows平台和linux平台下都大量存在着库。一般是软件作者为了发布方便、替换方便或二次开发目的，而发布的一组可以单独与应用程序进行compile time或runtime链接的二进制可重定位目标码文件。</p><p>本质上来说库是一种可执行代码的二进制形式，这个文件可以在编译时由编译器直接链接到可执行程序中，也可以在运行时由操作系统的runtime enviroment根据需要动态加载到内存中。</p><p>一组库，就形成了一个发布包，当然，具体发布多少个库，完全由库提供商自己决定。</p><p>由于windows和linux的本质不同，因此二者库的二进制是不兼容的。</p><p>现实中每个程序都要依赖很多基础的底层库，不可能每个人的代码都从零开始，因此库的存在意义非同寻常。</p><p>共享库的好处是，不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例。</p><a id="more"></a><h2 id="二、库的分类"><a href="#二、库的分类" class="headerlink" title="二、库的分类"></a>二、库的分类</h2><p>库有两种：静态库和动态库（共享库）。</p><p>windows平台下，静态库通常后缀为 .lib，动态库为 .dll；</p><p>linux平台下，静态库通常后缀为 .a，动态库为 .so；</p><p>从本质上来说，由同一段程序编译出来的静态库和动态库，在功能上是没有区别的。不同之处仅仅在于其名字上，也就是“静态”和“动态”。</p><p>二者均以文件的形式存在，其本质上是一种可执行代码的二进制格式，可以被载入内存中执行。无论是动态链接库还是静态链接库，它们无非是向其调用者提供变量、函数和类。</p><h3 id="1-静态库"><a href="#1-静态库" class="headerlink" title="1.静态库"></a>1.静态库</h3><p>所谓静态库，就是在静态编译时由编译器到指定目录寻找并且进行链接，一旦链接完成，最终的可执行程序中就包含了该库文件中的所有有用信息，包括代码段、数据段等。</p><h3 id="2-动态库"><a href="#2-动态库" class="headerlink" title="2.动态库"></a>2.动态库</h3><p>所谓动态库，就是在应用程序运行时，由操作系统根据应用程序的请求，动态到指定目录下寻找并装载入内存中，同时需要进行地址重定向。</p><h3 id="3-区别"><a href="#3-区别" class="headerlink" title="3.区别"></a>3.区别</h3><p>我们以编译链接、载入时刻两点来讨论静态库和动态库的区别。</p><p><strong>编译链接：</strong></p><p>静态链接库在程序编译时会被链接到目标代码中，目标程序运行时将不再需要改动库，移植方便，体积较大，浪费空间和资源，因为所有相关的对象文件与牵涉到库都被链接合成一个可执行文件，这样导致可执行文件的体积较大。</p><p>动态库在程序编译时并不会被链接到目标代码中，而是在程序运行时才被载入，因为可执行文件体积较小。有了动态库，程序的升级会相对比较简单，比如某个动态库升级了，只需要更换这个动态库的文件，而不需要去更换可执行文件。但要注意的是，可执行程序在运行时需要能找到动态库文件。可执行文件是动态库的调用者。</p><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/静态库和动态库.png" alt=""></p><p><strong>载入时刻</strong></p><p>二者的不同点在于代码被载入的时刻不同。静态库的代码在编译过程中已经被载入可执行程序，因此体积较大。共享库的代码是在可执行程序运行时才载入内存的，在编译过程中仅简单的引用，因此代码体积较小。</p><h3 id="4-优缺点"><a href="#4-优缺点" class="headerlink" title="4.优缺点"></a>4.优缺点</h3><p>相对于动态库，静态库的优点在于直接被链接进可执行程序中，之后，该可执行程序就不再依赖于运行环境的设置了(当然仍然会依赖于 CPU指令集和操作系统支持的可执行文件格式等硬性限制)。</p><p>而动态库的优点在于，用户甚至可以在程序运行时随时替换该动态库，这就构成了动态插件系统的基础。具体使用静态库和动态库，由程序员根据需要自己决定。</p><h2 id="三、库文件的制作"><a href="#三、库文件的制作" class="headerlink" title="三、库文件的制作"></a>三、库文件的制作</h2><h3 id="1-库文件的命名"><a href="#1-库文件的命名" class="headerlink" title="1.库文件的命名"></a>1.库文件的命名</h3><p>静态库的名字一般为libxxxx.a，其中xxxx是该lib的名称。动态库的名字一般为libxxxx.so.x.y.z，含义如下所示：</p><p><strong>libname.so.x.y.z</strong></p><div class="table-container"><table><thead><tr><th>lib</th><th>name</th><th>.so</th><th>.x</th><th>.y</th><th>.z</th></tr></thead><tbody><tr><td>固定代表共享库</td><td>共享库名称</td><td>固定后缀</td><td>主版本号</td><td>次版本号</td><td>发行版本号</td></tr></tbody></table></div><h3 id="2-制作库文件常用参数"><a href="#2-制作库文件常用参数" class="headerlink" title="2.制作库文件常用参数"></a>2.制作库文件常用参数</h3><p>首先需要了解gcc编译库要用到一些参数，很重要。</p><div class="table-container"><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-shared</td><td>指定生成动态链接库</td></tr><tr><td>-static</td><td>指定生成静态链接库</td></tr><tr><td>-fPIC</td><td>表示编译为位置独立的代码，用于编译共享库。目标文件需要创建成位置无关码，概念上就是在可执行程序装载它们的时候，它们可以放在可执行程序内存的任何地方</td></tr><tr><td>-L</td><td>表示要链接的库在当前目录中</td></tr><tr><td>-I</td><td>指定需要连接的动态库。编译器查找动态链接库时有隐含的命名规则，即在给出的名字前面加上lib，后面加上.so来确定库的名称</td></tr><tr><td>-Wall</td><td>生成所有警告信息</td></tr><tr><td>-ggdb</td><td>尽可能的生成gdb可用的调试信息</td></tr><tr><td>-g</td><td>编译器在编译时产生调试信息</td></tr><tr><td>-c</td><td>只产生与处理、编译、汇编之后的代码，不链接，结果为.o文件</td></tr></tbody></table></div><h3 id="3-库源文件"><a href="#3-库源文件" class="headerlink" title="3.库源文件"></a>3.库源文件</h3><p>编写calc.c文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>calc.h文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="4-制作静态库并使用"><a href="#4-制作静态库并使用" class="headerlink" title="4.制作静态库并使用"></a>4.制作静态库并使用</h3><p>(1) 需要把calc.c编译成.o文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c calc.c</span><br></pre></td></tr></table></figure><p>(2) 使用 ar 命令生成静态库 libcalc.a</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ar -rc libcalc.a calc.o</span><br></pre></td></tr></table></figure><p>(3) 使用静态库libcalc.a，只需要包含 calc.h 就可以使用函数 add() 和 sub()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"calc.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"add(5, 4) is %d\n"</span>, add(<span class="number">5</span>, <span class="number">4</span>));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"sub(5, 4) is %d\n"</span>, sub(<span class="number">5</span>, <span class="number">4</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态库文件可以放在任意的位置，编译时只需要找到该文件即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -o main libcalc.a</span><br></pre></td></tr></table></figure><p>(4) 库和头文件如果在其他目录下，使用以下命令编译</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c -l &#x2F;home&#x2F;xxxx&#x2F;include test.c    &#x2F;&#x2F;假设test.c要使用对应的静态库</span><br><span class="line">gcc -o test -L &#x2F;home&#x2F;xxxxx&#x2F;lib test.o libcalc.a</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c -I &#x2F;home&#x2F;xxxx&#x2F;include -L &#x2F;home&#x2F;xxxxx&#x2F;lib libcalc.a test.c</span><br></pre></td></tr></table></figure><p>1). 通过-I(是大i)指定对应的头文件</p><p>2). 通过-L制定库文件的路径,libcalc.a就是要用的静态库。</p><p>3). 在test.c中要包含静态库的头文件。</p><h3 id="5-制作动态库并使用"><a href="#5-制作动态库并使用" class="headerlink" title="5.制作动态库并使用"></a>5.制作动态库并使用</h3><p>(1) 把 calc.c 编译成动态链接库 libcalc.so</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -fPIC -o libcalc.o -c calc.c</span><br><span class="line">gcc -shared -o libcalc.so libcalc.o</span><br></pre></td></tr></table></figure><p>也可以直接使用一条命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -fPIC -shared -o libcalc.so calc.c</span><br></pre></td></tr></table></figure><p>(2) 动态库的安装，通常动态库拷贝到 /lib 下即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp libcalc.so &#x2F;lib</span><br></pre></td></tr></table></figure><p>(3) 使用动态库</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"calc.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"add(5, 4) is %d\n"</span>, add(<span class="number">5</span>, <span class="number">4</span>));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"sub(5, 4) is %d\n"</span>, sub(<span class="number">5</span>, <span class="number">4</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译动态库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -o main -lcalc</span><br></pre></td></tr></table></figure><p>编译时动态库的名字与库文件对应关系</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libcalc.so ---------- -lcalc</span><br></pre></td></tr></table></figure><p>去掉 .so，lib简化成l，其他字母保留。</p><h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><p><a href="https://zhuanlan.zhihu.com/p/270640487" target="_blank" rel="noopener">Linux 下的静态库和动态库</a></p><p><a href="https://colobu.com/2018/08/28/15-Most-Frequently-Used-GCC-Compiler-Command-Line-Options/#%E4%BD%BF%E7%94%A8-l%E5%8F%82%E6%95%B0%E9%93%BE%E6%8E%A5%E5%85%B1%E4%BA%AB%E5%BA%93" target="_blank" rel="noopener">常用的GCC编译器参数</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Windows </tag>
            
            <tag> 静态库 </tag>
            
            <tag> 动态库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++拷贝构造函数和赋值运算符</title>
      <link href="/2022/01/10/cpp_constructor_and_assign/"/>
      <url>/2022/01/10/cpp_constructor_and_assign/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>学习笔记</p><p><a href="https://www.cnblogs.com/wangguchangqing/p/6141743.html" target="_blank" rel="noopener">https://www.cnblogs.com/wangguchangqing/p/6141743.html</a></p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 构造函数 </tag>
            
            <tag> 赋值运算符 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 11 =default 和 =delete</title>
      <link href="/2022/01/10/cpp11_default_and_delete/"/>
      <url>/2022/01/10/cpp11_default_and_delete/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>学习笔记</p><p><a href="https://www.cnblogs.com/Braveliu/p/12247471.html" target="_blank" rel="noopener">https://www.cnblogs.com/Braveliu/p/12247471.html</a></p><p><a href="https://www.cnblogs.com/lsgxeva/p/7787438.html" target="_blank" rel="noopener">https://www.cnblogs.com/lsgxeva/p/7787438.html</a></p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 构造函数 </tag>
            
            <tag> 赋值运算符 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>语义化版本控制</title>
      <link href="/2021/12/05/Semantic_version_control/"/>
      <url>/2021/12/05/Semantic_version_control/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>文章转载自：<a href="https://semver.org/lang/zh-CN/" target="_blank" rel="noopener">https://semver.org/lang/zh-CN/</a></p><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>版本格式：主版本号.次版本号.修订号，版本号递增规则如下：</p><ol><li>主版本号：当你做了不兼容的 API 修改，</li><li>次版本号：当你做了向下兼容的功能性新增，</li><li>修订号：当你做了向下兼容的问题修正。</li></ol><p>先行版本号及版本编译信息可以加到“主版本号.次版本号.修订号”的后面，作为延伸。</p><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在软件管理的领域里存在着被称作“依赖地狱”的死亡之谷，系统规模越大，加入的包越多，你就越有可能在未来的某一天发现自己已深陷绝望之中。</p><p>在依赖高的系统中发布新版本包可能很快会成为噩梦。如果依赖关系过高，可能面临版本控制被锁死的风险（必须对每一个依赖包改版才能完成某次升级）。而如果依赖关系过于松散，又将无法避免版本的混乱（假设兼容于未来的多个版本已超出了合理数量）。当你项目的进展因为版本依赖被锁死或版本混乱变得不够简便和可靠，就意味着你正处于依赖地狱之中。</p><p>作为这个问题的解决方案之一，我提议用一组简单的规则及条件来约束版本号的配置和增长。这些规则是根据（但不局限于）已经被各种封闭、开放源码软件所广泛使用的惯例所设计。为了让这套理论运作，你必须先有定义好的公共 API。这可以透过文件定义或代码强制要求来实现。无论如何，这套 API 的清楚明了是十分重要的。一旦你定义了公共 API，你就可以透过修改相应的版本号来向大家说明你的修改。考虑使用这样的版本号格式：X.Y.Z（主版本号.次版本号.修订号）修复问题但不影响 API 时，递增修订号；API 保持向下兼容的新增及修改时，递增次版本号；进行不向下兼容的修改时，递增主版本号。</p><p>我称这套系统为“语义化的版本控制”，在这套约定下，版本号及其更新方式包含了相邻版本间的底层代码和修改内容的信息。</p><h2 id="语义化版本控制规范（SemVer）"><a href="#语义化版本控制规范（SemVer）" class="headerlink" title="语义化版本控制规范（SemVer）"></a>语义化版本控制规范（SemVer）</h2><p>以下关键词 MUST、MUST NOT、REQUIRED、SHALL、SHALL NOT、SHOULD、SHOULD NOT、 RECOMMENDED、MAY、OPTIONAL 依照 RFC 2119 的叙述解读。</p><ol><li>使用语义化版本控制的软件必须（MUST）定义公共 API。该 API 可以在代码中被定义或出现于严谨的文件内。无论何种形式都应该力求精确且完整。</li><li>标准的版本号必须（MUST）采用 X.Y.Z 的格式，其中 X、Y 和 Z 为非负的整数，且禁止（MUST NOT）在数字前方补零。X 是主版本号、Y 是次版本号、而 Z 为修订号。每个元素必须（MUST）以数值来递增。例如：1.9.1 -&gt; 1.10.0 -&gt; 1.11.0。</li><li>标记版本号的软件发行后，禁止（MUST NOT）改变该版本软件的内容。任何修改都必须（MUST）以新版本发行。</li><li>主版本号为零（0.y.z）的软件处于开发初始阶段，一切都可能随时被改变。这样的公共 API 不应该被视为稳定版。</li><li>1.0.0 的版本号用于界定公共 API 的形成。这一版本之后所有的版本号更新都基于公共 API 及其修改内容。</li><li>修订号 Z（x.y.Z <code>|</code> x &gt; 0）必须（MUST）在只做了向下兼容的修正时才递增。这里的修正指的是针对不正确结果而进行的内部修改。</li><li>次版本号 Y（x.Y.z <code>|</code> x &gt; 0）必须（MUST）在有向下兼容的新功能出现时递增。在任何公共 API 的功能被标记为弃用时也必须（MUST）递增。也可以（MAY）在内部程序有大量新功能或改进被加入时递增，其中可以（MAY）包括修订级别的改变。每当次版本号递增时，修订号必须（MUST）归零。</li><li>主版本号 X（X.y.z <code>|</code> X &gt; 0）必须（MUST）在有任何不兼容的修改被加入公共 API 时递增。其中可以（MAY）包括次版本号及修订级别的改变。每当主版本号递增时，次版本号和修订号必须（MUST）归零。</li><li>先行版本号可以（MAY）被标注在修订版之后，先加上一个连接号再加上一连串以句点分隔的标识符来修饰。标识符必须（MUST）由 ASCII 字母数字和连接号 [0-9A-Za-z-] 组成，且禁止（MUST NOT）留白。数字型的标识符禁止（MUST NOT）在前方补零。先行版的优先级低于相关联的标准版本。被标上先行版本号则表示这个版本并非稳定而且可能无法满足预期的兼容性需求。范例：1.0.0-alpha、1.0.0-alpha.1、1.0.0-0.3.7、1.0.0-x.7.z.92。</li><li>版本编译信息可以（MAY）被标注在修订版或先行版本号之后，先加上一个加号再加上一连串以句点分隔的标识符来修饰。标识符必须（MUST）由 ASCII 字母数字和连接号 [0-9A-Za-z-] 组成，且禁止（MUST NOT）留白。当判断版本的优先层级时，版本编译信息可（SHOULD）被忽略。因此当两个版本只有在版本编译信息有差别时，属于相同的优先层级。范例：1.0.0-alpha+001、1.0.0+20130313144700、1.0.0-beta+exp.sha.5114f85。</li><li>版本的优先层级指的是不同版本在排序时如何比较。判断优先层级时，必须（MUST）把版本依序拆分为主版本号、次版本号、修订号及先行版本号后进行比较（版本编译信息不在这份比较的列表中）。由左到右依序比较每个标识符，第一个差异值用来决定优先层级：主版本号、次版本号及修订号以数值比较，例如：1.0.0 &lt; 2.0.0 &lt; 2.1.0 &lt; 2.1.1。当主版本号、次版本号及修订号都相同时，改以优先层级比较低的先行版本号决定。例如：1.0.0-alpha &lt; 1.0.0。有相同主版本号、次版本号及修订号的两个先行版本号，其优先层级必须（MUST）透过由左到右的每个被句点分隔的标识符来比较，直到找到一个差异值后决定：只有数字的标识符以数值高低比较，有字母或连接号时则逐字以 ASCII 的排序来比较。数字的标识符比非数字的标识符优先层级低。若开头的标识符都相同时，栏位比较多的先行版本号优先层级比较高。范例：1.0.0-alpha &lt; 1.0.0-alpha.1 &lt; 1.0.0-alpha.beta &lt; 1.0.0-beta &lt; 1.0.0-beta.2 &lt; 1.0.0-beta.11 &lt; 1.0.0-rc.1 &lt; 1.0.0。</li></ol><h2 id="为什么要使用语义化的版本控制？"><a href="#为什么要使用语义化的版本控制？" class="headerlink" title="为什么要使用语义化的版本控制？"></a>为什么要使用语义化的版本控制？</h2><p>这并不是一个新的或者革命性的想法。实际上，你可能已经在做一些近似的事情了。问题在于只是“近似”还不够。如果没有某个正式的规范可循，版本号对于依赖的管理并无实质意义。将上述的想法命名并给予清楚的定义，让你对软件使用者传达意向变得容易。一旦这些意向变得清楚，弹性（但又不会太弹性）的依赖规范就能达成。</p><p>举个简单的例子就可以展示语义化的版本控制如何让依赖地狱成为过去。假设有个名为“救火车”的函数库，它需要另一个名为“梯子”并已经有使用语义化版本控制的包。当救火车创建时，梯子的版本号为 3.1.0。因为救火车使用了一些版本 3.1.0 所新增的功能，你可以放心地指定依赖于梯子的版本号大于等于 3.1.0 但小于 4.0.0。这样，当梯子版本 3.1.1 和 3.2.0 发布时，你可以将直接它们纳入你的包管理系统，因为它们能与原有依赖的软件兼容。</p><p>作为一位负责任的开发者，你理当确保每次包升级的运作与版本号的表述一致。现实世界是复杂的，我们除了提高警觉外能做的不多。你所能做的就是让语义化的版本控制为你提供一个健全的方式来发行以及升级包，而无需推出新的依赖包，节省你的时间及烦恼。</p><p>如果你对此认同，希望立即开始使用语义化版本控制，你只需声明你的函数库正在使用它并遵循这些规则就可以了。请在你的 README 文件中保留此页链接，让别人也知道这些规则并从中受益。</p><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><h3 id="在-0-y-z-初始开发阶段，我该如何进行版本控制？"><a href="#在-0-y-z-初始开发阶段，我该如何进行版本控制？" class="headerlink" title="在 0.y.z 初始开发阶段，我该如何进行版本控制？"></a>在 0.y.z 初始开发阶段，我该如何进行版本控制？</h3><p>最简单的做法是以 0.1.0 作为你的初始化开发版本，并在后续的每次发行时递增次版本号。</p><h3 id="如何判断发布-1-0-0-版本的时机？"><a href="#如何判断发布-1-0-0-版本的时机？" class="headerlink" title="如何判断发布 1.0.0 版本的时机？"></a>如何判断发布 1.0.0 版本的时机？</h3><p>当你的软件被用于正式环境，它应该已经达到了 1.0.0 版。如果你已经有个稳定的 API 被使用者依赖，也会是 1.0.0 版。如果你很担心向下兼容的问题，也应该算是 1.0.0 版了。</p><h3 id="这不会阻碍快速开发和迭代吗？"><a href="#这不会阻碍快速开发和迭代吗？" class="headerlink" title="这不会阻碍快速开发和迭代吗？"></a>这不会阻碍快速开发和迭代吗？</h3><p>主版本号为零的时候就是为了做快速开发。如果你每天都在改变 API，那么你应该仍在主版本号为零的阶段（0.y.z），或是正在下个主版本的独立开发分支中。</p><h3 id="对于公共-API，若即使是最小但不向下兼容的改变都需要产生新的主版本号，岂不是很快就达到-42-0-0-版？"><a href="#对于公共-API，若即使是最小但不向下兼容的改变都需要产生新的主版本号，岂不是很快就达到-42-0-0-版？" class="headerlink" title="对于公共 API，若即使是最小但不向下兼容的改变都需要产生新的主版本号，岂不是很快就达到 42.0.0 版？"></a>对于公共 API，若即使是最小但不向下兼容的改变都需要产生新的主版本号，岂不是很快就达到 42.0.0 版？</h3><p>这是开发的责任感和前瞻性的问题。不兼容的改变不应该轻易被加入到有许多依赖代码的软件中。升级所付出的代价可能是巨大的。要递增主版本号来发行不兼容的改版，意味着你必须为这些改变所带来的影响深思熟虑，并且评估所涉及的成本及效益比。</p><h3 id="为整个公共-API-写文件太费事了！"><a href="#为整个公共-API-写文件太费事了！" class="headerlink" title="为整个公共 API 写文件太费事了！"></a>为整个公共 API 写文件太费事了！</h3><p>为供他人使用的软件编写适当的文件，是你作为一名专业开发者应尽的职责。保持专案高效一个非常重要的部份是掌控软件的复杂度，如果没有人知道如何使用你的软件或不知道哪些函数的调用是可靠的，要掌控复杂度会是困难的。长远来看，使用语义化版本控制以及对于公共 API 有良好规范的坚持，可以让每个人及每件事都运行顺畅。</p><h3 id="万一不小心把一个不兼容的改版当成了次版本号发行了该怎么办？"><a href="#万一不小心把一个不兼容的改版当成了次版本号发行了该怎么办？" class="headerlink" title="万一不小心把一个不兼容的改版当成了次版本号发行了该怎么办？"></a>万一不小心把一个不兼容的改版当成了次版本号发行了该怎么办？</h3><p>一旦发现自己破坏了语义化版本控制的规范，就要修正这个问题，并发行一个新的次版本号来更正这个问题并且恢复向下兼容。即使是这种情况，也不能去修改已发行的版本。可以的话，将有问题的版本号记录到文件中，告诉使用者问题所在，让他们能够意识到这是有问题的版本。</p><h3 id="如果我更新了自己的依赖但没有改变公共-API-该怎么办？"><a href="#如果我更新了自己的依赖但没有改变公共-API-该怎么办？" class="headerlink" title="如果我更新了自己的依赖但没有改变公共 API 该怎么办？"></a>如果我更新了自己的依赖但没有改变公共 API 该怎么办？</h3><p>由于没有影响到公共 API，这可以被认定是兼容的。若某个软件和你的包有共同依赖，则它会有自己的依赖规范，作者也会告知可能的冲突。要判断改版是属于修订等级或是次版等级，是依据你更新的依赖关系是为了修复问题或是加入新功能。对于后者，我经常会预期伴随着更多的代码，这显然会是一个次版本号级别的递增。</p><h3 id="如果我变更了公共-API-但无意中未遵循版本号的改动怎么办呢？（意即在修订等级的发布中，误将重大且不兼容的改变加到代码之中）"><a href="#如果我变更了公共-API-但无意中未遵循版本号的改动怎么办呢？（意即在修订等级的发布中，误将重大且不兼容的改变加到代码之中）" class="headerlink" title="如果我变更了公共 API 但无意中未遵循版本号的改动怎么办呢？（意即在修订等级的发布中，误将重大且不兼容的改变加到代码之中）"></a>如果我变更了公共 API 但无意中未遵循版本号的改动怎么办呢？（意即在修订等级的发布中，误将重大且不兼容的改变加到代码之中）</h3><p>自行做最佳的判断。如果你有庞大的使用者群在依照公共 API 的意图而变更行为后会大受影响，那么最好做一次主版本的发布，即使严格来说这个修复仅是修订等级的发布。记住， 语义化的版本控制就是透过版本号的改变来传达意义。若这些改变对你的使用者是重要的，那就透过版本号来向他们说明。</p><h3 id="我该如何处理即将弃用的功能？"><a href="#我该如何处理即将弃用的功能？" class="headerlink" title="我该如何处理即将弃用的功能？"></a>我该如何处理即将弃用的功能？</h3><p>弃用现存的功能是软件开发中的家常便饭，也通常是向前发展所必须的。当你弃用部份公共 API 时，你应该做两件事：（1）更新你的文件让使用者知道这个改变，（2）在适当的时机将弃用的功能透过新的次版本号发布。在新的主版本完全移除弃用功能前，至少要有一个次版本包含这个弃用信息，这样使用者才能平顺地转移到新版 API。</p><h3 id="语义化版本对于版本的字串长度是否有限制呢？"><a href="#语义化版本对于版本的字串长度是否有限制呢？" class="headerlink" title="语义化版本对于版本的字串长度是否有限制呢？"></a>语义化版本对于版本的字串长度是否有限制呢？</h3><p>没有，请自行做适当的判断。举例来说，长到 255 个字元的版本已过度夸张。再者，特定的系统对于字串长度可能会有他们自己的限制。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔/杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 版本控制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件设计模式之单例模式</title>
      <link href="/2021/11/10/cpp_singleton_pattern/"/>
      <url>/2021/11/10/cpp_singleton_pattern/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="什么是单例模式？"><a href="#什么是单例模式？" class="headerlink" title="什么是单例模式？"></a>什么是单例模式？</h2><p>有的时候我们需要应用程序中的某个实例在运行期间有且只能有一个实例，程序运行时没有任何方法实现创建多于一个的实例，这种情况我们称之为软件设计模式——单例模式。</p><p>比如我们软件运行时，有且只能有一个日志对象…….</p><a id="more"></a><h2 id="单例模式实现"><a href="#单例模式实现" class="headerlink" title="单例模式实现"></a>单例模式实现</h2><p>单例模式实现时将类的构造函数私有化，使得外部方法无法通过类的构造函数构造对于一个的类对象，从而保证对象的唯一性。</p><h3 id="单例模式分类"><a href="#单例模式分类" class="headerlink" title="单例模式分类"></a>单例模式分类</h3><p>软件设计模式的单例模式实现有两种：</p><ul><li>饿汉模式：类定义的时候实现对象实例化（饿汉，很饿，要马上吃饭）。</li><li>懒汉模式：类使用的时候实现对象实例化（懒汉，不那么饿，稍后再吃）。</li></ul><h3 id="单例模式之饿汉实现"><a href="#单例模式之饿汉实现" class="headerlink" title="单例模式之饿汉实现"></a>单例模式之饿汉实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单例模式 饿汉实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonHungry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">//构造函数私有化，不允许外部方法通过new来创建实例</span></span><br><span class="line">  SingletonHungry()&#123;&#125;</span><br><span class="line">  <span class="keyword">static</span> SingletonHungry *p1;   <span class="comment">//静态成员变量声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> SingletonHungry *<span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">SingletonHungry *SingletonHungry::p1 = <span class="keyword">new</span> SingletonHungry();     <span class="comment">//静态成员变量的定义及初始化</span></span><br><span class="line">SingletonHungry *SingletonHungry::getInstance()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"单例模式，饿汉实现进行对象实例化\n"</span>);</span><br><span class="line">  <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单例模式的饿汉实现中在类定义时已经实现的对象的实例化，所以对于单线程/多线程的环境都是安全的。</p><h3 id="单例模式之懒汉实现"><a href="#单例模式之懒汉实现" class="headerlink" title="单例模式之懒汉实现"></a>单例模式之懒汉实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单例模式 懒汉模式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonLazy1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">//构造函数私有化</span></span><br><span class="line">  SingletonLazy1()&#123;&#125;</span><br><span class="line">  <span class="keyword">static</span> SingletonLazy1 *p2;    <span class="comment">//静态成员变量声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> SingletonLazy1 *<span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">SingletonLazy1 *SingletonLazy1::p2 = <span class="literal">nullptr</span>;      <span class="comment">//静态成员变量的定义及初始化</span></span><br><span class="line">SingletonLazy1 *SingletonLazy1::getInstance()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"单例模式，懒汉实现进行对象初始化\n"</span>);</span><br><span class="line">  &#123;</span><br><span class="line">     <span class="keyword">if</span>(p2 == <span class="literal">nullptr</span>)</span><br><span class="line">     &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> SingletonLazy1();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> p2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，对于上面的懒汉模式代码实现单线程运行时毫无疑问是正确的，但是多线程环境下，会创建多于一个的对象实例。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单例模式 懒汉模式，加锁机制实现线程安全</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonLazy1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">//构造函数私有化</span></span><br><span class="line">  SingletonLazy1()&#123;&#125;</span><br><span class="line">  <span class="keyword">static</span> SingletonLazy1 *p2;    <span class="comment">//静态成员变量声明</span></span><br><span class="line">  <span class="keyword">static</span> mutex lock_;           <span class="comment">//静态成员变量声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> SingletonLazy1 *<span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">SingletonLazy1 *SingletonLazy1::p2 = <span class="literal">nullptr</span>;      <span class="comment">//静态成员变量的定义及初始化</span></span><br><span class="line"><span class="built_in">std</span>::mutex SingletonLazy1::lock_;                  <span class="comment">//静态成员变量的定义</span></span><br><span class="line">SingletonLazy1 *SingletonLazy1::getInstance()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"单例模式，懒汉实现进行对象初始化\n"</span>);</span><br><span class="line">  &#123;</span><br><span class="line">     <span class="comment">//对象实例化加锁，保证线程安全</span></span><br><span class="line">     lock_guard&lt;mutex&gt; my_lock(lock_);</span><br><span class="line">     <span class="keyword">if</span>(p2 == <span class="literal">nullptr</span>)</span><br><span class="line">     &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> SingletonLazy1();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> p2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上单例模式懒汉实现代码中，对于对象实例的部分加锁，这样即使在多线程运行时，也能够保证程序运行时只创建一个对象。</p><p>但是，可以观察到这种方法虽然安全却不高效，因为每次运行到实例化对象的这部分代码时都需要加锁，但其实我们只需要在第一次运行此部分代码时需要加锁，此后运行的任何一次都不需要加锁，所以这种实现方法导致性能浪费。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单例模式 懒汉模式，DLCP(双重检查锁模式----Double-Checked Locking Pattern)实现线程安全</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonLazy2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">//构造函数私有化</span></span><br><span class="line">  SingletonLazy2()&#123;&#125;</span><br><span class="line">  <span class="keyword">static</span> SingletonLazy2 *p3;     <span class="comment">//静态成员变量声明</span></span><br><span class="line">  <span class="keyword">static</span> mutex lock_;            <span class="comment">//静态成员变量声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> SingletonLazy2 *<span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">SingletonLazy2 *SingletonLazy2::p3 = <span class="literal">nullptr</span>;     <span class="comment">//静态成员变量的定义及初始化</span></span><br><span class="line"><span class="built_in">std</span>::mutex SingletonLazy2::lock_;                 <span class="comment">//静态成员变量的定义</span></span><br><span class="line">SingletonLazy2 *SingletonLazy2::getInstance()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"单例模式，懒汉实现进行对象实例化DCLP\n"</span>);</span><br><span class="line">  <span class="keyword">if</span>(p3 == <span class="literal">nullptr</span>)</span><br><span class="line">  &#123;</span><br><span class="line">     lock_.lock();</span><br><span class="line">     <span class="keyword">if</span>(p3 == <span class="literal">nullptr</span>)</span><br><span class="line">     &#123;</span><br><span class="line">       p3 = <span class="keyword">new</span> SingletonLazy2();</span><br><span class="line">     &#125;</span><br><span class="line">     lock_.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> p3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所谓单例模式懒汉DCLP实现是指实例化对象时进行两次判空操作（上述代码第18，21行），为什么需要两次判空操作？🤦‍♂️🤦‍♂️🤦‍♂️</p><p>如果没有第18行的判空操作，那么上述代码与普通加锁实现无异，多线程安全但性能不高。</p><p>如果没有第21行的判空操作，假设有两个线程thread1、thread2都执行了第18行，但是thread1获得CPU时间片开始执行第20，23，25行，成功创建了一个对象，然后thread2获得CPU时间片，再次执行第20，23，25行，导致程序中出现多个对象实例。</p><p><strong>所以，两次判空不可少！！！</strong></p><p>上述DCLP实现看起来完美，但是，代码运行时并没有想象的那么完美，代码中存在重大漏洞，原因是：<strong>内存读写的乱序执行(编译器问题)</strong>。</p><p>那到底怎么解决？？？😢😢😢算了写不下去了，贴个连接备忘一下，我太菜了，其实是没看懂解决方法。</p><p>C++11标准中定义了线程、原子操作以及新的内存模型，通过这些新增的标准可以正确的实现单例模式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::atomic&lt;Singleton*&gt; Singleton::instance_;</span><br><span class="line"><span class="built_in">std</span>::mutex Singleton::m_mutex;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::Instance() &#123;</span><br><span class="line">    Singleton* temp = instance_.load(<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">    <span class="built_in">std</span>::atomic_thread_fence(<span class="built_in">std</span>::memory_order_acquire);</span><br><span class="line">    <span class="keyword">if</span> (temp == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock(m_mutex);</span><br><span class="line">        temp = instance_.load(<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            temp = <span class="keyword">new</span> Singleton;</span><br><span class="line">            <span class="built_in">std</span>::atomic_thread_fence(<span class="built_in">std</span>::memory_order_release);</span><br><span class="line">            instance_.store(temp, <span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://light-city.club/sc/design_pattern/singleton/singleton/#3" target="_blank" rel="noopener">C++设计模式之单例模式</a></p><p><a href="https://blog.csdn.net/qq_33774822/article/details/83095898?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-8.no_search_link&amp;spm=1001.2101.3001.4242.5" target="_blank" rel="noopener">大话设计模式之单例模式</a></p><p><a href="https://cloud.tencent.com/developer/article/1583894" target="_blank" rel="noopener">C++ 多线程互斥锁(mutex，lock，lock_guard)</a></p><p><a href="https://blog.csdn.net/fawdlstty/article/details/49491133" target="_blank" rel="noopener">C++11：原子操作</a></p><p><a href="https://developer.51cto.com/art/201311/419604.htm" target="_blank" rel="noopener">C++11 修复了双重检查锁定问题</a></p><p><a href="https://github.com/ljsong/Blog/blob/master/C++%E4%B8%AD%E7%9A%84Singleton(%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">C++中的Singleton（单例模式）及其实现</a>%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0.md)</p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 单例模式 </tag>
            
            <tag> DCLP </tag>
            
            <tag> 锁机制 </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git常用命令</title>
      <link href="/2021/10/27/Git_common_commands/"/>
      <url>/2021/10/27/Git_common_commands/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mkdir &lt;filename&gt;           &#x2F;&#x2F;创建目录  </span><br><span class="line">cd &lt;filename&gt;              &#x2F;&#x2F;进入指定文件夹</span><br><span class="line">rm &lt;filename&gt;              &#x2F;&#x2F;工作区删除文件</span><br><span class="line">rm -rf &lt;foldername&gt;        &#x2F;&#x2F;工作区删除文件夹</span><br><span class="line">pwd                        &#x2F;&#x2F;打印当前路径</span><br><span class="line">cat &lt;filename&gt;             &#x2F;&#x2F;查看指定文件的内容</span><br><span class="line">ls -a                      &#x2F;&#x2F;查看隐藏的.git文件，.git文件是git版本库，里面的stage就是暂存区</span><br><span class="line">git init                   &#x2F;&#x2F;将命令运行的目录变成git可以管理的仓库</span><br><span class="line">git add &lt;filename&gt;         &#x2F;&#x2F;将指定文件从工作区添加到暂存区</span><br><span class="line">git commit -m &quot;提交说明&quot;    &#x2F;&#x2F;将暂存区的所有文件提交到版本库，-m后面添加说明</span><br><span class="line">git status                 &#x2F;&#x2F;查看当前版本库状态</span><br><span class="line">git log                    &#x2F;&#x2F;查看历史版本记录</span><br><span class="line">git log --pretty&#x3D;oneline   &#x2F;&#x2F;查看历史记录，只不过一行显示更加清晰</span><br><span class="line">git reflog                 &#x2F;&#x2F;查看你的历史命令，可以看到历史版本的版本号，利用历史版本的版本号可以实现代码版本的回退</span><br><span class="line">git diff &lt;filename&gt;        &#x2F;&#x2F;查看该文件的具体修改内容</span><br><span class="line">git diff HEAD &lt;filename&gt;   &#x2F;&#x2F;查看工作区与版本库里面的最新版本的区别</span><br><span class="line">git reset --hard &lt;版本号&gt;   &#x2F;&#x2F;回退到指定版本号的版本</span><br><span class="line">git reset --hard HEAD^     &#x2F;&#x2F;回退到上一个版本</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>在git中，HEAD表示当前版本，HEAD^表示上一个版本，HEAD^^表示上上一个版本，前100个版本可以表示为HEAD~100。</strong></p><h2 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h2><p><code>git restore &lt;file&gt;</code></p><p><code>git checkout --&lt;file&gt;</code></p><ol><li><p>在未将修改内容<code>git add</code>到暂存区之前，可撤销工作区的修改</p></li><li><p>如果已经把修改后的内容<code>git add</code>到暂存区后，使用<code>git reset HEAD &lt;file&gt;</code> 可以撤销暂存区的修改，将其重新放回工作区，之后使用</p><p><code>git restore&lt;file&gt;</code> 撤销工作区的修改,回到最初的状态。</p><p><code>git reset</code>命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用<code>HEAD</code>时，表示最新的版本。</p><p><code>git rm &lt;filename&gt;</code> 从版本库删除文件</p></li><li><p>如果在工作区误删文件，使用<code>git checkout --&lt;filename&gt;</code>可以将版本库的版本替换到工作区从来没有被添加到版本库就被删除的文件，是无法恢复的！</p></li></ol><p>要关联一个远程库，使用命令<code>git remote add origin git@server-name:path/repo-name.git</code>；</p><p>关联一个远程库时必须给远程库指定一个名字，<code>origin</code>是默认习惯命名；</p><p><code>git remote -v</code> 查看远程库信息，包括名字和地址</p><p><code>git push origin &lt;分支名&gt;</code> 推送分支到远程库，<code>origin</code>是我的仓库名</p><p>关联后，使用命令<code>git push -u origin master</code>第一次推送<code>master</code>分支的所有内容；</p><p>此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改；</p><h2 id="创建新分支"><a href="#创建新分支" class="headerlink" title="创建新分支"></a>创建新分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git switch -c &lt;branch name&gt;          &#x2F;&#x2F;创建一个新分支，并切换当新分支</span><br><span class="line">git switch &lt;branch name&gt;             &#x2F;&#x2F;切换分支</span><br><span class="line">git branch                           &#x2F;&#x2F;查看当前分支，当前分支名字前面会显示*</span><br><span class="line">git branch -d &lt;branch name&gt;          &#x2F;&#x2F;删除分支</span><br><span class="line">git merge &lt;branch name&gt;              &#x2F;&#x2F;在当前分支合并指定的分支</span><br></pre></td></tr></table></figure><p><strong>在新分支修改后，必修add和commit才能上传至版本库，否则你只在工作区改动，无论是在原分支和新分支，cat 查看一个文件是一样的。</strong></p><h2 id="手动解决合并冲突"><a href="#手动解决合并冲突" class="headerlink" title="手动解决合并冲突"></a>手动解决合并冲突</h2><p>使用<code>vi &lt;filename&gt;</code> 查看并编辑文件内容，按下键盘上的<code>Insert</code>键进入编辑模式，完成后按下<code>Esc</code>键，之后</p><p><code>:q</code> 不保存退出</p><p><code>:q!</code> 不保存强制退出</p><p><code>:wq</code> 保存退出</p><p>切记要打 <strong><code>:</code></strong> 符号</p><p>编辑完成后保存退出，再次<code>git add</code>，<code>git commit</code>，之后手动合并成功</p><p><code>git log --graph</code> 查看分支合并图</p><p><code>git log --graph --pretty=oneline --abbrev-commit</code> 查看合并图更加清楚</p><h2 id="添加标签与管理标签"><a href="#添加标签与管理标签" class="headerlink" title="添加标签与管理标签"></a>添加标签与管理标签</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git tag &lt;label name&gt;                   &#x2F;&#x2F;新建一个标签，指向当前HEAD版本</span><br><span class="line">git tag &lt;label name&gt; commit-id         &#x2F;&#x2F;为commit-id的版本添加一个标签</span><br><span class="line">git tag -a &lt;label name&gt; -m&quot;说明备注&quot;    &#x2F;&#x2F;指定标签信息</span><br><span class="line">git show &lt;label name&gt;                  &#x2F;&#x2F;查看某一标签详细信息</span><br><span class="line">git tag                                &#x2F;&#x2F;查看当前所有标签</span><br><span class="line">git push origin &lt;label name&gt;           &#x2F;&#x2F;推送本地标签</span><br><span class="line">git push origin --tags                 &#x2F;&#x2F;推送全部未推送的本地标签</span><br><span class="line">git tag -d &lt;label name&gt;                &#x2F;&#x2F;删除一个本地标签</span><br><span class="line">git push origin :refs&#x2F;tags&#x2F;&lt;label name&gt;            &#x2F;&#x2F;删除一个远程标签</span><br></pre></td></tr></table></figure><h2 id="参与github开源"><a href="#参与github开源" class="headerlink" title="参与github开源"></a>参与github开源</h2><p>找到一个开源项目，点击右上角<code>Fork</code>即可将项目复制到自己的<code>github</code></p><p>本地创建一个空文件夹，<code>git init</code>作为仓库</p><p><code>git clone [git@github.com](mailto:git@github.com):Fallenpetal/仓库名.git</code></p><p>如果文件过大，按<code>Ctrl + c</code>取消克隆</p><p>在本地修改，如果想参与官方的开源，<code>pull request</code></p><h2 id="忽略特殊文件"><a href="#忽略特殊文件" class="headerlink" title="忽略特殊文件"></a>忽略特殊文件</h2><p>在工作区创建<code>.gitignore</code>文件</p><p>在里面加入想忽略的文件，这样每次改动<code>git</code>不会再提醒你<code>untracked</code></p><p>加入格式为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#java:</span><br><span class="line">*.class</span><br></pre></td></tr></table></figure><p>`#<code>是注释，</code>*.class<code>表示会忽视所有后缀为</code>.class`的文件</p><p>被<code>ignore</code>的文件，如果想强制添加，<code>git add -f app.class</code></p><p>使用<code>git check-ignore -v app.class</code> 查看<code>app.class</code>被忽略的准则，精确到第几行</p><p>把指定文件排除在<code>.gitignore</code>规则外的写法就是<code>!+文件名</code>，例如<code>!app.class</code></p><h2 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a>配置别名</h2><p>命令格式：<code>git config --global alias.别名 原命令名</code></p><p>比如 <code>git config --gloab [alias.st](http://alias.st/) status</code>，这样做，我们输入<code>git st</code>就表示<code>git status</code> <code>--global</code>参数是全局参数，也就是这些命令在这台电脑的所有<code>Git</code>仓库下都有用。配置<code>Git</code>的时候，加上<code>--global</code>是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。</p><p>每个仓库的<code>Git</code>配置文件都放在<code>.git/config</code>文件中：<code>$ cat .git/config</code> 查看</p><p>当前用户的<code>Git</code>配置文件放在用户主目录下的一个隐藏文件<code>.gitconfig</code>中：<code>$ cat .gitconfig</code> 查看</p>]]></content>
      
      
      <categories>
          
          <category> GitHub </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 标准库算法源代码剖析</title>
      <link href="/2021/07/26/cpp_algorithm_analysis/"/>
      <url>/2021/07/26/cpp_algorithm_analysis/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="一、-算法-accumulate"><a href="#一、-算法-accumulate" class="headerlink" title="一、 算法 accumulate"></a>一、 算法 accumulate</h2><h3 id="1-功能"><a href="#1-功能" class="headerlink" title="1. 功能"></a>1. 功能</h3><p>对容器内的元素进行累计（不限于累加运算，可以是自己传进去的运算）。</p><a id="more"></a><h3 id="2-可能的实现"><a href="#2-可能的实现" class="headerlink" title="2.  可能的实现"></a>2.  可能的实现</h3><p>版本一：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIt</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">constexpr</span> // <span class="title">C</span>++20 起</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">accumulate</span>(<span class="title">InputIt</span> <span class="title">first</span>, <span class="title">InputIt</span> <span class="title">last</span>, <span class="title">T</span> <span class="title">init</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">for</span> (; first != last; ++first) &#123;</span><br><span class="line">        init = <span class="built_in">std</span>::<span class="built_in">move</span>(init) + *first; <span class="comment">// C++20 起有 std::move</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> init;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>版本二：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIt</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">BinaryOperation</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">constexpr</span> // <span class="title">C</span>++20 起</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">accumulate</span>(<span class="title">InputIt</span> <span class="title">first</span>, <span class="title">InputIt</span> <span class="title">last</span>, <span class="title">T</span> <span class="title">init</span>, </span></span><br><span class="line"><span class="class">             <span class="title">BinaryOperation</span> <span class="title">op</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">for</span> (; first != last; ++first) &#123;</span><br><span class="line">        init = op(<span class="built_in">std</span>::<span class="built_in">move</span>(init), *first); <span class="comment">// C++20 起有 std::move</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> init;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-示例"><a href="#3-示例" class="headerlink" title="3. 示例"></a>3. 示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myfunc</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + <span class="number">2</span> * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFunc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">T <span class="title">operator</span><span class="params">()</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + <span class="number">3</span> * b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mystuct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + <span class="number">2</span> * b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;myobj;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> init = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> num[] = &#123; <span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span> &#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"accumulate default:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; accumulate(num, num + <span class="number">3</span>, init) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"accumulate minus:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; accumulate(num, num + <span class="number">3</span>, init, minus&lt;<span class="keyword">int</span>&gt;()) &lt;&lt; <span class="built_in">endl</span>;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"accumulate myfunc function:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; accumulate(num, num + <span class="number">3</span>, init, myfunc) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"accumulate template class:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; accumulate(num, num + <span class="number">3</span>, init, MyFunc&lt;<span class="keyword">int</span>&gt;()) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"accumulate myobj class:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; accumulate(num, num + <span class="number">3</span>, init, myobj) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">accumulate <span class="keyword">default</span>:</span><br><span class="line"><span class="number">190</span></span><br><span class="line">accumulate minus:</span><br><span class="line"><span class="number">10</span></span><br><span class="line">accumulate myfunc function:</span><br><span class="line"><span class="number">280</span></span><br><span class="line">accumulate <span class="keyword">template</span> <span class="class"><span class="keyword">class</span>:</span></span><br><span class="line"><span class="number">370</span></span><br><span class="line">accumulate myobj <span class="class"><span class="keyword">class</span>:</span></span><br><span class="line"><span class="number">280</span></span><br></pre></td></tr></table></figure><h2 id="二、算法-for-each"><a href="#二、算法-for-each" class="headerlink" title="二、算法 for_each"></a>二、算法 for_each</h2><h3 id="1-功能-1"><a href="#1-功能-1" class="headerlink" title="1. 功能"></a>1. 功能</h3><p>对一段元素或一个区间内的元素进行一个操作，一个程序员可以指定的操作。</p><h3 id="2-可能的实现-1"><a href="#2-可能的实现-1" class="headerlink" title="2. 可能的实现"></a>2. 可能的实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIt</span>, <span class="title">class</span> <span class="title">UnaryFunction</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">UnaryFunction</span> <span class="title">for_each</span>(<span class="title">InputIt</span> <span class="title">first</span>, <span class="title">InputIt</span> <span class="title">last</span>, <span class="title">UnaryFunction</span> <span class="title">f</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">for</span> (; first != last; ++first) &#123;</span><br><span class="line">        f(*first);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f; <span class="comment">// C++11 起隐式移动</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-示例-1"><a href="#3-示例-1" class="headerlink" title="3. 示例"></a>3. 示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfunc</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>&lt;&lt;i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mystruct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>&lt;&lt;i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;myobj;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; num&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>&#125;;</span><br><span class="line">    for_each(num.<span class="built_in">begin</span>(), num.<span class="built_in">end</span>(), myfunc);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;    </span><br><span class="line"></span><br><span class="line">    for_each(num.<span class="built_in">begin</span>(), num.<span class="built_in">end</span>(), myobj);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、算法-replace-replace-if-replace-copy"><a href="#三、算法-replace-replace-if-replace-copy" class="headerlink" title="三、算法 replace, replace_if, replace_copy"></a>三、算法 replace, replace_if, replace_copy</h2><h3 id="1-功能-2"><a href="#1-功能-2" class="headerlink" title="1. 功能"></a>1. 功能</h3><p>对范围内的元素批量化进行一个操作。</p><h3 id="2-可能的实现-2"><a href="#2-可能的实现-2" class="headerlink" title="2. 可能的实现"></a>2. 可能的实现</h3><p>replace</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIt</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">replace</span>(<span class="title">ForwardIt</span> <span class="title">first</span>, <span class="title">ForwardIt</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">             <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">old_value</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">new_value</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//范围内所有等同于old_value的值都以new_value取代</span></span><br><span class="line">    <span class="keyword">for</span> (; first != last; ++first) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*first == old_value) &#123;</span><br><span class="line">            *first = new_value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>replace_if</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIt</span>, <span class="title">class</span> <span class="title">UnaryPredicate</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">replace_if</span>(<span class="title">ForwardIt</span> <span class="title">first</span>, <span class="title">ForwardIt</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">                <span class="title">UnaryPredicate</span> <span class="title">p</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">new_value</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//范围内所有满足p()操作的值都已new_value取代</span></span><br><span class="line">    <span class="keyword">for</span> (; first != last; ++first) &#123;</span><br><span class="line">        <span class="keyword">if</span>(p(*first)) &#123;</span><br><span class="line">            *first = new_value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>replace_copy</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIt</span>, <span class="title">class</span> <span class="title">OutputIt</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">OutputIt</span> <span class="title">replace_copy</span>(<span class="title">InputIt</span> <span class="title">first</span>, <span class="title">InputIt</span> <span class="title">last</span>, <span class="title">OutputIt</span> <span class="title">d_first</span>,</span></span><br><span class="line"><span class="class">                      <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">old_value</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">new_value</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//范围内所有等同于old_value的值都以new_value放至新区间，不符合者原值放入新区间</span></span><br><span class="line">    <span class="keyword">for</span> (; first != last; ++first) &#123;</span><br><span class="line">        *d_first++ = (*first == old_value) ? new_value : *first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d_first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.apiref.com/cpp-zh/cpp/algorithm/replace.html" target="_blank" rel="noopener">replace/replace_if</a>、<a href="https://www.apiref.com/cpp-zh/cpp/algorithm/replace_copy_if.html" target="_blank" rel="noopener">replace_copy</a></p><h2 id="四、算法-count-count-if"><a href="#四、算法-count-count-if" class="headerlink" title="四、算法 count, count_if"></a>四、算法 count, count_if</h2><h3 id="1-功能-3"><a href="#1-功能-3" class="headerlink" title="1. 功能"></a>1. 功能</h3><p>计算一个区间内符合一个条件的元素有多少个。</p><h3 id="2-可能的实现-3"><a href="#2-可能的实现-3" class="headerlink" title="2. 可能的实现"></a>2. 可能的实现</h3><p>版本一</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">count_fn</span> &#123;</span></span><br><span class="line">  <span class="keyword">template</span>&lt; <span class="built_in">std</span>::input_iterator I, <span class="built_in">std</span>::sentinel_for&lt;I&gt; S,</span><br><span class="line">          <span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Proj</span> = <span class="title">std</span>:</span>:identity &gt;</span><br><span class="line">  <span class="keyword">requires</span> <span class="built_in">std</span>::indirect_binary_predicate&lt;ranges::equal_to, <span class="built_in">std</span>::projected&lt;I, Proj&gt;, </span><br><span class="line">                                        <span class="keyword">const</span> T*&gt;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="built_in">std</span>::<span class="keyword">iter_difference_t</span>&lt;I&gt;</span><br><span class="line">    <span class="keyword">operator</span>()( I first, S last, <span class="keyword">const</span> T&amp; value, Proj proj = &#123;&#125; ) <span class="keyword">const</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">iter_difference_t</span>&lt;I&gt; counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; first != last; ++first) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">std</span>::invoke(proj, *first) == value)</span><br><span class="line">      &#123;</span><br><span class="line">        ++counter;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">template</span>&lt; ranges::input_range R, <span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Proj</span> = <span class="title">std</span>:</span>:identity &gt;</span><br><span class="line">  <span class="keyword">requires</span> <span class="built_in">std</span>::indirect_binary_predicate&lt;ranges::equal_to,</span><br><span class="line">                                          <span class="built_in">std</span>::projected&lt;ranges::<span class="keyword">iterator_t</span>&lt;R&gt;, Proj&gt;,</span><br><span class="line">                                          <span class="keyword">const</span> T*&gt;</span><br><span class="line">  <span class="keyword">constexpr</span> ranges::<span class="keyword">range_difference_t</span>&lt;R&gt;</span><br><span class="line">    <span class="keyword">operator</span>()( R&amp;&amp; r, <span class="keyword">const</span> T&amp; value, Proj proj = &#123;&#125; ) <span class="keyword">const</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> (*<span class="keyword">this</span>)(ranges::<span class="built_in">begin</span>(r), ranges::<span class="built_in">end</span>(r), value, <span class="built_in">std</span>::ref(proj));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> count_fn count;</span><br></pre></td></tr></table></figure><p>版本二</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">count_if_fn</span> &#123;</span></span><br><span class="line">  <span class="keyword">template</span>&lt; <span class="built_in">std</span>::input_iterator I, <span class="built_in">std</span>::sentinel_for&lt;I&gt; S,</span><br><span class="line">            <span class="class"><span class="keyword">class</span> <span class="title">Proj</span> = <span class="title">std</span>:</span>:identity,</span><br><span class="line">            <span class="built_in">std</span>::indirect_unary_predicate&lt;<span class="built_in">std</span>::projected&lt;I, Proj&gt;&gt; Pred &gt;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="built_in">std</span>::<span class="keyword">iter_difference_t</span>&lt;I&gt;</span><br><span class="line">    <span class="keyword">operator</span>()( I first, S last, Pred pred = &#123;&#125;, Proj proj = &#123;&#125; ) <span class="keyword">const</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">iter_difference_t</span>&lt;I&gt; counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; first != last; ++first) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">std</span>::invoke(pred, <span class="built_in">std</span>::invoke(proj, *first)))</span><br><span class="line">      &#123;</span><br><span class="line">        ++counter;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">template</span>&lt; ranges::input_range R, <span class="class"><span class="keyword">class</span> <span class="title">Proj</span> = <span class="title">std</span>:</span>:identity,</span><br><span class="line">            <span class="built_in">std</span>::indirect_unary_predicate&lt;<span class="built_in">std</span>::projected&lt;ranges::<span class="keyword">iterator_t</span>&lt;R&gt;, Proj&gt;&gt; Pred &gt;</span><br><span class="line">  <span class="keyword">constexpr</span> ranges::<span class="keyword">range_difference_t</span>&lt;R&gt;</span><br><span class="line">    <span class="keyword">operator</span>()( R&amp;&amp; r, Pred pred = &#123;&#125;, Proj proj = &#123;&#125; ) <span class="keyword">const</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> (*<span class="keyword">this</span>)(ranges::<span class="built_in">begin</span>(r), ranges::<span class="built_in">end</span>(r),</span><br><span class="line">                   <span class="built_in">std</span>::ref(pred), <span class="built_in">std</span>::ref(proj));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> count_if_fn count_if;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
            <tag> 标准库 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ this指针</title>
      <link href="/2021/07/22/cpp_this_pointer/"/>
      <url>/2021/07/22/cpp_this_pointer/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>参考文章：</strong></p><ol><li><p><a href="https://zhuanlan.zhihu.com/p/94864064" target="_blank" rel="noopener">C++ this指针的理解和作用</a></p></li><li><p><a href="https://blog.csdn.net/weixin_43751983/article/details/91147918?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-2.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-2.control" target="_blank" rel="noopener">C++ this指针</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> this指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 中的左值、右值</title>
      <link href="/2021/07/20/cpp_leftvalue_and_rightvalue/"/>
      <url>/2021/07/20/cpp_leftvalue_and_rightvalue/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>参考文章：</strong></p><p><a href="https://www.yhspy.com/2019/08/31/C-%E5%B7%A6%E5%80%BC%E3%80%81%E5%8F%B3%E5%80%BC%E4%B8%8E%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/" target="_blank" rel="noopener">C++ 左值、右值和右值引用</a></p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 左值 </tag>
            
            <tag> 右值 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 文件操作与文件流</title>
      <link href="/2021/07/17/cpp_file_stream/"/>
      <url>/2021/07/17/cpp_file_stream/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="一、文件的概念"><a href="#一、文件的概念" class="headerlink" title="一、文件的概念"></a>一、文件的概念</h2><p>对于用户来说，常用到的文件有两大类：程序文件和数据文件。而根据文件中数据的组织方式，则可以将文件分为<strong>ASCII 文件</strong>和<strong>二进制文件</strong>。</p><ul><li>ASCII 文件，又称字符文件或者文本文件，它的每一个字节放一个 ASCII 代码，代表一个字符。</li><li>二进制文件，又称内部格式文件或字节文件，是把内存中的数据按其在内存中的存储形式原样输出到磁盘上存放。</li></ul><a id="more"></a><p>数字 64 在内存中表示为 0100 0000，若将其保存为 ASCII 文件，则要分别存放十位 6 和个位 4 的 ASCII 码，为 0011 0110 0011 0100，占用两个字节；若将其保存为二进制文件，则按内存中形式直接输出，为 0100 0000，占用一个字节。</p><p>ASCII 文件中数据与字符一一对应，一个字节代表一个字符，可以直接在屏幕上显示或打印出来，这种方式使用方便，比较直观，便于阅读，但一般占用存储空间较大，而且输出时要将二进制转化为 ASCII 码比较花费时间。</p><p>二进制文件，输出时不需要进行转化，直接将内存中的形式输出到文件中，占用存储空间较小，但一个字节并不对应一个文件，不能直观显示文件中的内容。</p><h2 id="二、文件流和文件流对象"><a href="#二、文件流和文件流对象" class="headerlink" title="二、文件流和文件流对象"></a>二、文件流和文件流对象</h2><h3 id="2-1-文件流"><a href="#2-1-文件流" class="headerlink" title="2.1 文件流"></a>2.1 文件流</h3><p>文件流是以外存文件未输入输出对象的数据流。输出文件流是从内存流向外存文件的数据，输入文件流是从外存文件流向内存的数据。每一个文件流都有一个内存缓冲区与之对应。</p><p>C++ 中有三个用于文件操作的文件类：</p><ul><li>ifstream 类，它是从 istream 类派生来的，用于支持从磁盘文件的输入。</li><li>ofstream 类，它是从 ostream 类派生来的，用于支持向磁盘文件的输出。</li><li>fstream 类，它是从 iostream 类派生来的，用于支持对磁盘文件的输入输出。</li></ul><p>要以磁盘文件为对象进行输入输出，必须定义一个文件流类的对象，通过文件流对象将数据从内存输出到磁盘文件，或者将磁盘文件输入到内存。</p><h3 id="2-2-文件流对象"><a href="#2-2-文件流对象" class="headerlink" title="2.2 文件流对象"></a>2.2 文件流对象</h3><p>定义文件流对象后，我们还需要将文件流对象和指定的磁盘文件建立关联，以便使文件流流向指定的磁盘文件，并确定文件的工作方式（输入还是输出，二进制还是 ASCII）。我们可以在定义流对象的时候指定参数来调用构造函数，或者通过成员函数 open 来进行文件流对象和指定文件的关联。</p><h3 id="2-3-文件模式"><a href="#2-3-文件模式" class="headerlink" title="2.3 文件模式"></a>2.3 文件模式</h3><p>每个流都有一个关联的<strong>文件模式</strong>（file mode），用来指出如何使用文件。</p><div class="table-container"><table><thead><tr><th>文件模式</th><th>模式含义</th></tr></thead><tbody><tr><td>ios::in</td><td>以读方式打开</td></tr><tr><td>ios::out</td><td>以写方式打开（从文件头开始写入，但不会删除旧内容）</td></tr><tr><td>ios::app</td><td>每次写操作前均定位到文件末尾（append）</td></tr><tr><td>ios::ate</td><td>打开文件后立即定位到文件末尾</td></tr><tr><td>ios::trunc</td><td>截断文件，表示打开文件时，旧的内容将立即删除</td></tr><tr><td>ios::binary</td><td>以二进制方式进行IO</td></tr></tbody></table></div><h2 id="三、对-ASCII-文件的操作"><a href="#三、对-ASCII-文件的操作" class="headerlink" title="三、对 ASCII 文件的操作"></a>三、对 ASCII 文件的操作</h2><p>然后，我们就可以用类似 cin 或者 cout 的方式将数据读出或写入文件，只不过是输入输出的对象变成了文件而已。当然，在对磁盘文件完成读写操作后，我们可以通过 close 方法来解除磁盘文件和文件流对象的关联。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ofstream <span class="title">outfile</span><span class="params">(<span class="string">"a.txt"</span>, ios::out)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!outfile)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Failed to open the file!"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入数字 1-5 到文件中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        outfile &lt;&lt; i &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    outfile.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">ifstream <span class="title">infile</span><span class="params">(<span class="string">"a.txt"</span>, ios::in)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!infile)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Failed to open the file!"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> data;  <span class="comment">// 从文件中读出数字 1-5 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        infile &gt;&gt; data;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; data &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    infile.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以利用文件流对象的成员函数 get, put 等，其用法就和<a href="https://link.zhihu.com/?target=https%3A//blog.csdn.net/seniusen/article/details/83512970">标准输入输出</a>介绍的一样。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ofstream <span class="title">outfile</span><span class="params">(<span class="string">"a.txt"</span>, ios::out)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!outfile)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Failed to open the file!"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> i = <span class="string">'1'</span>; i &lt; <span class="string">'6'</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        outfile.<span class="built_in">put</span>(i); <span class="comment">// 输出一个字符到文件中去</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    outfile.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">ifstream <span class="title">infile</span><span class="params">(<span class="string">"a.txt"</span>, ios::in)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!infile)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Failed to open the file!"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*char a;</span></span><br><span class="line"><span class="comment">    for (int i = 0; i &lt; 5; i++)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        infile.get(a); // 从文件中读出 1 个字符</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; a &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> data[<span class="number">5</span>];</span><br><span class="line">    infile.<span class="built_in">get</span>(data, <span class="number">6</span>); <span class="comment">// 从文件中读出 5 个字符</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; data[i] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    infile.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、对二进制文件的操作"><a href="#四、对二进制文件的操作" class="headerlink" title="四、对二进制文件的操作"></a>四、对二进制文件的操作</h2><p>二进制文件的操作需要在打开文件的时候指定打开方式为 ios::binary，并且还可以指定为既能输入又能输出的文件，我们通过成员函数 read 和 write 来读写二进制文件。</p><ul><li><code>istream&amp; read (char* s, streamsize n);</code></li><li><code>ostream&amp; write (const char* s, streamsize n);</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ofstream <span class="title">outfile</span><span class="params">(<span class="string">"a.txt"</span>, ios::binary)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!outfile)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Failed to open the file!"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> a[] = &#123;<span class="string">'h'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>, <span class="string">','</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> b[] = &#123;<span class="string">'s'</span>, <span class="string">'e'</span>, <span class="string">'n'</span>, <span class="string">'i'</span>, <span class="string">'u'</span>, <span class="string">'s'</span>, <span class="string">'e'</span>, <span class="string">'n'</span>, <span class="string">'!'</span>&#125;;</span><br><span class="line"></span><br><span class="line">    outfile.<span class="built_in">write</span>(a, <span class="number">6</span>); <span class="comment">// 将以 a 为首地址的 6 个字符写入文件</span></span><br><span class="line">    outfile.<span class="built_in">write</span>(b, <span class="number">9</span>);</span><br><span class="line">    outfile.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">ifstream <span class="title">infile</span><span class="params">(<span class="string">"a.txt"</span>, ios::binary)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!infile)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Failed to open the file!"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> data[<span class="number">6</span>];</span><br><span class="line">    infile.<span class="built_in">read</span>(data, <span class="number">6</span>);  <span class="comment">// 从文件中读出 6 个字符到以 data 为首地址的字符数组中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; data[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> datb[<span class="number">6</span>];</span><br><span class="line">    infile.<span class="built_in">read</span>(datb, <span class="number">9</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; datb[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    infile.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在磁盘文件中有一个文件指针，用来指明当前读写的位置。每次写入或者读出一个字节，指针就向后移动一个字节。对于二进制文件，允许对指针进行控制，使它移动到所需的位置，以便在该位置上进行读写。  </p><ul><li><code>ostream&amp; seekp (streampos pos);</code>将输出文件中指针移动到指定的位置</li><li><code>ostream&amp; seekp (streamoff off, ios_base::seekdir way);</code>以参照位置为基准对输出文件中的指针移动若干字节</li><li><code>streampos tellp();</code>返回输出文件指针当前的位置</li><li><code>istream&amp; seekg (streampos pos);</code>将输入文件中指针移动到指定的位置</li><li><code>istream&amp; seekg (streamoff off, ios_base::seekdir way);</code>以参照位置为基准对输入文件中的指针移动若干字节</li><li><code>streampos tellg();</code>返回输入文件指针当前的位置</li></ul><p>其中，参照位置有以下几个选择：</p><ul><li><code>ios_base::beg</code>文件开始位置</li><li><code>ios_base::cur</code>文件当前位置</li><li><code>ios_base::end</code>文件末尾位置</li></ul><p><strong>参考文章：</strong></p><ol><li><p><a href="https://zhuanlan.zhihu.com/p/49757495" target="_blank" rel="noopener">文件操作和文件流</a></p></li><li><p><a href="https://www.cnblogs.com/likebeta/archive/2012/06/16/2551662.html" target="_blank" rel="noopener">C++文件操作详解</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++中的构造函数与析构函数</title>
      <link href="/2021/07/15/cpp_constructor_and_destructor/"/>
      <url>/2021/07/15/cpp_constructor_and_destructor/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>原文链接：<a href="https://www.cnblogs.com/mr-wid/archive/2013/02/19/2917911.html" target="_blank" rel="noopener">https://www.cnblogs.com/mr-wid/archive/2013/02/19/2917911.html</a></p></blockquote><h2 id="一、构造函数介绍"><a href="#一、构造函数介绍" class="headerlink" title="一、构造函数介绍"></a>一、构造函数介绍</h2><h3 id="1-构造函数的作用"><a href="#1-构造函数的作用" class="headerlink" title="1.构造函数的作用"></a>1.构造函数的作用</h3><p>构造函数主要用来在创建对象时完成对对象属性的一些初始化等操作, 当创建对象时, 对象会自动调用它的构造函数。一般来说, 构造函数有以下三个方面的作用:</p><ul><li>给创建的对象建立一个标识符;</li><li>为对象数据成员开辟内存空间;</li><li>完成对象数据成员的初始化。</li></ul><a id="more"></a><h3 id="2-默认构造函数"><a href="#2-默认构造函数" class="headerlink" title="2.默认构造函数"></a>2.默认构造函数</h3><p>​    当用户没有显式的去定义构造函数时, 编译器会为类生成一个默认的构造函数, 称为 “<strong>默认构造函数</strong>“, 默认构造函数不能完成对象数据成员的初始化, 只能给对象创建一标识符, 并为对象中的数据成员开辟一定的内存空间。</p><h3 id="3-构造函数的特点"><a href="#3-构造函数的特点" class="headerlink" title="3.构造函数的特点"></a>3.构造函数的特点</h3><p>无论是用户自定义的构造函数还是默认构造函数都主要有以下特点:</p><ol><li>在对象被创建时自动执行;</li><li>构造函数的函数名与类名相同;</li><li>没有返回值类型、也没有返回值;</li><li>构造函数不能被显式调用。</li></ol><h2 id="二、构造函数的显式定义"><a href="#二、构造函数的显式定义" class="headerlink" title="二、构造函数的显式定义"></a>二、构造函数的显式定义</h2><p> 由于在大多数情况下我们希望在对象创建时就完成一些对成员属性的初始化等工作, 而默认构造函数无法满足我们的要求, 所以我们需要显式定义一个构造函数来覆盖掉默认构造函数以便来完成必要的初始化工作, 当用户自定义构造函数后编译器就不会再为对象生成默认构造函数。</p><p>在构造函数的特点中我们看到, 构造函数的名称必须与类名相同, 并且没有返回值类型和返回值, 看一个构造函数的定义:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Point()     <span class="comment">//声明并定义构造函数</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"自定义的构造函数被调用...\n"</span>;</span><br><span class="line">            xPos = <span class="number">100</span>;         <span class="comment">//利用构造函数对数据成员 xPos, yPos进行初始化</span></span><br><span class="line">            yPos = <span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">printPoint</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"xPos = "</span> &lt;&lt; xPos &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"yPos = "</span> &lt;&lt; yPos &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> xPos;</span><br><span class="line">        <span class="keyword">int</span> yPos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Point M;    <span class="comment">//创建对象M</span></span><br><span class="line">    M.printPoint();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行的结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">自定义的构造函数被调用...</span><br><span class="line">xPos = <span class="number">100</span></span><br><span class="line">yPos = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Process</span> returned <span class="number">0</span> (<span class="number">0x0</span>)   execution time : <span class="number">0.453</span> s</span><br><span class="line">Press any key to <span class="keyword">continue</span>.</span><br></pre></td></tr></table></figure><p><strong>代码说明：</strong></p><p>在Point类的 public 成员中我们定义了一个构造函数 <strong>Point()</strong> , 可以看到这个Point构造函数并不像 printPoint 函数有个void类型的返回值, 这正是构造函数的一特点。在构造函数中, 我们输出了一句提示信息, “自定义的构造函数被调用…”, 并且将对象中的数据成员xPos和yPos初始化为100。</p><p>在 main 函数中, 使用 Point 类创建了一个对象 M, 并调用M对象的方法 printPoint 输出M的属性信息, 根据输出结果看到, 自定义的构造函数被调用了, 所以 xPos和yPos 的值此时都是100, 而不是一个随机值。</p><p>需要提示一下的是, 构造函数的定义也可放在类外进行。</p><h2 id="三、有参数的构造函数"><a href="#三、有参数的构造函数" class="headerlink" title="三、有参数的构造函数"></a>三、有参数的构造函数</h2><p>在上个示例中实在构造函数的函数体内直接对数据成员进行赋值以达到初始化的目的, 但是有时候在创建时每个对象的属性有可能是不同的, 这种直接赋值的方式显然不合适。不过构造函数是支持向函数中传入参数的, 所以可以使用带参数的构造函数来解决该问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Point(<span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">int</span> y = <span class="number">0</span>)     <span class="comment">//带有默认参数的构造函数</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"自定义的构造函数被调用...\n"</span>;</span><br><span class="line">            xPos = x;         <span class="comment">//利用传入的参数值对成员属性进行初始化</span></span><br><span class="line">            yPos = y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">printPoint</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"xPos = "</span> &lt;&lt; xPos &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"yPos = "</span> &lt;&lt; yPos &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> xPos;</span><br><span class="line">        <span class="keyword">int</span> yPos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Point <span class="title">M</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;    <span class="comment">//创建对象M并初始化xPos,yPos为10和20</span></span><br><span class="line">    M.printPoint();</span><br><span class="line"></span><br><span class="line">    <span class="function">Point <span class="title">N</span><span class="params">(<span class="number">200</span>)</span></span>;       <span class="comment">//创建对象N并初始化xPos为200, yPos使用参数y的默认值0</span></span><br><span class="line">    N.printPoint();</span><br><span class="line"></span><br><span class="line">    Point P;            <span class="comment">//创建对象P使用构造函数的默认参数</span></span><br><span class="line">    P.printPoint();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行的结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">自定义的构造函数被调用...</span><br><span class="line">xPos = <span class="number">10</span></span><br><span class="line">yPos = <span class="number">20</span></span><br><span class="line">自定义的构造函数被调用...</span><br><span class="line">xPos = <span class="number">200</span></span><br><span class="line">yPos = <span class="number">0</span></span><br><span class="line">自定义的构造函数被调用...</span><br><span class="line">xPos = <span class="number">0</span></span><br><span class="line">yPos = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Process</span> returned <span class="number">0</span> (<span class="number">0x0</span>)   execution time : <span class="number">0.297</span> s</span><br><span class="line">Press any key to <span class="keyword">continue</span>.</span><br></pre></td></tr></table></figure><p><strong>代码说明：</strong></p><p>在这个示例中的构造函数 <strong>Point(int x = 0, int y = 0)</strong> 使用了参数列表并且对参数进行了默认参数设置为0。在 main 函数中共创建了三个对象 M, N, P。</p><p>M对象不使用默认参数将M的坐标属性初始化10和20;</p><p>N对象使用一个默认参数y, xPos属性初始化为200;</p><p>P对象完全使用默认参数将xPos和yPos初始化为0。</p><h2 id="四、构造函数的重载"><a href="#四、构造函数的重载" class="headerlink" title="四、构造函数的重载"></a>四、构造函数的重载</h2><p>构造函数也毕竟是函数, 与普通函数相同, 构造函数也支持重载, 需要注意的是, 在进行构造函数的重载时要注意重载和参数默认的关系要处理好, 避免产生代码的二义性导致编译出错, 例如以下具有二义性的重载:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Point(<span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">int</span> y = <span class="number">0</span>)     <span class="comment">//默认参数的构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">    xPos = x;</span><br><span class="line">    yPos = y;</span><br><span class="line">&#125;</span><br><span class="line">Point()         <span class="comment">//重载一个无参构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">    xPos = <span class="number">0</span>;</span><br><span class="line">    yPos = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 在上面的重载中, 当尝试用 Point 类重载一个无参数传入的对象 M 时, Point M; 这时编译器就报一条 <strong>error: call of overloaded ‘Point()’ is ambiguous</strong> 的错误信息来告诉我们说 Point 函数具有二义性, 这是因为 <strong>Point(int x = 0, int y = 0)</strong> 全部使用了默认参数, 即使我们不传入参数也不会出现错误, 但是在重载时又重载了一个不需要传入参数了构造函数 <strong>Point()</strong>, 这样就造成了当创建对象都不传入参数时编译器就不知道到底该使用哪个构造函数了, 就造成了二义性。</p><h2 id="五、初始化表达式"><a href="#五、初始化表达式" class="headerlink" title="五、初始化表达式"></a>五、初始化表达式</h2><p>对象中的一些数据成员除了在构造函数体中进行初始化外还可以通过调用初始化表来进行完成, 要使用初始化表来对数据成员进行初始化时使用 <strong>:</strong> 号进行调出, 示例如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Point(<span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">int</span> y = <span class="number">0</span>):xPos(x), yPos(y)　　<span class="comment">//使用初始化表</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"调用初始化表对数据成员进行初始化!\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Point 构造函数头的后面, 通过单个冒号 <strong>:</strong> 引出的就是初始化表, 初始化的内容为 Point 类中int型的 xPos 成员和 yPos成员, 其效果和 xPos = x; yPos = y; 是相同的。</p><p>与在构造函数体内进行初始化不同的是, 使用初始化表进行初始化是在构造函数被调用以前就完成的。每个成员在初始化表中只能出现一次, 并且初始化的顺序不是取决于数据成员在初始化表中出现的顺序, 而是取决于在类中声明的顺序。</p><p>此外, 一些通过构造函数无法进行初始化的数据类型可以使用初始化表进行初始化, 如: 常量成员和引用成员, 这部分内容将在后面进行详细说明。使用初始化表对对象成员进行初始化的完整示例:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Point(<span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">int</span> y = <span class="number">0</span>):xPos(x), yPos(y)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"调用初始化表对数据成员进行初始化!\n"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">printPoint</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"xPos = "</span> &lt;&lt; xPos &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"yPos = "</span> &lt;&lt; yPos &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> xPos;</span><br><span class="line">        <span class="keyword">int</span> yPos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Point <span class="title">M</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;    <span class="comment">//创建对象M并初始化xPos,yPos为10和20</span></span><br><span class="line">    M.printPoint();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、析构函数"><a href="#六、析构函数" class="headerlink" title="六、析构函数"></a>六、析构函数</h2><p> 与构造函数相反, 析构函数是在对象被撤销时被自动调用, 用于对成员撤销时的一些清理工作, 例如在前面提到的手动释放使用 new 或 malloc 进行申请的内存空间。析构函数具有以下特点:</p><ul><li>析构函数函数名与类名相同, 紧贴在名称前面用波浪号 ~ 与构造函数进行区分, 例如: <strong>~Point();</strong></li><li>构造函数没有返回类型, 也不能指定参数, 因此析构函数只能有一个, 不能被重载;</li><li>当对象被撤销时析构函数被自动调用, 与构造函数不同的是, 析构函数可以被显式的调用, 以释放对象中动态申请的内存。</li></ul><p>当用户没有显式定义析构函数时, 编译器同样会为对象生成一个默认的析构函数, 但默认生成的析构函数只能释放类的普通数据成员所占用的空间, 无法释放通过 new 或 malloc 进行申请的空间, 因此有时我们需要自己显式的定义析构函数对这些申请的空间进行释放, 避免造成内存泄露。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Book( <span class="keyword">const</span> <span class="keyword">char</span> *name )      <span class="comment">//构造函数</span></span><br><span class="line">        &#123;</span><br><span class="line">            bookName = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(name)+<span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(bookName, name);</span><br><span class="line">        &#125;</span><br><span class="line">        ~Book()                 <span class="comment">//析构函数</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"析构函数被调用...\n"</span>;</span><br><span class="line">            <span class="keyword">delete</span> []bookName;  <span class="comment">//释放通过new申请的空间</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">showName</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"Book name: "</span>&lt;&lt; bookName &lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *bookName;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Book <span class="title">CPP</span><span class="params">(<span class="string">"C++ Primer"</span>)</span></span>;</span><br><span class="line">    CPP.showName();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行的结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Book name: C++ Primer</span><br><span class="line">析构函数被调用...</span><br><span class="line"></span><br><span class="line"><span class="built_in">Process</span> returned <span class="number">0</span> (<span class="number">0x0</span>)   execution time : <span class="number">0.266</span> s</span><br><span class="line">Press any key to <span class="keyword">continue</span>.</span><br></pre></td></tr></table></figure><p><strong>代码说明：</strong></p><p>代码中创建了一个 <strong>Book</strong> 类, 类的数据成员只有一个字符指针型的 <strong>bookName</strong>, 在创建对象时系统会为该指针变量分配它所需内存, 但是此时该指针并没有被初始化所以不会再为其分配其他多余的内存单元。在构造函数中, 我们使用 new 申请了一块 strlen(name)+1 大小的空间, 也就是比传入进来的字符串长度多1的空间, 目的是让字符指针 bookName 指向它, 这样才能正常保存传入的字符串。</p><p>在 main 函数中使用 Book 类创建了一个对象 CPP, 初始化 bookName 属性为 “C++ Primer”。从运行结果可以看到, 析构函数被调用了, 这时使用 new 所申请的空间就会被正常释放。</p><p>自然状态下对象何时将被销毁取决于对象的生存周期, 例如全局对象是在程序运行结束时被销毁, 自动对象是在离开其作用域时被销毁。</p><p>如果需要显式调用析构函数来释放对象中动态申请的空间只需要使用 对象名.析构函数名(); 即可, 例如上例中要显式调用析构函数来释放 bookName 所指向的空间只要:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CPP.~Book();</span><br></pre></td></tr></table></figure><p><strong>参考文章：</strong></p><p><a href="https://blog.csdn.net/chaipp0607/article/details/71525599" target="_blank" rel="noopener">C++ 构造函数总结</a></p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 构造函数 </tag>
            
            <tag> 析构函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL中的优先级队列和堆问题</title>
      <link href="/2021/06/28/Priority_queue_and_heap/"/>
      <url>/2021/06/28/Priority_queue_and_heap/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>priority_queue 是容器适配器，它提供常数时间的（默认）最大元素查找，对数代价的插入与释出。</p><p>可用用户提供的 <code>Compare</code> 更改顺序，例如，用 std::greater<T> 将导致最小元素作为 <a href="https://zh.cppreference.com/w/cpp/container/priority_queue/top" target="_blank" rel="noopener">top()</a> 出现。</p><p>用 <code>priority_queue</code> 工作类似管理某些随机访问容器中的<a href="https://zh.cppreference.com/w/cpp/algorithm/make_heap" target="_blank" rel="noopener">堆</a>，优势是不可能突然把堆非法化。</p></blockquote><p>默认情况下priority_queue内部是以”降序“排列的，即默认<strong>大顶堆</strong>。</p><a id="more"></a><h2 id="一、使用"><a href="#一、使用" class="headerlink" title="一、使用"></a>一、使用</h2><p>定义于头文件 <queue>     </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;     </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span>,    </span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Container</span> = <span class="title">std</span>:</span>:<span class="built_in">vector</span>&lt;T&gt;,     </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Compare</span> = <span class="title">std</span>:</span>:less&lt;<span class="keyword">typename</span> Container::value_type&gt;</span><br><span class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">priority_queue</span>;</span></span><br></pre></td></tr></table></figure><p><strong>模板形参</strong></p><ul><li><strong>T</strong> - 存储的元素类型。若 <code>T</code> 与 <code>Container::value_type</code> 不是同一类型则行为未定义。 (C++17 起)</li><li><strong>Container </strong>- 用于存储元素的底层容器类型。容器必须满足<a href="https://zh.cppreference.com/w/cpp/named_req/SequenceContainer" target="_blank" rel="noopener"><em>序列容器</em> <em>(SequenceContainer)</em> </a>的要求，而其迭代器必须满足<a href="https://zh.cppreference.com/w/cpp/named_req/RandomAccessIterator" target="_blank" rel="noopener"><em>遗留随机访问迭代器</em> <em>(LegacyRandomAccessIterator)</em> </a>的要求。另外，它必须提供拥有通常语义的下列函数：<code>front()``push_back()``pop_back()</code>标准容器 <a href="https://zh.cppreference.com/w/cpp/container/vector" target="_blank" rel="noopener">std::vector</a> 和 <a href="https://zh.cppreference.com/w/cpp/container/deque" target="_blank" rel="noopener">std::deque</a> 满足这些要求。</li><li><strong>Compare</strong> - 提供严格弱序的<a href="https://zh.cppreference.com/w/cpp/named_req/Compare" target="_blank" rel="noopener"><em>比较</em> <em>(Compare)</em> </a>类型。</li></ul><p><strong>堆实现</strong></p><p><strong>大顶堆</strong>：priority_queue默认实现大顶堆，也可将priority_queue模板第三个参数显示设置 std::less<T>。</p><p><strong>小顶堆</strong>：priority_queue模板第三个参数显示设置 std::greater<T>，实现小顶堆。</p><h2 id="二、priority-queue自定义排序"><a href="#二、priority-queue自定义排序" class="headerlink" title="二、priority_queue自定义排序"></a>二、priority_queue自定义排序</h2><p>前面说到 priority_queue 容器适配器时，还遗留一个问题，即当 <function> 头文件提供的排序方式（std::less<T> 和 std::greater<T>）不再适用时，如何自定义一个满足需求的排序规则。</p><p>首先来看看 std::less<T> 和 std::greater<T> 各自的底层实现。实际上，<function> 头文件中的 std::less<T> 和 std::greater<T> ，各自底层实现采用的都是函数对象的方式。</p><p>比如，std::less<T> 的底层实现代码为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">less</span> &#123;</span></span><br><span class="line">    <span class="comment">//定义新的排序规则</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T &amp;_lhs, <span class="keyword">const</span> T &amp;_rhs)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _lhs &lt; _rhs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>std::greater<T> 的底层实现代码为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">greater</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T &amp;_lhs, <span class="keyword">const</span> T &amp;_rhs)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _lhs &gt; _rhs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到，std::less<T> 和 std::greater<T> 底层实现的唯一不同在于，前者使用 &lt; 号实现从大到小排序，后者使用 &gt; 号实现从小到大排序。</p><p>仿照 std::less<T> 和 std::greater<T>  的底层实现代码，我们可以自己定义比较函数，然后作为参数传入priority_queue使用。</p><p><strong>参考文章</strong>：</p><p><a href="https://zh.cppreference.com/w/cpp/container/priority_queue" target="_blank" rel="noopener">cppreference::priority_queue</a></p><p><a href="http://c.biancheng.net/view/6996.html" target="_blank" rel="noopener">STL priority_queue自定义排序实现方法详解</a></p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 堆 </tag>
            
            <tag> STL </tag>
            
            <tag> priority_queue </tag>
            
            <tag> 优先级队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>求解某一范围内的全部素数</title>
      <link href="/2021/06/27/Calculate_prime_numbers/"/>
      <url>/2021/06/27/Calculate_prime_numbers/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p><strong>素数</strong>又称质数，是指大于1的<a href="https://baike.baidu.com/item/自然数" target="_blank" rel="noopener">自然数</a>中，除了1和它本身，不能被其它自然数整除的数字。1被定义为非素数。大于1的自然数，如果不是素数则为<strong>合数</strong>。<strong>2是最小的素数</strong>。</p></blockquote><p><strong>问题</strong>：给定一个范围，求解这个范围内的全部素数。</p><a id="more"></a><h2 id="一、试除法"><a href="#一、试除法" class="headerlink" title="一、试除法"></a>一、试除法</h2><p><strong>基本思想</strong>：为了判断自然数x是否是素数，我们可以从2开始，分别除以不大于x的每个数，如果存在能整除x的数，则x不是素数。</p><p><strong>简单实现</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*判断一个数是否是素数*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_prime</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (n%i == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*方法一 试除法*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prime_number1</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prime, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (is_prime(i))</span><br><span class="line">&#123;</span><br><span class="line">prime.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度</strong>：O(n*sqrt(n))</p><h2 id="二、埃拉托斯特尼筛法"><a href="#二、埃拉托斯特尼筛法" class="headerlink" title="二、埃拉托斯特尼筛法"></a>二、埃拉托斯特尼筛法</h2><p><strong>基本思想</strong>：<strong>埃拉托斯特尼筛法（sieve of Eratosthenes ）</strong> 是古希腊数学家<a href="https://zh.wikipedia.org/wiki/埃拉托斯特尼" target="_blank" rel="noopener">埃拉托斯特尼</a>发明的计算素数的方法。对于求解不大于 <strong>n</strong> 的所有素数，我们先找出 <strong>sqrt(n)</strong> 内的所有素数 <strong>p<sub>1</sub>, p<sub>2</sub>, p<sub>3</sub>, , , p<sub>k-1</sub>, p<sub>k</sub></strong>，其中 <strong>k=floor(sqrt(n))</strong> (floor表示向下取整)，依次剔除 <strong>p<sub>i</sub> (1&lt;=i&lt;=k) </strong>的倍数，剩下的所有数都是素数。下面我们来看一个来自维基百科的例子，如果求25内的所有素数</p><p>1.列出大于等于2小于等于25的所有数组成的序列：</p><ul><li>2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25</li></ul><p>2.去掉素数2的所有倍数：</p><ul><li>2 3 5 7 9 11 13 15 17 19 21 23 25</li></ul><p>3.去掉素数3的所有倍数：</p><ul><li>2 3 5 7 11 13 17 19 23 25</li></ul><p>4.去掉素数5的所有倍数：</p><ul><li>2 3 7 11 17 19 23</li></ul><p>5.因为 <strong>5=sqrt(25)</strong> ，所以算法结束。剩下的所有数都是素数。</p><p><strong>简单实现</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*方法三 埃拉托斯特尼筛法*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prime_number3</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prime, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; is_prime(n + <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (is_prime[i])</span><br><span class="line">&#123;</span><br><span class="line">prime.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i * i; j &lt;= n; j += i)</span><br><span class="line">&#123;</span><br><span class="line">is_prime[j] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度</strong>：O(nlogn)</p><h2 id="三、欧拉筛法"><a href="#三、欧拉筛法" class="headerlink" title="三、欧拉筛法"></a>三、欧拉筛法</h2><p><strong>基本思想</strong>：回顾上文的埃拉托斯特尼筛法，核心思想就是依次剔除素数的倍数。这里我们很容易就能想到此算法存在的缺点：对于两个素数的公倍数，我们可能会进行多次剔除。于是便出现了欧拉筛法，核心思想便是对于一个没被筛选过的数来说，它只需要被第一个整除它的素数筛掉就行。</p><p><strong>简单实现</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*方法四 欧拉筛法*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prime_number4</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prime, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; is_prime(n + <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (is_prime[i])</span><br><span class="line">&#123;</span><br><span class="line">prime.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; prime.<span class="built_in">size</span>() &amp;&amp; i*prime[j] &lt;= n; j++)</span><br><span class="line">&#123;</span><br><span class="line">is_prime[i*prime[j]] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (i%prime[j] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度</strong>：O(n)</p><p><strong>参考文章</strong>：<a href="https://www.jianshu.com/p/7867517826e7" target="_blank" rel="noopener">https://www.jianshu.com/p/7867517826e7</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> LeetCode刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 素数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经典 TopK 问题</title>
      <link href="/2021/06/25/Classic_TopK_problem/"/>
      <url>/2021/06/25/Classic_TopK_problem/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>什么是 Top K 问题？简单来说就是在一堆数据里面找到前 K 大（当然也可以是前 K 小）的数。</p><p>这个问题也是十分经典的算法问题，不论是面试中还是实际开发中，都非常典型。而这个问题其实也有很多种做法，你真的都懂了么？</p></blockquote><p>经典的 Top K 问题有：最大（小） K 个数、前 K 个高频元素、第 K 个最大（小）元素，下面举例子说明：</p><p><strong>栗子(以下所有方法均使用这个栗子)</strong>：</p><p>从 data[1, 12]={5,3,7,1,8,2,9,4,7,2,6,6} 这n=12个数中，找出最大的k=5个。</p><a id="more"></a><h2 id="一、排序"><a href="#一、排序" class="headerlink" title="一、排序"></a>一、排序</h2><p>最简单也是最容易想到的方法就是排序，利用快排将数组排序，然后取前k个。</p><p><strong>时间复杂度</strong>：O(nlogn)</p><p><strong>分析</strong>：明明只需要TopK，却将全局都排序了，这也是这个方法复杂度非常高的原因。那能不能不全局排序，而只局部排序呢？这就引出了第二个优化方法。</p><h2 id="二、局部排序"><a href="#二、局部排序" class="headerlink" title="二、局部排序"></a>二、局部排序</h2><p>不再全局排序，只对最大的k个排序。</p><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/local_sort.png" alt=""></p><p>冒泡是一个很常见的排序方法，每冒一个泡，找出最大值，冒k个泡，就得到TopK。</p><p><strong>简单实现</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*方法一 局部冒泡排序*/</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; local_bubble_sort(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;data, <span class="keyword">int</span> k)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; data.<span class="built_in">size</span>(); ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (data[i] &lt; data[j])</span><br><span class="line">&#123;</span><br><span class="line">swap(data[i], data[j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">res = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(data.<span class="built_in">begin</span>(), data.<span class="built_in">begin</span>() + k);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度</strong>：O(n*k)</p><p><strong>分析</strong>：冒泡，将全局排序优化为了局部排序，非TopK的元素是不需要排序的，节省了计算资源。不少朋友会想到，需求是TopK，是不是这最大的k个元素也不需要排序呢？这就引出了第三个优化方法。</p><h2 id="三、堆"><a href="#三、堆" class="headerlink" title="三、堆"></a>三、堆</h2><p><strong>思路</strong>：只找到TopK，不排序TopK</p><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/heap_1.png" alt=""></p><p>先用前k个元素生成一个小顶堆，这个小顶堆用于存储，当前最大的k个元素。</p><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/heap_2.png" alt=""></p><p>接着，从第k+1个元素开始扫描，和堆顶（堆中最小的元素）比较，如果被扫描的元素大于堆顶，则替换堆顶的元素，并调整堆，以保证堆内的k个元素，总是当前最大的k个元素。</p><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/heap_3.png" alt=""></p><p>直到，扫描完所有n-k个元素，最终堆中的k个元素，就是所求的TopK。</p><p><strong>简单实现</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*方法二 堆*/</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; local_heap_sort(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;data, <span class="keyword">int</span> k)</span><br><span class="line">&#123;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; heap;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num : data)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (heap.<span class="built_in">size</span>() == k)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!heap.empty() &amp;&amp; heap.top() &lt; num)</span><br><span class="line">&#123;</span><br><span class="line">heap.pop();</span><br><span class="line">heap.emplace(num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">heap.emplace(num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!heap.empty())</span><br><span class="line">&#123;</span><br><span class="line">res.emplace_back(heap.top());</span><br><span class="line">heap.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度</strong>：O(n*log(k))</p><p><strong>解释</strong>：n个元素扫一遍，最坏的情况下，每插入一个元素都要进行堆调整，调整时间复杂度为堆的高度，即lg(k)，故整体时间复杂度是n*lg(k)。</p><p><strong>分析</strong>：堆，将冒泡的TopK排序优化为了TopK不排序，节省了计算资源。堆，是求TopK的经典算法，那还有没有更快的方案呢？</p><h2 id="四、随机选择"><a href="#四、随机选择" class="headerlink" title="四、随机选择"></a>四、随机选择</h2><p>随机选择算在是《算法导论》中一个经典的算法，其时间复杂度为O(n)，是一个线性复杂度的方法。</p><p>这个方法并不是所有同学都知道，为了将算法讲透，先聊一些前序知识，一个所有程序员都应该烂熟于胸的经典算法：<strong>快速排序</strong>。</p><p><strong>其伪代码是</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span>[]arr, <span class="keyword">int</span> low, inthigh)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low== high) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> i = partition(arr, low, high);</span><br><span class="line">quick_sort(arr, low, i<span class="number">-1</span>);</span><br><span class="line">quick_sort(arr, i+<span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其核心算法思想是：<strong>分治法</strong>。</p><p><strong>分治法（Divide&amp;Conquer）</strong>，把一个大的问题，转化为若干个子问题（Divide），每个子问题“都”解决，大的问题便随之解决（Conquer）。这里的关键词是“都”。从伪代码里可以看到，快速排序递归时，先通过partition把数组分隔为两个部分，两个部分“都”要再次递归。</p><p>分治法有一个特例，叫<strong>减治法</strong>。 </p><p><strong>减治法（Reduce&amp;Conquer）</strong>，把一个大的问题，转化为若干个子问题（Reduce），这些子问题中“只”解决一个，大的问题便随之解决（Conquer）。这里的关键词是“只”。</p><p><strong>二分查找binary_search</strong>，BS，是一个典型的运用减治法思想的算法。</p><p><strong>其伪代码是</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BS</span><span class="params">(<span class="keyword">int</span>[]arr, <span class="keyword">int</span> low, inthigh, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(low&gt; high) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">mid= (low+high)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(arr[mid]== target) </span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line"><span class="keyword">if</span>(arr[mid]&gt; target)</span><br><span class="line"><span class="keyword">return</span> BS(arr, low, mid<span class="number">-1</span>, target);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> BS(arr, mid+<span class="number">1</span>, high, target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从伪代码可以看到，二分查找，一个大的问题，可以用一个mid元素，分成左半区，右半区两个子问题。而左右两个子问题，只需要解决其中一个，递归一次，就能够解决二分查找全局的问题。</p><p>通过分治法与减治法的描述，可以发现，分治法的复杂度一般来说是大于减治法的：</p><p>快速排序：O(n*lg(n))</p><p>二分查找：O(lg(n))</p><p>话题收回来，<strong>快速排序</strong>的核心是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = partition(arr, low, high);</span><br></pre></td></tr></table></figure><p>这个partition是干嘛的呢？</p><p>顾名思义，partition会把整体分为两个部分。</p><p>更具体的，会用数组 arr中 的一个元素（默认是第一个元素 t=arr[low] ）为划分依据，将数据 arr[low, high] 划分成左右两个子数组：</p><ul><li><p>左半部分，都比 t 大</p></li><li><p>右半部分，都比 t 小</p></li><li><p>中间位置 i 是划分元素</p></li></ul><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/heap_4.png" alt=""></p><p>以上述TopK的数组为例，先用第一个元素 t=arr[low] 为划分依据，扫描一遍数组，把数组分成了两个半区：</p><ul><li>左半区比 t 大</li><li>右半区比 t 小</li><li>中间是 t</li></ul><p>partition返回的是 t 最终的位置 i 。</p><p>很容易知道，partition的时间复杂度是O(n)。</p><p>解释：把整个数组扫一遍，比 t 大的放左边，比 t 小的放右边，最后 t 放在中间 N[i]。</p><p>partition和TopK问题有什么关系呢？</p><p>TopK是希望求出 arr[1,n] 中最大的 k 个数，那如果找到了第 k 大的数，做一次partition，不就一次性找到最大的 k 个数了么？</p><p>解释：即partition后左半区的 k 个数。</p><p>问题变成了arr[1, n]中找到第 k 大的数。</p><p>再回过头来看看第一次partition，划分之后：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = partition(arr, <span class="number">1</span>, n);</span><br></pre></td></tr></table></figure><p>如果 i 大于 k，则说明 arr[i] 左边的元素都大于 k，于是只递归 arr[1, i-1] 里第 k 大的元素即可；</p><p>如果 i 小于 k，则说明说明第 k 大的元素在 arr[i] 的右边，于是只递归 arr[i+1, n] 里第 k-i 大的元素即可；</p><p>这就是随机选择算法randomized_select，RS，</p><p><strong>其伪代码如下</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RS</span><span class="params">(arr, low, high, k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low== high) </span><br><span class="line">        <span class="keyword">return</span> arr[low];</span><br><span class="line">    i= partition(arr, low, high);</span><br><span class="line">    temp= i-low;                        <span class="comment">//数组前半部分元素个数</span></span><br><span class="line">    <span class="keyword">if</span>(temp&gt;=k)</span><br><span class="line">        <span class="keyword">return</span> RS(arr, low, i<span class="number">-1</span>, k);    <span class="comment">//求前半部分第k大</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> RS(arr, i+<span class="number">1</span>, high, k-i); <span class="comment">//求后半部分第k-i大</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>简单实现</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;data, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = low, j = high, pivot = data[low];</span><br><span class="line"><span class="keyword">while</span> (i &lt; j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (i &lt; j&amp;&amp;data[j] &gt; pivot)</span><br><span class="line">&#123;</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i &lt; j)</span><br><span class="line">&#123;</span><br><span class="line">swap(data[i], data[j]);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (i&lt;j&amp;&amp;data[i]&lt;pivot)</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i &lt; j)</span><br><span class="line">&#123;</span><br><span class="line">swap(data[i], data[j]);</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*方法三 随机选择*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">randomized_select</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;data, <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (low == high)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> pos = partition(data, low, high);</span><br><span class="line"><span class="keyword">int</span> tmp = pos - low + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (tmp == k)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (tmp &gt; k)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> randomized_select(data, low, pos - <span class="number">1</span>, k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> randomized_select(data, pos + <span class="number">1</span>, high, k - tmp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/heap_5.png" alt=""></p><p>这是一个典型的减治算法，递归内的两个分支，最终只会执行一个，它的时间复杂度是O(n)。</p><p>再次强调一下：</p><p><strong>分治法</strong>，大问题分解为小问题，小问题都要递归各个分支，例如：快速排序</p><p><strong>减治法</strong>，大问题分解为小问题，小问题只要递归一个分支，例如：二分查找，随机选择</p><p>通过随机选择（randomized_select），找到 arr[1, n] 中第 k 大的数，再进行一次 partition，就能得到 TopK 的结果。</p><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>TopK，不难；其思路优化过程，不简单：</p><p>全局排序，O(n*lg(n))</p><p>局部排序，只排序TopK个数，O(n*k)</p><p>堆，TopK个数也不排序了，O(n*lg(k))</p><p>分治法，每个分支“都要”递归，例如：快速排序，O(n*lg(n))</p><p>减治法，“只要”递归一个分支，例如：二分查找O(lg(n))，随机选择O(n)</p><p>TopK的另一个解法：随机选择+partition</p><p><strong>原文链接</strong>：<a href="https://blog.csdn.net/z50L2O08e2u4afToR9A/article/details/82837278" target="_blank" rel="noopener">https://blog.csdn.net/z50L2O08e2u4afToR9A/article/details/82837278</a></p><p><strong>参考文章</strong>：</p><p><a href="https://github.com/sisterAn/JavaScript-Algorithms/issues/73" target="_blank" rel="noopener">前端进阶算法10：topk问题</a></p><p><a href="https://www.jianshu.com/p/7eea93ab683b" target="_blank" rel="noopener">从快速排序、堆排序到top k问题</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> LeetCode刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 堆 </tag>
            
            <tag> 分治法 </tag>
            
            <tag> 减治法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 单调栈的理解与使用</title>
      <link href="/2021/05/08/Understanding-and-use-of-monotone-stack/"/>
      <url>/2021/05/08/Understanding-and-use-of-monotone-stack/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>写在前面：LeetCode刷题笔记</p><p>近来刷题，遇到单调栈，感觉这是个宝藏解题思想，在此记录一下！</p><hr><h2 id="单调栈定义"><a href="#单调栈定义" class="headerlink" title="单调栈定义"></a>单调栈定义</h2><p>单调栈是指：站内元素保持一定单调性（单调递增或单调递减）的栈。这里的单调递增或递减是指从栈顶到栈底单调递增或递减。</p><a id="more"></a><p>主要解决的问题</p><ul><li>比当前元素更大的下一个元素</li><li>比当前元素更大的前一个元素</li><li>比当前元素更小的下一个元素</li><li>比当前元素更小的前一个元素</li></ul><h2 id="单调栈解题模板代码"><a href="#单调栈解题模板代码" class="headerlink" title="单调栈解题模板代码"></a>单调栈解题模板代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line"><span class="comment">//此处一般需要给数组最后添加结束标志符，具体下面例题会有详细讲解</span></span><br><span class="line"><span class="keyword">for</span> (遍历这个数组)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (栈不为空 &amp;&amp; 栈顶元素小于当前元素)</span><br><span class="line">    &#123;</span><br><span class="line">        栈顶元素出栈;</span><br><span class="line">        更新结果;</span><br><span class="line">    &#125;</span><br><span class="line">    当前数据入栈;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="举栗子"><a href="#举栗子" class="headerlink" title="举栗子"></a>举栗子</h2><p>寻找<code>T = [73, 74, 75, 71, 69, 72, 76, 73]</code>数组每个元素右边第一个比自己大的元素位置，如果找不到，则用-1表示。</p><p>那么对应的结果应该为 <code>[1, 2, 6, 5, 5, -1, -1]</code></p><p>分析：</p><p>73右边第一个比自己大的元素是74，数组下标位置为1</p><p>74右边第一个比自己大的元素是75，数组下标位置为2</p><p>75右边第一个比自己大的元素是76，数组下标位置为6</p><p>依次往下求解……</p><p>现在可以构造一个单调递增的栈来解决这个问题，以上述数组为例：<code>[73, 74, 75, 71, 69, 72, 76, 73]</code>。从左到右遍历，如果栈为空或入栈元素值小于栈顶元素值，则入栈；反之，如果栈不为空或入栈元素大于栈顶元素值，则需要把比入栈元素小的元素全部出栈，同时对其进行相关操作。单调递减的栈反之。</p><p>以下是上述问题的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*单调栈*/</span></span><br><span class="line"><span class="comment">/*向右找第一个大于当前元素的元素*/</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dailyTemperatures(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; T) &#123;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans(T.<span class="built_in">size</span>(), <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (!stk.empty() &amp;&amp; T[i] &gt; T[stk.top()])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> loc = stk.top();</span><br><span class="line">ans[loc] = i;</span><br><span class="line">stk.pop();</span><br><span class="line">&#125;</span><br><span class="line">stk.push(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LeetCode相关题目"><a href="#LeetCode相关题目" class="headerlink" title="LeetCode相关题目"></a>LeetCode相关题目</h2><ul><li><h4 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739. 每日温度"></a><a href="https://leetcode-cn.com/problems/daily-temperatures/" target="_blank" rel="noopener">739. 每日温度</a></h4></li><li><h4 id="496-下一个更大元素-I"><a href="#496-下一个更大元素-I" class="headerlink" title="496. 下一个更大元素 I"></a><a href="https://leetcode-cn.com/problems/next-greater-element-i/" target="_blank" rel="noopener">496. 下一个更大元素 I</a></h4></li><li><h4 id="503-下一个更大元素-II"><a href="#503-下一个更大元素-II" class="headerlink" title="503. 下一个更大元素 II"></a><a href="https://leetcode-cn.com/problems/next-greater-element-ii/" target="_blank" rel="noopener">503. 下一个更大元素 II</a></h4></li><li><h4 id="316-去除重复字母"><a href="#316-去除重复字母" class="headerlink" title="316. 去除重复字母"></a><a href="https://leetcode-cn.com/problems/remove-duplicate-letters/" target="_blank" rel="noopener">316. 去除重复字母</a></h4></li><li><h4 id="402-移掉K位数字"><a href="#402-移掉K位数字" class="headerlink" title="402. 移掉K位数字"></a><a href="https://leetcode-cn.com/problems/remove-k-digits/" target="_blank" rel="noopener">402. 移掉K位数字</a></h4></li><li><h4 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a><a href="https://leetcode-cn.com/problems/trapping-rain-water/" target="_blank" rel="noopener">42. 接雨水</a></h4></li><li><h4 id="84-柱状图中最大的矩形"><a href="#84-柱状图中最大的矩形" class="headerlink" title="84. 柱状图中最大的矩形"></a><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">84. 柱状图中最大的矩形</a></h4></li></ul><p>参考文章：</p><ul><li><a href="https://blog.csdn.net/weixin_43283687/article/details/85164863?utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control" target="_blank" rel="noopener">浅谈单调栈与单调栈的理解</a></li><li><a href="https://blog.csdn.net/lucky52529/article/details/89155694?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control" target="_blank" rel="noopener">单调栈</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> LeetCode刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算术表达式的前序、中序、后序表示及其转换</title>
      <link href="/2021/05/06/Arithmetic-expression/"/>
      <url>/2021/05/06/Arithmetic-expression/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>写在前面：LeetCode刷题笔记</p><hr><p>中序表达式转后序表达式（从左向右读入）</p><ol><li><p>创建一个队列，存储后缀表达式；创建一个栈，存储操作符。</p></li><li><p>遇到操作数则送入队列。</p></li><li><p>遇到 “(“ ，入栈，遇到操作符入栈。</p></li><li><p>如果遇到其他运算符，不断去除所有运算优先级大于等于当前运算符的运算符，送入队列。最后，新的符号入栈。</p></li><li><p>遇到 “)” 括号，则将栈内从 “(“ 到 “)” 的所有操作符全部取出送入队列（左括号出栈但不入队）。</p></li><li><p>中序表达式读取结束后，如果栈不为空，则将栈内元素依次出栈送入队列。</p></li><li><p>此时队列的表达式即为原中序表达式的后序表达式。</p><a id="more"></a></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*代码实现中将操作数队列替换为vector*/</span></span><br><span class="line"><span class="comment">/*代码实现中只考虑了加、减运算，故没有判断优先级，如果是一个四则运算表达式可以添加优先级判断部分*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inToPost</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; post)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//vector&lt;char&gt; post;</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; op;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">'('</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            op.push(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">'+'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (!op.empty() &amp;&amp; (op.top() == <span class="string">'+'</span> || op.top() == <span class="string">'-'</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">char</span> tmp = op.top();</span><br><span class="line">                op.pop();</span><br><span class="line">                post.push_back(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">            op.push(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">'-'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (!op.empty() &amp;&amp; (op.top() == <span class="string">'+'</span> || op.top() == <span class="string">'-'</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">char</span> tmp = op.top();</span><br><span class="line">                op.pop();</span><br><span class="line">                post.push_back(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">            op.push(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">')'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (!op.empty() &amp;&amp; op.top() != <span class="string">'('</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">char</span> tmp = op.top();</span><br><span class="line">                op.pop();</span><br><span class="line">                post.push_back(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">            op.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            post.push_back(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!op.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        post.push_back(op.top());</span><br><span class="line">        op.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考文章：<a href="https://oi-wiki.org/misc/expression/" target="_blank" rel="noopener">表达式求值</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> LeetCode刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算术表达式 </tag>
            
            <tag> 前序表达式 </tag>
            
            <tag> 中序表达式 </tag>
            
            <tag> 后序表达式 </tag>
            
            <tag> 逆波兰式 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何优雅的使用Git</title>
      <link href="/2021/04/27/Git-usage/"/>
      <url>/2021/04/27/Git-usage/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="git初始化本地仓库"><a href="#git初始化本地仓库" class="headerlink" title="git初始化本地仓库"></a>git初始化本地仓库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>此操作会生成一个.git文件，默认情况下是隐藏的。</p><h2 id="git仓库clone到本地"><a href="#git仓库clone到本地" class="headerlink" title="git仓库clone到本地"></a>git仓库clone到本地</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone HTTPS&#x2F;SSH</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="git本地项目提交到云端"><a href="#git本地项目提交到云端" class="headerlink" title="git本地项目提交到云端"></a>git本地项目提交到云端</h2><p>以下操作默认远程仓库分支为master。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git add .     （git add隔空格.）</span><br><span class="line"></span><br><span class="line">git commit  -m  &quot;提交信息&quot;  （注：“提交信息”里面换成你需要，如“first commit”）</span><br><span class="line"></span><br><span class="line">git push -u origin master  （注：此操作目的是把本地仓库push到github上面，此步骤需要你输入帐号和密码）</span><br></pre></td></tr></table></figure><h2 id="如果push失败，可能的原因："><a href="#如果push失败，可能的原因：" class="headerlink" title="如果push失败，可能的原因："></a>如果push失败，可能的原因：</h2><p>（1）本地库与远程库内同不一致，此时需要执行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master</span><br></pre></td></tr></table></figure><p>（2）远程和本地仓库分支不一致，git更改仓库分支，把本地的 master 仓库名称修改为远端的 main</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -m oldBranchName newBranchName</span><br></pre></td></tr></table></figure><p>（3）本地的origin和remote origin/master 没有建立关联，此时重新建立本地和远端的连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git remote remove origin</span><br><span class="line"></span><br><span class="line">git remote add origin git@github.com:XXX&#x2F;XXX.github.io.git</span><br><span class="line"></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>（4）本地文件与github上的文件有冲突/本地需要提交的文件中存在空文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">touch README</span><br><span class="line"></span><br><span class="line">git add README</span><br><span class="line"></span><br><span class="line">git commit -m &quot;change&quot;</span><br><span class="line"></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p><strong>参考文章：</strong><a href="https://www.cnblogs.com/tugenhua0707/p/4050072.html" target="_blank" rel="noopener">https://www.cnblogs.com/tugenhua0707/p/4050072.html</a></p>]]></content>
      
      
      <categories>
          
          <category> GitHub </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言typedef与#define详谈</title>
      <link href="/2021/03/17/C-typedef-and-define-specific-explain/"/>
      <url>/2021/03/17/C-typedef-and-define-specific-explain/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>最近更新：2022/5/9 </p><h2 id="一、typedef与-define比较"><a href="#一、typedef与-define比较" class="headerlink" title="一、typedef与#define比较"></a>一、<strong>typedef</strong>与<strong>#define</strong>比较</h2><h3 id="typedef和-define功能的共同点"><a href="#typedef和-define功能的共同点" class="headerlink" title="typedef和#define功能的共同点"></a><code>typedef</code>和<code>#define</code>功能的共同点</h3><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BYTE unsigned char</span></span><br></pre></td></tr></table></figure><p>表示预处理器用<code>BYTE</code>替换<code>unsigned char</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> BYTE</span><br></pre></td></tr></table></figure><p>表示编译器给类型<code>unsigned char</code>起了一个别名<code>BYTE</code></p><a id="more"></a><h3 id="typedef和-define的区别"><a href="#typedef和-define的区别" class="headerlink" title="typedef和#define的区别"></a><code>typedef</code>和<code>#define</code>的区别</h3><p><code>#define</code>只是替换，由预处理器执行，<code>#define A B</code>即意味着将B用A替换。</p><p>与<code>#define</code>不同，<code>typedef</code>具有以下特点：</p><ul><li><code>typedef</code>给出的符号名称仅限于类型，而不是数值。</li><li><code>typedef</code>的解释由编译器执行，不是简单的文本替换。</li><li>虽然范围有限，但是在有限范围内<code>typedef</code>比<code>#define</code>更灵活。</li></ul><p>(1) 连续定义多个变量时<code>typedef</code>和<code>#define</code>的区别。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> * STRING</span><br></pre></td></tr></table></figure><p>表示编译器把<code>STRING</code>解释为一个类型的标识符，该类型指向<code>char</code>。</p><p>所以：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STRING name, sign;</span><br></pre></td></tr></table></figure><p>相当于：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> * name, * sign;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STRING char *</span></span><br></pre></td></tr></table></figure><p>表示预处理器将用<code>STRING</code>替换<code>char *</code>标识符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STRING name, sign;</span><br></pre></td></tr></table></figure><p>将被翻译成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *name, sign;</span><br></pre></td></tr></table></figure><p>结果是<code>name</code>是一个指针，<code>sign</code>是一个字符类型。</p><p>(2) <code>#define</code>可以使用其他类型名对宏类型名进行拓展，但<code>typedef</code>定义的类型名不能用其他类型进行拓展。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTERGE int;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> INTERGE n;    <span class="comment">//正确</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> INTERGE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> INTERGE n;    <span class="comment">//错误，不能在INTERGE前面添加unsigned</span></span><br></pre></td></tr></table></figure><h2 id="二、typedef的主要用法"><a href="#二、typedef的主要用法" class="headerlink" title="二、typedef的主要用法"></a>二、typedef的主要用法</h2><h3 id="用法一："><a href="#用法一：" class="headerlink" title="用法一："></a>用法一：</h3><p>1、为基本数据类型定义一个别名，不是简单的宏替换。可以用作同时声明多个指针对象。比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> * pa, pb;      <span class="comment">// 这只是声明了一个指向字符的指针</span></span><br></pre></td></tr></table></figure><p>换一种可行的方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> * PCHAR;</span><br><span class="line"></span><br><span class="line">PCHAR pa, pb;</span><br></pre></td></tr></table></figure><p>实际上等同于：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> * pa, *pb;</span><br></pre></td></tr></table></figure><p>2、为数组定义简洁名称。</p><p>示例代码为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> INT_ARRAY_100[<span class="number">100</span>];</span><br><span class="line">INT_ARRAY_100 arr;    <span class="comment">// INT_ARRAY_100表示一个长度为100的int型数组</span></span><br></pre></td></tr></table></figure><p><em><u>番外：</u></em></p><p><em><u>c++11新标准中引入<code>using</code>进行别名定义，使用更加方便、简洁，示例为数组定义简洁名称：</u></em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> INT_ARRAY_100 = <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">INT_ARRAY_100 arr;</span><br></pre></td></tr></table></figure><h3 id="用法二："><a href="#用法二：" class="headerlink" title="用法二："></a>用法二：</h3><p>1、用在旧的C代码中，帮助struct。以前的代码中，声明struct新对象时，必须要带上struct，即形式为： struct 结构名对象名，如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tagPOINT1</span></span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tagPOINT1</span> <span class="title">p1</span>;</span></span><br></pre></td></tr></table></figure><p>而在C++中，则可以直接写：结构名对象名，即：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tagPOINT1 p1;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagPOINT</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;POINT;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POINT p1; <span class="comment">// 这样就比原来的方式少写了一个struct</span></span><br></pre></td></tr></table></figure><p>2、另外，还可以为自定义数据类型（结构体、共用体和枚举类型）定义简洁的类型名称。</p><p>以结构体为例，下面我们定义一个名为Point的结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">double</span> x;</span><br><span class="line"><span class="keyword">double</span> y;</span><br><span class="line"><span class="keyword">double</span> z;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>调用这个结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> <span class="title">oPoint1</span>=&#123;</span><span class="number">100</span>,<span class="number">10</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Ponit</span> <span class="title">oPoint2</span>;</span></span><br></pre></td></tr></table></figure><p>在这里，结构体 <code>struct Point</code> 为新的数据类型，在定义变量的时候均要向上面的调用方法一样有保留字 <code>struct</code>，而不能像 <code>int</code> 和 <code>double</code> 那样直接使用 <code>Point</code> 来定义变量。现在，我们利用 <code>typedef</code> 定义这个结构体，如下面的代码所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagPonit</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">double</span> x;</span><br><span class="line"><span class="keyword">double</span> y;</span><br><span class="line"><span class="keyword">double</span> z;</span><br><span class="line">&#125;Point;</span><br></pre></td></tr></table></figure><p>在上面的代码中，实际上完成了两个操作：</p><p>（1）定义了一个新的结构体类型，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tagPoint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">double</span> x;</span><br><span class="line"><span class="keyword">double</span> y;</span><br><span class="line"><span class="keyword">double</span> z;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在已经定义了一个新的结构体类型<code>tagPoint</code>。</p><p>（2）使用<code>typedef</code>为这个新的结构体起一个别名，叫Point，即：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagPoint</span> <span class="title">Point</span>;</span></span><br></pre></td></tr></table></figure><p>因此，现在你就可以像 int 和 double 那样直接使用 Point 定义变量，如下面的代码所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Point oPoint1=&#123;<span class="number">100</span>,<span class="number">10</span>,<span class="number">0</span>&#125;;</span><br><span class="line">Point oPoint2;</span><br></pre></td></tr></table></figure><p>使用typedef规范定义结构体的方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tagNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> *pItem;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tagNode</span> *<span class="title">pNext</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagNode</span> *<span class="title">pNode</span>;</span></span><br></pre></td></tr></table></figure><p>推荐使用这种使用<code>typedef</code>规范定义结构体的方法，在定义<strong>链表</strong>时经常会用到。</p><h3 id="用法三："><a href="#用法三：" class="headerlink" title="用法三："></a>用法三：</h3><p>用typedef来定义与平台无关的类型。</p><p><strong><u>多使用在跨平台移植程序时！</u></strong></p><p>比如定义一个叫 <code>REAL</code> 的浮点类型，在目标平台一上，让它表示最高精度的类型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">double</span> REAL;</span><br></pre></td></tr></table></figure><p>在不支持 <code>long double</code> 的平台二上，改为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> REAL;</span><br></pre></td></tr></table></figure><p>在连 <code>double</code> 都不支持的平台三上，改为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">float</span> REAL;</span><br></pre></td></tr></table></figure><p>也就是说，当跨平台时，只要改下 <code>typedef</code> 本身就行，不用对其他源码做任何修改。</p><p>标准库就广泛使用了这个技巧，比如<code>size_t</code>。另外，因为<code>typedef</code>是定义了一种类型的新别名，不是简单的字符串替换，所以它比宏来得稳健。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://www.cnblogs.com/csyisong/archive/2009/01/09/1372363.html" target="_blank" rel="noopener">关于typedef的用法总结</a></p><p><a href="http://c.biancheng.net/view/298.html" target="_blank" rel="noopener">typedef的用法，C语言typedef详解</a></p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> typedef </tag>
            
            <tag> define </tag>
            
            <tag> using </tag>
            
            <tag> 宏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matplotlib函数汇总</title>
      <link href="/2020/11/28/Matplotlib-function/"/>
      <url>/2020/11/28/Matplotlib-function/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="matplotlib函数汇总"><a href="#matplotlib函数汇总" class="headerlink" title="matplotlib函数汇总"></a>matplotlib函数汇总</h2><a id="more"></a><iframe border=2 frameborder=0 width=1000 height=900 marginheight=0 marginwidth=0 scrolling=no src="https://www.wulihub.com.cn/gc/WzOlXg/index.html"></iframe>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> matplotlib </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>朴素贝叶斯算法原理及实现</title>
      <link href="/2020/11/10/Naive-bayes/"/>
      <url>/2020/11/10/Naive-bayes/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="一、贝叶斯算法原理"><a href="#一、贝叶斯算法原理" class="headerlink" title="一、贝叶斯算法原理"></a>一、贝叶斯算法原理</h2><h3 id="1-条件概率公式"><a href="#1-条件概率公式" class="headerlink" title="1.条件概率公式"></a>1.条件概率公式</h3><p>根据文氏图，可以看到在事件B发生的情况下，事件A发生的概率为：</p><a id="more"></a><p><a href="https://www.codecogs.com/eqnedit.php?latex=P(A|B)=\frac{P(A\cap&space;B)}{P(B)}" target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?P(A|B)=\frac{P(A\cap&space;B)}{P(B)}" title="P(A|B)=\frac{P(A\cap B)}{P(B)}" /></a>，其中<a href="https://www.codecogs.com/eqnedit.php?latex=P(A\cap&space;B)" target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?P(A\cap&space;B)" title="P(A\cap B)" /></a>又可写为<a href="https://www.codecogs.com/eqnedit.php?latex=P(AB)" target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?P(AB)" title="P(AB)" /></a></p><p>因此：<a href="https://www.codecogs.com/eqnedit.php?latex=P(A\cap&space;B)=P(A|B){P(B)}" target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?P(A\cap&space;B)=P(A|B){P(B)}" title="P(A\cap B)=P(A|B){P(B)}" /></a></p><p>同理又有：<a href="https://www.codecogs.com/eqnedit.php?latex=P(A\cap&space;B)=P(B|A){P(A)}" target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?P(A\cap&space;B)=P(B|A){P(A)}" title="P(A\cap B)=P(B|A){P(A)}" /></a></p><p>所以：<a href="https://www.codecogs.com/eqnedit.php?latex=P(B|A){P(A)}=P(A|B){P(B)}" target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?P(B|A){P(A)}=P(A|B){P(B)}" title="P(B|A){P(A)}=P(A|B){P(B)}" /></a>，<a href="https://www.codecogs.com/eqnedit.php?latex=P(A\cap&space;B)" target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?P(A\cap&space;B)" title="P(A\cap B)" /></a>称为联合概率。</p><p><a href="https://www.codecogs.com/eqnedit.php?latex=P(A|B)=\frac{P(B|A)P(A)}{P(B)}" target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?P(A|B)=\frac{P(B|A)P(A)}{P(B)}" title="P(A|B)=\frac{P(B|A)P(A)}{P(B)}" /></a></p><p>即为条件概率公式。</p><p><a href="https://imgchr.com/i/BbzL3F" target="_blank" rel="noopener"><img src="/loading.gif" data-original="https://s1.ax1x.com/2020/11/10/BbzL3F.jpg" alt=""></a></p><h3 id="2-全概率公式"><a href="#2-全概率公式" class="headerlink" title="2.全概率公式"></a>2.全概率公式</h3><p>如果事件B1，B2，B3，…，Bn 构成一个完备事件组，即它们两两互不相容，其和为全集；并且P(Bi)大于0，则对任一事件A有：</p><p><a href="https://www.codecogs.com/eqnedit.php?latex=P(A)=P(A|B_{1})\*P(B_{1})&space;&plus;&space;P(A|B_{2})\*P(B_{2})&space;&plus;&space;...&space;&plus;&space;P(A|B_{n})\*P(B_{n})" target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?P(A)=P(A|B_{1})\*P(B_{1})&space;&plus;&space;P(A|B_{2})\*P(B_{2})&space;&plus;&space;...&space;&plus;&space;P(A|B_{n})\*P(B_{n})" title="P(A)=P(A|B_{1})\*P(B_{1}) + P(A|B_{2})\*P(B_{2}) + ... + P(A|B_{n})\*P(B_{n})" /></a></p><h3 id="3-贝叶斯定理"><a href="#3-贝叶斯定理" class="headerlink" title="3.贝叶斯定理"></a>3.贝叶斯定理</h3><p>贝叶斯定理是关于随机事件A和B的条件概率（或边缘概率）的一则定理。其中P(A|B)是在B发生的情况下A发生的可能性。</p><p><a href="https://www.codecogs.com/eqnedit.php?latex=P(A|B)=\frac{P(B|A)P(A)}{P(B)}" target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?P(A|B)=\frac{P(B|A)P(A)}{P(B)}" title="P(A|B)=\frac{P(B|A)P(A)}{P(B)}" /></a></p><p>举个例子：一个鸢尾花数据有四个特征，其特征分别为：sepal length、sepal width、petal length、petal width，三个类别，分别为：Iris Setosa、Iris Versicolour、Iris Virginica，现在有一组鸢尾花数据：5.5，2.6，4.4，1.2，判断此鸢尾花属于哪种。</p><p>由贝叶斯定理我们可以计算此条件下属于各个类别的概率，</p><p><a href="https://www.codecogs.com/eqnedit.php?latex=P(setosa|sepallen*sepalwid*petallen*petalwid)=\frac{P(sepallen*sepalwid*petallen*petalwid|setosa)}{P(sepallen*sepalwid*petallen*petalwid)}" target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?P(setosa|sepallen*sepalwid*petallen*petalwid)=\frac{P(sepallen*sepalwid*petallen*petalwid|setosa)}{P(sepallen*sepalwid*petallen*petalwid)}" title="P(setosa|sepallen*sepalwid*petallen*petalwid)=\frac{P(sepallen*sepalwid*petallen*petalwid|setosa)}{P(sepallen*sepalwid*petallen*petalwid)}" /></a></p><p>同理，依次可以计算属于类别 Versicolour、Virginica的概率。概率最大的类别即为最有可能的鸢尾花类别。</p><p>但是，可以看到<a href="https://www.codecogs.com/eqnedit.php?latex=P(sepallen*sepalwid*petallen*petalwid|setosa)" target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?P(sepallen*sepalwid*petallen*petalwid|setosa)" title="P(sepallen*sepalwid*petallen*petalwid|setosa)" /></a>并不好计算，此时，我们可以将鸢尾花数据的四个特征看作相互独立（即朴素贝叶斯的核心），所以有：</p><p><a href="https://www.codecogs.com/eqnedit.php?latex=P(sepallen*sepalwid*petallen*petalwid|setosa)" target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?P(sepallen*sepalwid*petallen*petalwid|setosa)" title="P(sepallen*sepalwid*petallen*petalwid|setosa)" /></a> = <a href="https://www.codecogs.com/eqnedit.php?latex=P(sepallen|setosa)*P(sepalwid|setosa)*P(petallen|setosa)*P(petalwid|setosa)" target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?P(sepallen|setosa)*P(sepalwid|setosa)*P(petallen|setosa)*P(petalwid|setosa)" title="P(sepallen|setosa)*P(sepalwid|setosa)*P(petallen|setosa)*P(petalwid|setosa)" /></a></p><p>此时我们只需要计算<a href="https://www.codecogs.com/eqnedit.php?latex=P(sepallen|setosa)" target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?P(sepallen|setosa)" title="P(sepallen|setosa)" /></a>等单个特征值概率即可。</p><h3 id="4-高斯分布"><a href="#4-高斯分布" class="headerlink" title="4.高斯分布"></a>4.高斯分布</h3><p>上述例子中，sepal length、sepal width、petal length、petal width等特征均为连续变量，<a href="https://www.codecogs.com/eqnedit.php?latex=P(sepallen|setosa)" target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?P(sepallen|setosa)" title="P(sepallen|setosa)" /></a>该如何计算？我们可以假设在<strong>setosa</strong>的条件下，<strong>sepallen</strong>服从高斯分布（正态分布）。根据正态分布的概率密度函数即可计算出<a href="https://www.codecogs.com/eqnedit.php?latex=P(sepallen|setosa)" target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?P(sepallen|setosa)" title="P(sepallen|setosa)" /></a>，公式如下：<a href="https://www.codecogs.com/eqnedit.php?latex=P(x)=\frac{1}{\sqrt{2\pi&space;\sigma&space;^{2}}}e^{-\frac{(x-\mu&space;)^{2}}{2\sigma&space;^{2}}}" target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?P(x)=\frac{1}{\sqrt{2\pi&space;\sigma&space;^{2}}}e^{-\frac{(x-\mu&space;)^{2}}{2\sigma&space;^{2}}}" title="P(x)=\frac{1}{\sqrt{2\pi \sigma ^{2}}}e^{-\frac{(x-\mu )^{2}}{2\sigma ^{2}}}" /></a></p><h2 id="二、朴素贝叶斯处理过程"><a href="#二、朴素贝叶斯处理过程" class="headerlink" title="二、朴素贝叶斯处理过程"></a>二、朴素贝叶斯处理过程</h2><ul><li><p>加载数据：原始数据集载入</p></li><li><p>分类数据：根据贝叶斯定理对数据进行分类</p></li><li><p>训练算法：计算不同的独立特征的条件概率</p></li><li><p>测试算法：计算正确率</p></li><li><p>使用算法：数据分类</p><p><a href="https://imgchr.com/i/BXcu5t" target="_blank" rel="noopener"><img src="/loading.gif" data-original="https://s1.ax1x.com/2020/11/11/BXcu5t.png" alt=""></a></p></li></ul><h2 id="三、朴素贝叶斯分类实现"><a href="#三、朴素贝叶斯分类实现" class="headerlink" title="三、朴素贝叶斯分类实现"></a>三、朴素贝叶斯分类实现</h2><h3 id="1-数据集说明"><a href="#1-数据集说明" class="headerlink" title="1.数据集说明"></a>1.数据集说明</h3><p>朴素贝叶斯分类实现鸢尾花数据分类，数据集来源：<a href="https://archive.ics.uci.edu/ml/datasets/iris。算法实现之前，按照8：2的比例将原始数据集分为训练数据集和测试数据集，原始数据集中每个类别抽取10个样本组成一个总共30个样本的测试数据集。" target="_blank" rel="noopener">https://archive.ics.uci.edu/ml/datasets/iris。算法实现之前，按照8：2的比例将原始数据集分为训练数据集和测试数据集，原始数据集中每个类别抽取10个样本组成一个总共30个样本的测试数据集。</a></p><p>数据集说明：</p><blockquote><p>Attribute Information:</p><ol><li>sepal length in cm</li><li>sepal width in cm</li><li>petal length in cm</li><li>petal width in cm</li><li>class:<br>— Iris Setosa<br>— Iris Versicolour<br>— Iris Virginica</li></ol></blockquote><h3 id="2-加载数据集"><a href="#2-加载数据集" class="headerlink" title="2.加载数据集"></a>2.加载数据集</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    iris数据集载入</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_data</span><span class="params">(file)</span>:</span></span><br><span class="line">    x_data=[]</span><br><span class="line">    y_data=[]</span><br><span class="line">    data=[]</span><br><span class="line">    <span class="keyword">with</span> open(file,<span class="string">'r'</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        lines=fp.readlines()</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">            line=line.strip().split(<span class="string">','</span>)</span><br><span class="line">            x_data.append(line[:<span class="number">-1</span>])</span><br><span class="line">            y_data.append((line[<span class="number">-1</span>]))</span><br><span class="line">            data.append(line)</span><br><span class="line">    <span class="keyword">return</span> x_data,y_data,data</span><br></pre></td></tr></table></figure><h3 id="3-计算训练集均值"><a href="#3-计算训练集均值" class="headerlink" title="3.计算训练集均值"></a>3.计算训练集均值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_mean</span><span class="params">(x,lable)</span>:</span></span><br><span class="line">    <span class="comment">#获取每个类别的均值</span></span><br><span class="line">    means=[]</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        sum=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">120</span>):</span><br><span class="line">            <span class="keyword">if</span> (lable==x[i,<span class="number">4</span>]):</span><br><span class="line">                sum+=float(x[i,j])</span><br><span class="line">        means.append(sum/<span class="number">40</span>)</span><br><span class="line">    <span class="keyword">return</span> means</span><br></pre></td></tr></table></figure><p>4.计算训练集方差</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_var</span><span class="params">(x,mean,label)</span>:</span></span><br><span class="line">    <span class="comment">#获取每个类别的方差</span></span><br><span class="line">    vars=[]</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        sum=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">120</span>):</span><br><span class="line">            <span class="keyword">if</span> (label==x[i,<span class="number">4</span>]):</span><br><span class="line">                sum+=(float(x[i,j])-mean[j])**<span class="number">2</span></span><br><span class="line">        vars.append(sum/<span class="number">40</span>)</span><br><span class="line">    <span class="keyword">return</span> vars</span><br></pre></td></tr></table></figure><h3 id="5-计算先验概率"><a href="#5-计算先验概率" class="headerlink" title="5.计算先验概率"></a>5.计算先验概率</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_prior</span><span class="params">(x,label)</span>:</span></span><br><span class="line">    <span class="comment">#获取每个类别的先验概率</span></span><br><span class="line">    cnt=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(x)):</span><br><span class="line">        <span class="keyword">if</span> (label==x[i,<span class="number">4</span>]):</span><br><span class="line">            cnt+=<span class="number">1</span></span><br><span class="line">    prior=cnt/len(x)</span><br><span class="line">    <span class="keyword">return</span> prior</span><br></pre></td></tr></table></figure><h3 id="6-计算后验概率"><a href="#6-计算后验概率" class="headerlink" title="6.计算后验概率"></a>6.计算后验概率</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_postpro</span><span class="params">(mean,var,xi)</span>:</span></span><br><span class="line">    <span class="comment">#获取每个类别的后验概率</span></span><br><span class="line">    p=(<span class="number">1</span>/np.sqrt(<span class="number">2</span>*math.pi*var))*np.exp(-((float(xi)-mean)**<span class="number">2</span>)/(<span class="number">2</span>*var))</span><br><span class="line">    <span class="keyword">return</span> p</span><br></pre></td></tr></table></figure><h3 id="7-计算似然度"><a href="#7-计算似然度" class="headerlink" title="7.计算似然度"></a>7.计算似然度</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_likelihood</span><span class="params">(mean,var,x)</span>:</span></span><br><span class="line">    <span class="comment">#根据后验概率计算似然度</span></span><br><span class="line">    p=<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        p=get_postpro(mean[i],var[i],x[i])</span><br><span class="line">        p*=p</span><br><span class="line">    <span class="keyword">return</span> p</span><br></pre></td></tr></table></figure><h3 id="8-训练模型"><a href="#8-训练模型" class="headerlink" title="8.训练模型"></a>8.训练模型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fit_model</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="comment">#训练模型</span></span><br><span class="line">    mean_set=get_mean(x,<span class="string">'Iris-setosa'</span>)</span><br><span class="line">    mean_ver=get_mean(x,<span class="string">'Iris-versicolor'</span>)</span><br><span class="line">    mean_vir=get_mean(x,<span class="string">'Iris-virginica'</span>)</span><br><span class="line">    var_set=get_var(x,mean_set,<span class="string">'Iris-setosa'</span>)</span><br><span class="line">    var_ver=get_var(x,mean_ver,<span class="string">'Iris-versicolor'</span>)</span><br><span class="line">    var_vir=get_var(x,mean_vir,<span class="string">'Iris-virginica'</span>)</span><br><span class="line">    <span class="keyword">return</span> mean_set,mean_ver,mean_vir,var_set,var_ver,var_vir</span><br></pre></td></tr></table></figure><h3 id="9-预测类别"><a href="#9-预测类别" class="headerlink" title="9.预测类别"></a>9.预测类别</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="comment">#预测类别</span></span><br><span class="line">    proba=[]</span><br><span class="line">    mean_set,mean_ver,mean_vir,var_set,var_ver,var_vir=fit_model(X_train)</span><br><span class="line">    p1=get_likelihood(mean_set,var_set,x[:<span class="number">-1</span>])</span><br><span class="line">    p2=get_likelihood(mean_ver,var_ver, x[:<span class="number">-1</span>])</span><br><span class="line">    p3=get_likelihood(mean_vir,var_vir, x[:<span class="number">-1</span>])</span><br><span class="line">    proba.append(p1)</span><br><span class="line">    proba.append(p2)</span><br><span class="line">    proba.append(p3)</span><br><span class="line">    sort=np.argmax(proba)</span><br><span class="line">    <span class="keyword">return</span> sort</span><br></pre></td></tr></table></figure><h3 id="10-效果评估"><a href="#10-效果评估" class="headerlink" title="10.效果评估"></a>10.效果评估</h3><p>对于运算结果，在此只截取了一部分，可以看到总准确率为100%，朴素贝叶斯得到的各个类别的相对概率值差别很大，结果显而易见。这个结果并不能说明朴素贝叶斯的分类效果特别好，只是这个鸢尾花测试数据集数据太理想，没有一点误差，数据集很干净。</p><p><a href="https://imgchr.com/i/BqqQAS" target="_blank" rel="noopener"><img src="/loading.gif" data-original="https://s1.ax1x.com/2020/11/10/BqqQAS.md.png" alt=""></a></p><p>通过散点图同时展示该测试数据集的四个不同维度：图中的(x, y)位置代表每个样本的花萼的长度和宽度（sepal length、sepal width），散点的大小代表每个样本的花瓣的长度（petal length），而散点的颜色代表一种特定的鸢尾花类型。</p><p><a href="https://imgchr.com/i/BX61B9" target="_blank" rel="noopener"><img src="/loading.gif" data-original="https://s1.ax1x.com/2020/11/11/BX61B9.png" alt=""></a></p><h2 id="四、附录"><a href="#四、附录" class="headerlink" title="四、附录"></a>四、附录</h2><p>load_data.py文件，实现数据载入。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    iris数据集载入</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_data</span><span class="params">(file)</span>:</span></span><br><span class="line">    x_data=[]</span><br><span class="line">    y_data=[]</span><br><span class="line">    data=[]</span><br><span class="line">    <span class="keyword">with</span> open(file,<span class="string">'r'</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        lines=fp.readlines()</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">            line=line.strip().split(<span class="string">','</span>)</span><br><span class="line">            x_data.append(line[:<span class="number">-1</span>])</span><br><span class="line">            y_data.append((line[<span class="number">-1</span>]))</span><br><span class="line">            data.append(line)</span><br><span class="line">    <span class="keyword">return</span> x_data,y_data,data</span><br></pre></td></tr></table></figure><p>naive_bayes.py文件，实现贝叶斯模型训练，测试数据集分类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">from</span> load_data <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_mean</span><span class="params">(x,lable)</span>:</span></span><br><span class="line">    <span class="comment">#获取每个类别的均值</span></span><br><span class="line">    means=[]</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        sum=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">120</span>):</span><br><span class="line">            <span class="keyword">if</span> (lable==x[i,<span class="number">4</span>]):</span><br><span class="line">                sum+=float(x[i,j])</span><br><span class="line">        means.append(sum/<span class="number">40</span>)</span><br><span class="line">    <span class="keyword">return</span> means</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_var</span><span class="params">(x,mean,label)</span>:</span></span><br><span class="line">    <span class="comment">#获取每个类别的方差</span></span><br><span class="line">    vars=[]</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        sum=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">120</span>):</span><br><span class="line">            <span class="keyword">if</span> (label==x[i,<span class="number">4</span>]):</span><br><span class="line">                sum+=(float(x[i,j])-mean[j])**<span class="number">2</span></span><br><span class="line">        vars.append(sum/<span class="number">40</span>)</span><br><span class="line">    <span class="keyword">return</span> vars</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_prior</span><span class="params">(x,label)</span>:</span></span><br><span class="line">    <span class="comment">#获取每个类别的先验概率</span></span><br><span class="line">    cnt=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(x)):</span><br><span class="line">        <span class="keyword">if</span> (label==x[i,<span class="number">4</span>]):</span><br><span class="line">            cnt+=<span class="number">1</span></span><br><span class="line">    prior=cnt/len(x)</span><br><span class="line">    <span class="keyword">return</span> prior</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_postpro</span><span class="params">(mean,var,xi)</span>:</span></span><br><span class="line">    <span class="comment">#获取每个类别的后验概率</span></span><br><span class="line">    p=(<span class="number">1</span>/np.sqrt(<span class="number">2</span>*math.pi*var))*np.exp(-((float(xi)-mean)**<span class="number">2</span>)/(<span class="number">2</span>*var))</span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_likelihood</span><span class="params">(mean,var,x)</span>:</span></span><br><span class="line">    <span class="comment">#根据后验概率计算似然度</span></span><br><span class="line">    p=<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        p=get_postpro(mean[i],var[i],x[i])</span><br><span class="line">        p*=p</span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fit_model</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="comment">#训练模型</span></span><br><span class="line">    mean_set=get_mean(x,<span class="string">'Iris-setosa'</span>)</span><br><span class="line">    mean_ver=get_mean(x,<span class="string">'Iris-versicolor'</span>)</span><br><span class="line">    mean_vir=get_mean(x,<span class="string">'Iris-virginica'</span>)</span><br><span class="line">    var_set=get_var(x,mean_set,<span class="string">'Iris-setosa'</span>)</span><br><span class="line">    var_ver=get_var(x,mean_ver,<span class="string">'Iris-versicolor'</span>)</span><br><span class="line">    var_vir=get_var(x,mean_vir,<span class="string">'Iris-virginica'</span>)</span><br><span class="line">    <span class="keyword">return</span> mean_set,mean_ver,mean_vir,var_set,var_ver,var_vir</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="comment">#预测类别</span></span><br><span class="line">    proba=[]</span><br><span class="line">    mean_set, mean_ver, mean_vir, var_set, var_ver, var_vir = fit_model(X_train)</span><br><span class="line">    p1=get_likelihood(mean_set,var_set,x[:<span class="number">-1</span>])</span><br><span class="line">    p2=get_likelihood(mean_ver, var_ver, x[:<span class="number">-1</span>])</span><br><span class="line">    p3=get_likelihood(mean_vir, var_vir, x[:<span class="number">-1</span>])</span><br><span class="line">    proba.append(p1)</span><br><span class="line">    proba.append(p2)</span><br><span class="line">    proba.append(p3)</span><br><span class="line">    print(<span class="string">'proba is '</span>,proba)</span><br><span class="line">    sort=np.argmax(proba)</span><br><span class="line">    <span class="keyword">return</span> sort</span><br><span class="line"></span><br><span class="line">file1=<span class="string">'C:\\Users\\wnxy\\PycharmProjects\\NaiveBayesian\\iris_data\\iris_train.data'</span></span><br><span class="line">file2=<span class="string">'C:\\Users\\wnxy\\PycharmProjects\\NaiveBayesian\\iris_data\\iris_test.data'</span></span><br><span class="line">x_train_data,y_train_data,x_train=load_data(file1)</span><br><span class="line">X_train_data=np.mat(x_train_data)</span><br><span class="line">Y_train_data=np.mat(y_train_data)</span><br><span class="line">X_train=np.mat(x_train)</span><br><span class="line">mean_set,mean_ver,mean_vir,var_set,var_ver,var_vir=fit_model(X_train)</span><br><span class="line">prior_set=get_prior(X_train,<span class="string">'Iris-setosa'</span>)</span><br><span class="line">prior_ver=get_prior(X_train,<span class="string">'Iris-versicolor'</span>)</span><br><span class="line">prior_vir=get_prior(X_train,<span class="string">'Iris-virginica'</span>)</span><br><span class="line">print(<span class="string">'prior_set'</span>,prior_set)</span><br><span class="line">cnt = <span class="number">0</span></span><br><span class="line"><span class="keyword">with</span> open(file2,<span class="string">'r'</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    x_test=[]</span><br><span class="line">    lines=fp.readlines()</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        line = line.strip().split(<span class="string">','</span>)</span><br><span class="line">        x_test.append(line)</span><br><span class="line">        sort=predict(x_test[<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">if</span> (x_test[<span class="number">-1</span>][<span class="number">4</span>]==<span class="string">'Iris-setosa'</span>):</span><br><span class="line">            y_test=<span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> (x_test[<span class="number">-1</span>][<span class="number">4</span>]==<span class="string">'Iris-versicolor'</span>):</span><br><span class="line">            y_test=<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            y_test=<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> (y_test==sort):</span><br><span class="line">            cnt+=<span class="number">1</span></span><br><span class="line">        print(<span class="string">'The prediction is classified as: '</span>,sort)</span><br><span class="line">        print(<span class="string">'The fact is classified as: '</span>, y_test)</span><br><span class="line">print(<span class="string">'Accuracy is: '</span>,cnt/len(lines))</span><br><span class="line">y_test=np.array(y_test)</span><br><span class="line">seplen = []</span><br><span class="line">sepwid = []</span><br><span class="line">petlen = []</span><br><span class="line">petwid = []</span><br><span class="line">colors=[<span class="string">'purple'</span>,<span class="string">'y'</span>,<span class="string">'b'</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">30</span>):</span><br><span class="line">    seplen.append(x_test[i][<span class="number">0</span>])</span><br><span class="line">    sepwid.append(x_test[i][<span class="number">1</span>])</span><br><span class="line">    petlen.append(x_test[i][<span class="number">2</span>])</span><br><span class="line">    petwid.append(x_test[i][<span class="number">3</span>])</span><br><span class="line">    index=y_test[i]</span><br><span class="line">    plt.scatter(float(seplen[i]), float(sepwid[i]), alpha=<span class="number">0.2</span>, s=<span class="number">100</span>*float(petlen[i]), c=colors[index], cmap=<span class="string">'viridis'</span>)</span><br><span class="line">plt.ylim(<span class="number">2.0</span>,<span class="number">4.0</span>)</span><br><span class="line">plt.title(<span class="string">'Iris Data Classification'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'sepal length in cm'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'sepal width in cm'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Machine-Learning </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 朴素贝叶斯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据可视化模块Matplotlib实操</title>
      <link href="/2020/11/02/Data-visualization-matplotlib/"/>
      <url>/2020/11/02/Data-visualization-matplotlib/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>通过 Matplotlib，开发者可以仅需要几行代码，便可以生成绘图，直方图，功率谱，条形图，错误图，散点图等。</p><h1 id="导读"><a href="#导读" class="headerlink" title="导读"></a><strong>导读</strong></h1><p>Matplotlib 是一个 Python 的 2D绘图库，它以各种硬拷贝格式和跨平台的交互式环境生成出版质量级别的图形。通过 Matplotlib，开发者可以仅需要几行代码，便可以生成绘图，直方图，功率谱，条形图，错误图，散点图等。</p><a id="more"></a><p>以下内容来自Github，为《PythonDataScienceHandbook[1]》(Python 数据科学手册[2])第四章Matplotlib介绍部分。全部内容都在以下环境演示通过：</p><ul><li>numpy:1.18.5</li><li>pandas:1.0.5</li><li>matplotlib:3.2.1</li></ul><blockquote><p>文章转自微信公众号：<strong>DataWhale</strong></p><p>如有侵权，联系删除！</p></blockquote><h1 id="1-简单的折线图"><a href="#1-简单的折线图" class="headerlink" title="1.简单的折线图"></a><strong>1.简单的折线图</strong></h1><p>对于图表来说，最简单的莫过于作出一个单一函数  的图像。本节中我们首先来介绍创建这种类型图表。本节和后续小节中，我们都会使用下面的代码将我们需要的包载入到 notebook 中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.style.use(<span class="string">'seaborn-whitegrid'</span>)</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><p>对于所有的 Matplotlib 图表来说，我们都需要从创建图形和维度开始。图形和维度可以使用下面代码进行最简形式的创建：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fig = plt.figure()</span><br><span class="line">ax = plt.axes()</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102223923.png" alt=""></p><p>在 Matplotlib 中，图形（类plt.Figure的一个实例）可以被认为是一个包括所有维度、图像、文本和标签对象的容器。维度（类plt.Axes的一个实例）就是你上面看到的图像，一个有边界的格子包括刻度和标签，最终还有我们画在上面的图表元素。在本书中，我们会使用变量名fig来指代图形对象，以及变量名ax来指代维度变量。</p><p>一旦我们创建了维度，我们可以使用ax.plot方法将数据绘制在图表上。下面是一个简单的正弦函数图形：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fig = plt.figure()</span><br><span class="line">ax = plt.axes()</span><br><span class="line"></span><br><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">10</span>, <span class="number">1000</span>)</span><br><span class="line">ax.plot(x, np.sin(x));</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102223854.png" alt=""></p><p>同样的，我们可以使用 pylab 接口（MATLAB 风格的接口）帮我们在后台自动创建这两个对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(x, np.sin(x));</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102223854.png" alt=""></p><p>如果我们需要在同一幅图形中绘制多根线条，只需要多次调用<code>plot</code>函数即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(x, np.sin(x))</span><br><span class="line">plt.plot(x, np.cos(x));</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102223933.png" alt=""></p><p>这就是在 Matplotlib 中绘制简单函数图像的所有接口了。下面我们深入了解一下控制坐标轴和线条外观的细节。</p><h2 id="调整折线图：线条颜色和风格"><a href="#调整折线图：线条颜色和风格" class="headerlink" title="调整折线图：线条颜色和风格"></a><strong>调整折线图：线条颜色和风格</strong></h2><p>你可能第一个想到需要进行调整的部分就是线条的颜色和风格。plt.plot()函数接受额外的参数可以用来指定它们。通过指定color关键字参数可以调整颜色，这个字符串类型参数基本上能用来代表任何你能想到的颜色。可以通过多种方式指定颜色参数：</p><p>所有 HTML 颜色名称可以在这里[3]找到。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(x, np.sin(x - <span class="number">0</span>), color=<span class="string">'blue'</span>)        <span class="comment"># 通过颜色名称指定</span></span><br><span class="line">plt.plot(x, np.sin(x - <span class="number">1</span>), color=<span class="string">'g'</span>)           <span class="comment"># 通过颜色简写名称指定(rgbcmyk)</span></span><br><span class="line">plt.plot(x, np.sin(x - <span class="number">2</span>), color=<span class="string">'0.75'</span>)        <span class="comment"># 介于0-1之间的灰阶值</span></span><br><span class="line">plt.plot(x, np.sin(x - <span class="number">3</span>), color=<span class="string">'#FFDD44'</span>)     <span class="comment"># 16进制的RRGGBB值</span></span><br><span class="line">plt.plot(x, np.sin(x - <span class="number">4</span>), color=(<span class="number">1.0</span>,<span class="number">0.2</span>,<span class="number">0.3</span>)) <span class="comment"># RGB元组的颜色值，每个值介于0-1</span></span><br><span class="line">plt.plot(x, np.sin(x - <span class="number">5</span>), color=<span class="string">'chartreuse'</span>); <span class="comment"># 能支持所有HTML颜色名称值</span></span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102223938.png" alt=""></p><p>如果没有指定颜色，Matplotlib 会在一组默认颜色值中循环使用来绘制每一条线条。</p><p>类似的，通过linestyle关键字参数可以指定线条的风格：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(x, x + <span class="number">0</span>, linestyle=<span class="string">'solid'</span>)</span><br><span class="line">plt.plot(x, x + <span class="number">1</span>, linestyle=<span class="string">'dashed'</span>)</span><br><span class="line">plt.plot(x, x + <span class="number">2</span>, linestyle=<span class="string">'dashdot'</span>)</span><br><span class="line">plt.plot(x, x + <span class="number">3</span>, linestyle=<span class="string">'dotted'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 还可以用形象的符号代表线条风格</span></span><br><span class="line">plt.plot(x, x + <span class="number">4</span>, linestyle=<span class="string">'-'</span>)  <span class="comment"># 实线</span></span><br><span class="line">plt.plot(x, x + <span class="number">5</span>, linestyle=<span class="string">'--'</span>) <span class="comment"># 虚线</span></span><br><span class="line">plt.plot(x, x + <span class="number">6</span>, linestyle=<span class="string">'-.'</span>) <span class="comment"># 长短点虚线</span></span><br><span class="line">plt.plot(x, x + <span class="number">7</span>, linestyle=<span class="string">':'</span>);  <span class="comment"># 点线</span></span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102223941.png" alt=""></p><p>如果你喜欢更简洁的代码，这些linestyle和color参数能够合并成一个非关键字参数，传递给plt.plot()函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(x, x + <span class="number">0</span>, <span class="string">'-g'</span>)  <span class="comment"># 绿色实线</span></span><br><span class="line">plt.plot(x, x + <span class="number">1</span>, <span class="string">'--c'</span>) <span class="comment"># 天青色虚线</span></span><br><span class="line">plt.plot(x, x + <span class="number">2</span>, <span class="string">'-.k'</span>) <span class="comment"># 黑色长短点虚线</span></span><br><span class="line">plt.plot(x, x + <span class="number">3</span>, <span class="string">':r'</span>);  <span class="comment"># 红色点线</span></span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102223945.png" alt=""></p><p>上面的单字母颜色码是 RGB 颜色系统以及 CMYK 颜色系统的缩写，被广泛应用在数字化图像的颜色系统中。</p><p>还有很多其他的关键字参数可以对折线图的外观进行精细调整；可以通过在 IPython 中使用帮助工具查看plt.plot()函数的文档来获得更多细节内容。</p><h2 id="调整折线图：坐标轴范围"><a href="#调整折线图：坐标轴范围" class="headerlink" title="调整折线图：坐标轴范围"></a><strong>调整折线图：坐标轴范围</strong></h2><p>Matplotlib 会自动选择非常合适的坐标轴范围来绘制你的图像，但是有些情况下你也需要自己进行相关调整。使用plt.xlim()和plt.ylim()函数可以调整坐标轴的范围：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(x, np.sin(x))</span><br><span class="line"></span><br><span class="line">plt.xlim(<span class="number">-1</span>, <span class="number">11</span>)</span><br><span class="line">plt.ylim(<span class="number">-1.5</span>, <span class="number">1.5</span>);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102223949.png" alt=""></p><p>如果某些情况下你希望将坐标轴反向，你可以通过上面的函数实现，将参数顺序颠倒即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(x, np.sin(x))</span><br><span class="line"></span><br><span class="line">plt.xlim(<span class="number">10</span>, <span class="number">0</span>)</span><br><span class="line">plt.ylim(<span class="number">1.2</span>, <span class="number">-1.2</span>);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102223953.png" alt=""></p><p>相关的函数还有plt.axis()（注意：这不是plt.axes()函数，函数名称是 i 而不是 e）。这个函数可以在一个函数调用中就完成 x 轴和 y 轴范围的设置，传递一个[xmin, xmax, ymin, ymax]的列表参数即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(x, np.sin(x))</span><br><span class="line">plt.axis([<span class="number">-1</span>, <span class="number">11</span>, <span class="number">-1.5</span>, <span class="number">1.5</span>]);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102223955.png" alt=""></p><p>当然plt.axis()函数不仅能设置范围，还能像下面代码一样将坐标轴压缩到刚好足够绘制折线图像的大小：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(x, np.sin(x))</span><br><span class="line">plt.axis(<span class="string">'tight'</span>);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102223958.png" alt=""></p><p>还可以通过设置’equal’参数设置x轴与y轴使用相同的长度单位：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(x, np.sin(x))</span><br><span class="line">plt.axis(<span class="string">'equal'</span>);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224002.jpg" alt=""></p><p>更多关于设置 axis 属性的内容请查阅plt.axis函数的文档字符串。</p><h2 id="折线图标签"><a href="#折线图标签" class="headerlink" title="折线图标签"></a><strong>折线图标签</strong></h2><p>本节最后介绍一下在折线图上绘制标签：标题、坐标轴标签和简单的图例。</p><p>标题和坐标轴标签是最简单的这类标签，Matplotlib 提供了函数用来方便的设置它们：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(x, np.sin(x))</span><br><span class="line">plt.title(<span class="string">"A Sine Curve"</span>)</span><br><span class="line">plt.xlabel(<span class="string">"x"</span>)</span><br><span class="line">plt.ylabel(<span class="string">"sin(x)"</span>);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224134.png" alt=""></p><p>这些标签的位置、大小和风格可以通过上面函数的可选参数进行设置。参阅 Matplotlib 在线文档和这些函数的文档字符串可以获得更多的信息。</p><p>当一幅图中绘制了多条折线时，如果能够绘制一个线条对应的图例能让图表更加清晰。Matplotlib 也内建了函数来快速创建图例。估计你也猜到了，通过plt.legend()函数可以实现这个需求。虽然有很多种正确的方法来指定图例，作者认为最简单的方法是通过在绘制每条线条时指定对应的label关键字参数来使用这个函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(x, np.sin(x), <span class="string">'-g'</span>, label=<span class="string">'sin(x)'</span>)</span><br><span class="line">plt.plot(x, np.cos(x), <span class="string">':b'</span>, label=<span class="string">'cos(x)'</span>)</span><br><span class="line">plt.axis(<span class="string">'equal'</span>)</span><br><span class="line"></span><br><span class="line">plt.legend();</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224138.png" alt=""></p><p>上图可见，plt.legend()函数绘制的图例线条与图中的折线无论风格和颜色都保持一致。查阅plt.legend文档字符串可以获得更多相关信息；我们在[自定义图表图例]一节中也会讨论更高级的图例应用。</p><h2 id="额外内容：Matplotlib-的坑"><a href="#额外内容：Matplotlib-的坑" class="headerlink" title="额外内容：Matplotlib 的坑"></a><strong>额外内容：Matplotlib 的坑</strong></h2><p>虽然大多数的plt函数都可以直接转换为ax的方法进行调用（例如plt.plot() → ax.plot()，plt.legend() → ax.legend()等），但是并不是所有的命令都能应用这种情况。特别是用于设置极值、标签和标题的函数都有一定的改变。下表列出了将 MATLAB 风格的函数转换为面向对象的方法的区别：</p><ul><li>plt.xlabel() → ax.set_xlabel()</li><li>plt.ylabel() → ax.set_ylabel()</li><li>plt.xlim() → ax.set_xlim()</li><li>plt.ylim() → ax.set_ylim()</li><li>plt.title() → ax.set_title()</li></ul><p>在面向对象接口中，与其逐个调用上面的方法来设置属性，更常见的使用ax.set()方法来一次性设置所有的属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ax = plt.axes()</span><br><span class="line">ax.plot(x, np.sin(x))</span><br><span class="line">ax.set(xlim=(<span class="number">0</span>, <span class="number">10</span>), ylim=(<span class="number">-2</span>, <span class="number">2</span>),</span><br><span class="line">       xlabel=<span class="string">'x'</span>, ylabel=<span class="string">'sin(x)'</span>,</span><br><span class="line">       title=<span class="string">'A Simple Plot'</span>);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224143.png" alt=""></p><h1 id="2-简单散点图"><a href="#2-简单散点图" class="headerlink" title="2.简单散点图"></a><strong>2.简单散点图</strong></h1><p>另一种常用的图表类型是简单散点图，它是折线图的近亲。不像折线图，图中的点连接起来组成连线，散点图中的点都是独立分布的点状、圆圈或其他形状。本节开始我们也是首先将需要用到的图表工具和函数导入到 notebook 中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.style.use(<span class="string">'seaborn-whitegrid'</span>)</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><h2 id="使用-plt-plot-绘制散点图"><a href="#使用-plt-plot-绘制散点图" class="headerlink" title="使用 plt.plot 绘制散点图"></a><strong>使用 plt.plot 绘制散点图</strong></h2><p>在上一节中，我们介绍了plt.plot/ax.plot方法绘制折线图。这两个方法也可以同样用来绘制散点图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">10</span>, <span class="number">30</span>)</span><br><span class="line">y = np.sin(x)</span><br><span class="line"></span><br><span class="line">plt.plot(x, y, <span class="string">'o'</span>, color=<span class="string">'black'</span>);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224148.png" alt=""></p><p>传递给函数的第三个参数是使用一个字符代表的图表绘制点的类型。就像你可以使用’-‘或’—‘来控制线条的风格那样，点的类型风格也可以使用短字符串代码来表示。所有可用的符号可以通过plt.plot文档或 Matplotlib 在线文档进行查阅。大多数的代码都是非常直观的，我们使用下面的例子可以展示那些最通用的符号：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rng = np.random.RandomState(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> marker <span class="keyword">in</span> [<span class="string">'o'</span>, <span class="string">'.'</span>, <span class="string">','</span>, <span class="string">'x'</span>, <span class="string">'+'</span>, <span class="string">'v'</span>, <span class="string">'^'</span>, <span class="string">'&lt;'</span>, <span class="string">'&gt;'</span>, <span class="string">'s'</span>, <span class="string">'d'</span>]:</span><br><span class="line">    plt.plot(rng.rand(<span class="number">5</span>), rng.rand(<span class="number">5</span>), marker,</span><br><span class="line">             label=<span class="string">"marker='&#123;0&#125;'"</span>.format(marker))</span><br><span class="line">plt.legend(numpoints=<span class="number">1</span>)</span><br><span class="line">plt.xlim(<span class="number">0</span>, <span class="number">1.8</span>);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224151.png" alt=""></p><p>而且这些符号代码可以和线条、颜色代码一起使用，这会在折线图的基础上绘制出散点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(x, y, <span class="string">'-ok'</span>);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224155.png" alt=""></p><p>plt.plot还有很多额外的关键字参数用来指定广泛的线条和点的属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(x, y, <span class="string">'-p'</span>, color=<span class="string">'gray'</span>,</span><br><span class="line">         markersize=<span class="number">15</span>, linewidth=<span class="number">4</span>,</span><br><span class="line">         markerfacecolor=<span class="string">'white'</span>,</span><br><span class="line">         markeredgecolor=<span class="string">'gray'</span>,</span><br><span class="line">         markeredgewidth=<span class="number">2</span>)</span><br><span class="line">plt.ylim(<span class="number">-1.2</span>, <span class="number">1.2</span>);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224159.png" alt=""></p><p>plt.plot函数的这种灵活性提供了很多的可视化选择。查阅plt.plot帮助文档获得完整的选项说明。</p><h2 id="使用plt-scatter绘制散点图"><a href="#使用plt-scatter绘制散点图" class="headerlink" title="使用plt.scatter绘制散点图"></a><strong>使用plt.scatter绘制散点图</strong></h2><p>第二种更强大的绘制散点图的方法是使用plt.scatter函数，它的使用方法和plt.plot类似：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.scatter(x, y, marker=<span class="string">'o'</span>);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224202.png" alt=""></p><p>plt.scatter和plt.plot的主要区别在于，plt.scatter可以针对每个点设置不同属性（大小、填充颜色、边缘颜色等），还可以通过数据集合对这些属性进行设置。</p><p>让我们通过一个随机值数据集绘制不同颜色和大小的散点图来说明。为了更好的查看重叠的结果，我们还使用了alpha关键字参数对点的透明度进行了调整：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rng = np.random.RandomState(<span class="number">0</span>)</span><br><span class="line">x = rng.randn(<span class="number">100</span>)</span><br><span class="line">y = rng.randn(<span class="number">100</span>)</span><br><span class="line">colors = rng.rand(<span class="number">100</span>)</span><br><span class="line">sizes = <span class="number">1000</span> * rng.rand(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">plt.scatter(x, y, c=colors, s=sizes, alpha=<span class="number">0.3</span>,</span><br><span class="line">            cmap=<span class="string">'viridis'</span>)</span><br><span class="line">plt.colorbar();  <span class="comment"># 显示颜色对比条</span></span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224207.png" alt=""></p><p>注意图表右边有一个颜色对比条（这里通过colormap()函数输出），图表中的点大小的单位是像素。使用这种方法，散点的颜色和大小都能用来展示数据信息，在希望展示多个维度数据集合的情况下很直观。</p><p>例如，当我们使用 Scikit-learn 中的鸢尾花数据集，里面的每个样本都是三种鸢尾花中的其中一种，并带有仔细测量的花瓣和花萼的尺寸数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line">iris = load_iris()</span><br><span class="line">features = iris.data.T</span><br><span class="line"></span><br><span class="line">plt.scatter(features[<span class="number">0</span>], features[<span class="number">1</span>], alpha=<span class="number">0.2</span>,</span><br><span class="line">            s=<span class="number">100</span>*features[<span class="number">3</span>], c=iris.target, cmap=<span class="string">'viridis'</span>)</span><br><span class="line">plt.xlabel(iris.feature_names[<span class="number">0</span>])</span><br><span class="line">plt.ylabel(iris.feature_names[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224211.png" alt=""></p><p>我们可以从上图中看出，可以通过散点图同时展示该数据集的四个不同维度：图中的(x, y)位置代表每个样本的花萼的长度和宽度，散点的大小代表每个样本的花瓣的宽度，而散点的颜色代表一种特定的鸢尾花类型。如上图的多种颜色和多种属性的散点图对于我们分析和展示数据集时都非常有帮助。</p><h2 id="plot-和-scatter-对比：性能提醒"><a href="#plot-和-scatter-对比：性能提醒" class="headerlink" title="plot 和 scatter 对比：性能提醒"></a><strong>plot 和 scatter 对比：性能提醒</strong></h2><p>除了上面说的plt.plot和plt.scatter对于每个散点不同属性的支持不同之外，还有别的因素影响对这两个函数的选择吗？对于小的数据集来说，两者并无差别，当数据集增长到几千个点时，plt.plot会明显比plt.scatter的性能要高。造成这个差异的原因是plt.scatter支持每个点使用不同的大小和颜色，因此渲染每个点时需要完成更多额外的工作。而plt.plot来说，每个点都是简单的复制另一个点产生，因此对于整个数据集来说，确定每个点的展示属性的工作仅需要进行一次即可。对于很大的数据集来说，这个差异会导致两者性能的巨大区别，因此，对于大数据集应该优先使用plt.plot函数。</p><h1 id="3-误差可视化"><a href="#3-误差可视化" class="headerlink" title="3.误差可视化"></a><strong>3.误差可视化</strong></h1><p>对于任何的科学测量来说，精确计算误差与精确报告测量值基本上同等重要。例如，设想我正在使用一些天文物理学观测值来估算哈勃常数，即本地观测的宇宙膨胀系数。我从一些文献中知道这个值大概是 71 (km/s)/Mpc，而我测量得到的值是 74 (km/s)/Mpc,。这两个值是否一致？在仅给定这些数据的情况下，这个问题的答案是，无法回答。</p><p>Mpc（百万秒差距）参见秒差距[4]</p><p>如果我们将信息增加一些，给出不确定性：最新的文献表示哈勃常数的值大约是 71  2.5 (km/s)/Mpc，我的测量值是 74  5 (km/s)/Mpc。这两个值是一致的吗？这就是一个可以准确回答的问题了。</p><p>在数据和结果的可视化中，有效地展示这些误差能使你的图表涵盖和提供更加完整的信息。</p><h2 id="基础误差条"><a href="#基础误差条" class="headerlink" title="基础误差条"></a><strong>基础误差条</strong></h2><p>调用一个 Matplotlib 函数就能创建一个基础的误差条：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.style.use(<span class="string">'seaborn-whitegrid'</span>)</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">10</span>, <span class="number">50</span>)</span><br><span class="line">dy = <span class="number">0.8</span></span><br><span class="line">y = np.sin(x) + dy * np.random.randn(<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line">plt.errorbar(x, y, yerr=dy, fmt=<span class="string">'.k'</span>);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224220.png" alt=""></p><p>这里的fmt参数是用来控制线条和点风格的代码，与plt.plot有着相同的语法，参见[简单的折线图]和[简单的散点图]。</p><p>除了上面的基本参数，errorbar函数还有很多参数可以用来精细调节图表输出。使用这些参数你可以很容易的个性化调整误差条的样式。作者发现通常将误差线条颜色调整为浅色会更加清晰，特别是在数据点比较密集的情况下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.errorbar(x, y, yerr=dy, fmt=<span class="string">'o'</span>, color=<span class="string">'black'</span>,</span><br><span class="line">             ecolor=<span class="string">'lightgray'</span>, elinewidth=<span class="number">3</span>, capsize=<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224225.png" alt=""></p><p>除了上面介绍的参数，你还可以指定水平方向的误差条（xerr），单边误差条和其他很多的参数。参阅plt.errorbar的帮助文档获得更多信息。</p><h2 id="连续误差"><a href="#连续误差" class="headerlink" title="连续误差"></a><strong>连续误差</strong></h2><p>在某些情况下可能需要对连续值展示误差条。虽然 Matplotlib 没有內建的函数能直接完成这个任务，但是你可以通过简单将plt.plot和plt.fill_between函数结合起来达到目标。</p><p>这里我们会采用简单的高斯过程回归方法，Scikit-Learn 提供了 API。这个方法非常适合在非参数化的函数中获得连续误差。我们在这里不会详细介绍高斯过程回归，仅仅聚焦在如何绘制连续误差本身：</p><p>译者注：新版的 sklearn 修改了高斯过程回归实现方法，下面代码做了相应修改。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.gaussian_process <span class="keyword">import</span> GaussianProcessRegressor</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义模型和一些符合模型的点</span></span><br><span class="line">model = <span class="keyword">lambda</span> x: x * np.sin(x)</span><br><span class="line">xdata = np.array([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>])</span><br><span class="line">ydata = model(xdata)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算高斯过程回归，使其符合 fit 数据点</span></span><br><span class="line">gp = GaussianProcessRegressor()</span><br><span class="line">gp.fit(xdata[:, np.newaxis], ydata)</span><br><span class="line"></span><br><span class="line">xfit = np.linspace(<span class="number">0</span>, <span class="number">10</span>, <span class="number">1000</span>)</span><br><span class="line">yfit, std = gp.predict(xfit[:, np.newaxis], return_std=<span class="literal">True</span>)</span><br><span class="line">dyfit = <span class="number">2</span> * std  <span class="comment"># 两倍sigma ~ 95% 确定区域</span></span><br></pre></td></tr></table></figure><p>我们现在有了xfit、yfit和dyfit，作为对我们数据的连续拟合值以及误差限。当然我们也可以像上面一样使用plt.errorbar绘制误差条，但是事实上我们不希望在图标上绘制 1000 个点的误差条。于是我们可以使用plt.fill_between函数在误差限区域内填充一道浅色的误差带来展示连续误差：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可视化结果</span></span><br><span class="line">plt.plot(xdata, ydata, <span class="string">'or'</span>)</span><br><span class="line">plt.plot(xfit, yfit, <span class="string">'-'</span>, color=<span class="string">'gray'</span>)</span><br><span class="line"></span><br><span class="line">plt.fill_between(xfit, yfit - dyfit, yfit + dyfit,</span><br><span class="line">                 color=<span class="string">'gray'</span>, alpha=<span class="number">0.2</span>)</span><br><span class="line">plt.xlim(<span class="number">0</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224230.png" alt=""></p><p>注意上面我们调用fill_between函数：我们传递了的参数包括 x 值，y 值的低限，然后是 y 值的高限，结果是图表中介于低限和高限之间的区域会被填充。</p><p>上图为我们提供了一个非常直观的高斯过程回归展示：在观测点的附近，模型会被限制在一个很小的区域内，反映了这些数据的误差比较小。在远离观测点的区域，模型开始发散，反映了这时的数据误差比较大。</p><p>如果需要获得plt.fill_between（以及类似的plt.fill函数）更多参数的信息，请查阅函数的帮助文档或 Matplotlib 在线文档。</p><h1 id="4-密度和轮廓图"><a href="#4-密度和轮廓图" class="headerlink" title="4.密度和轮廓图"></a><strong>4.密度和轮廓图</strong></h1><p>有些情况下，我们需要在二维图表中使用轮廓或颜色区域来展示三维的数据（可以设想等高线地图或温度分布图）。Matplotlib 提供了三个有用的函数来处理这项任务：plt.contour绘制轮廓图，plt.contourf来绘制填充区域颜色的图表以及plt.imshow来展示图像。本节会介绍几个使用它们的例子。当然我们还是首先从将需要使用的包导入 notebook 和初始化工作开始：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.style.use(<span class="string">'seaborn-white'</span>)</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><h2 id="三维可视化函数"><a href="#三维可视化函数" class="headerlink" title="三维可视化函数"></a><strong>三维可视化函数</strong></h2><p>我们首先使用一个简单的函数  绘制一个轮廓图来进行说明，我们用来作为数组广播运算的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> np.sin(x) ** <span class="number">10</span> + np.cos(<span class="number">10</span> + y * x) * np.cos(x)</span><br></pre></td></tr></table></figure><p>轮廓图可以使用plt.contour函数进行创建。它接收三个参数：x参数代表三维网格的平面横轴坐标，y参数代表三维网格的平面纵轴坐标，而z参数代表三维网格的高度坐标。最容易用来准备这种网格数据的是np.meshgrid函数，可以将两个一维的数组构造成一个二维的网格：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">5</span>, <span class="number">50</span>)</span><br><span class="line">y = np.linspace(<span class="number">0</span>, <span class="number">5</span>, <span class="number">40</span>)</span><br><span class="line"></span><br><span class="line">X, Y = np.meshgrid(x, y)</span><br><span class="line">Z = f(X, Y)</span><br></pre></td></tr></table></figure><p>下面我们可以绘制标准的轮廓线图表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.contour(X, Y, Z, colors=<span class="string">'black'</span>);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224235.png" alt=""></p><p>图中值得注意的是，当使用单色绘制轮廓图时，虚线代表的是负数的数值，而实线代表的是正数。而轮廓线可以通过指定cmap参数来设置线条的色图。下例中展示了使用色图且绘制了更多的轮廓线的例子，会在整个数据范围区域内等距分布有 20 条轮廓线：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.contour(X, Y, Z, <span class="number">20</span>, cmap=<span class="string">'RdGy'</span>);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224238.png" alt=""></p><p>上例中我们选择了RdGy（Red-Gray的缩写）色图，这对于聚集的数据来说是一个不错的选择。Matplotlib 有大量的颜色图可供使用，你可以通过在 IPython 中对plt.cm模块使用 TAB 自动补全方法就可以看到：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.cm.&lt;TAB&gt;</span><br></pre></td></tr></table></figure><p>上面的图看起来比第一幅图好多了，但是线条之间的空隙还是有点让人混淆。我们可以将上面的图改为填充轮廓图来解决这个问题，使用plt.contourf()函数（注意函数名最后有个 f，代表填充 fill），这个函数的语法基本上与plt.contour()保持一致。</p><p>并且我们加上了plt.colorbar()函数，这个函数会在图表边上创建一个颜色图例用以展示颜色所表示的数值区域：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.contourf(X, Y, Z, <span class="number">20</span>, cmap=<span class="string">'RdGy'</span>)</span><br><span class="line">plt.colorbar();</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224241.png" alt=""></p><p>有了图例，很容易可以看出黑色区域代表着“峰”，而红色区域代表这“谷”。</p><p>上图有一个缺点，那就是图中颜色的阶梯是离散的而不是连续的，这通常不是我们想要的。我们可以通过设置很高的轮廓线数量来改善，但是这会导致绘制图表的性能降低：Matplotlib 必须在每个颜色阶梯上绘制一条新的轮廓多边形。更好的办法是使用plt.imshow()函数，它会将一个二维的网格图表转换为一张图像。</p><p>下面的例子展示了该方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plt.imshow(Z, extent=[<span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">5</span>], origin=<span class="string">'lower'</span>,</span><br><span class="line">           cmap=<span class="string">'RdGy'</span>)</span><br><span class="line">plt.colorbar()</span><br><span class="line">plt.axis(aspect=<span class="string">'image'</span>);</span><br></pre></td></tr></table></figure><p>C:\Users\gdc\Anaconda3\lib\site-packages\ipykernel_launcher.py:4: MatplotlibDeprecationWarning: Passing unsupported keyword arguments to axis() will raise a TypeError in 3.3.<br>  after removing the cwd from sys.path.</p><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224241.png" alt=""></p><p>然而，在使用imshow()的时候也有一些坑：</p><ul><li>plt.imshow()不接受 x 和 y 网格值作为参数，因此你需要手动指定extent参数[xmin, xmax, ymin, ymax]来设置图表的数据范围。</li><li>plt.imshow()使用的是默认的图像坐标，即左上角坐标点是原点，而不是通常图表的左下角坐标点。这可以通过设置origin参数来设置。</li><li>plt.imshow()会自动根据输入数据调整坐标轴的比例；这可以通过参数来设置，例如，plt.axis(aspect=’image’)能让 x 和 y 轴的单位一致。</li></ul><p>最后，有时可能需要将轮廓图和图像结合起来。例如，下例中我们使用了半透明的背景图像（通过alpha参数设置透明度），然后在背景图层之上绘制了轮廓图，并带有每个轮廓的数值标签（使用plt.clabel()函数绘制标签）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">contours = plt.contour(X, Y, Z, <span class="number">3</span>, colors=<span class="string">'black'</span>)</span><br><span class="line">plt.clabel(contours, inline=<span class="literal">True</span>, fontsize=<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">plt.imshow(Z, extent=[<span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">5</span>], origin=<span class="string">'lower'</span>,</span><br><span class="line">           cmap=<span class="string">'RdGy'</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line">plt.colorbar();</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224249.png" alt=""></p><p>通过组合使用plt.contour、plt.contourf和plt.imshow这三个函数，基本可以满足我们绘制所有这种在二维图标上的三维数据的需求。需要了解更多函数的参数信息，参考它们的文档字符串。如果你对于使用三维图表展示这种数据感兴趣，参见[在 matplotlib 中创建三维图表]。</p><h1 id="5-直方图，分桶和密度"><a href="#5-直方图，分桶和密度" class="headerlink" title="5.直方图，分桶和密度"></a><strong>5.直方图，分桶和密度</strong></h1><p>一个简单的直方图可以是我们开始理解数据集的第一步。前面我们看到了 Matplotlib 的直方图函数，我们可以用一行代码绘制基础的直方图，当然首先需要将需要用的包导入 notebook：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.style.use(<span class="string">'seaborn-white'</span>)</span><br><span class="line"></span><br><span class="line">data = np.random.randn(<span class="number">1000</span>)</span><br><span class="line">plt.hist(data);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224252.png" alt=""></p><p>hist()函数有很多的参数可以用来调整运算和展示；下面又一个更加个性化的直方图展示：</p><p>译者注：normed 参数已经过时，此处对代码进行了相应修改，使用了替代的 density 参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plt.hist(data, bins=<span class="number">30</span>, density=<span class="literal">True</span>, alpha=<span class="number">0.5</span>,</span><br><span class="line">         histtype=<span class="string">'stepfilled'</span>, color=<span class="string">'steelblue'</span>,</span><br><span class="line">         edgecolor=<span class="string">'none'</span>);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224255.png" alt=""></p><p>plt.hist文档中有更多关于个性化参数的信息。作者发现联合使用histtype=’stepfilled’和alpha参数设置透明度在对不同分布的数据集进行比较展示时很有用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x1 = np.random.normal(<span class="number">0</span>, <span class="number">0.8</span>, <span class="number">1000</span>)</span><br><span class="line">x2 = np.random.normal(<span class="number">-2</span>, <span class="number">1</span>, <span class="number">1000</span>)</span><br><span class="line">x3 = np.random.normal(<span class="number">3</span>, <span class="number">2</span>, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">kwargs = dict(histtype=<span class="string">'stepfilled'</span>, alpha=<span class="number">0.3</span>, density=<span class="literal">True</span>, bins=<span class="number">40</span>)</span><br><span class="line"></span><br><span class="line">plt.hist(x1, **kwargs)</span><br><span class="line">plt.hist(x2, **kwargs)</span><br><span class="line">plt.hist(x3, **kwargs);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224258.png" alt=""></p><p>如果你只是需要计算直方图的数值（即每个桶的数据点数量）而不是展示图像，np.histogram()函数可以完成这个目标：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">counts, bin_edges = np.histogram(data, bins=<span class="number">5</span>)</span><br><span class="line">print(counts)</span><br></pre></td></tr></table></figure><p>[ 49 273 471 183  24]</p><h2 id="二维直方图和分桶"><a href="#二维直方图和分桶" class="headerlink" title="二维直方图和分桶"></a><strong>二维直方图和分桶</strong></h2><p>正如前面我们可以在一维上使用数值对应的直线划分桶一样，我们也可以在二维上使用数据对应的点来划分桶。本节我们介绍几种实现的方法。首先定义数据集，从多元高斯分布中获得x和y数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mean = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">cov = [[<span class="number">1</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">2</span>]]</span><br><span class="line">x, y = np.random.multivariate_normal(mean, cov, <span class="number">10000</span>).T</span><br></pre></td></tr></table></figure><h3 id="plt-hist2d：二维直方图"><a href="#plt-hist2d：二维直方图" class="headerlink" title="plt.hist2d：二维直方图"></a><strong>plt.hist2d：二维直方图</strong></h3><p>绘制二维直方图最直接的方法是使用 Matplotlib 的plt.hist2d函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plt.hist2d(x, y, bins=<span class="number">30</span>, cmap=<span class="string">'Blues'</span>)</span><br><span class="line">cb = plt.colorbar()</span><br><span class="line">cb.set_label(<span class="string">'counts in bin'</span>)</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224304.png" alt=""></p><p>类似plt.hist，plt.hist2d有许多额外的参数来调整分桶计算和图表展示，可以通过文档了解更多信息。而且，plt.hist有np.histogram，plt.hist2d也有其对应的函数np.histogram2d。如下例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">counts, xedges, yedges = np.histogram2d(x, y, bins=<span class="number">30</span>)</span><br></pre></td></tr></table></figure><p>如果要获得更高维度的分桶结果，参见np.histogramd函数文档。</p><h3 id="plt-hexbin：六角形分桶"><a href="#plt-hexbin：六角形分桶" class="headerlink" title="plt.hexbin：六角形分桶"></a><strong>plt.hexbin：六角形分桶</strong></h3><p>刚才的二维分桶是沿着坐标轴将每个桶分为正方形。另一个很自然的分桶形状就是正六边形。对于这个需求，Matplotlib 提供了plt.hexbin函数，它也是在二维平面上分桶展示，不过每个桶（即图表上的每个数据格）将会是六边形：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.hexbin(x, y, gridsize=<span class="number">30</span>, cmap=<span class="string">'Blues'</span>)</span><br><span class="line">cb = plt.colorbar(label=<span class="string">'count in bin'</span>)</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224308.png" alt=""></p><p>plt.hexbin有许多有趣的参数，包括能对每个点设置权重和将每个桶的输出数据结果改为任意的 NumPy 聚合结果（带权重的平均值，带权重的标准差等）。</p><h3 id="核密度估计"><a href="#核密度估计" class="headerlink" title="核密度估计"></a><strong>核密度估计</strong></h3><p>另外一个常用来统计多维数据密度的工具是核密度估计（KDE）。目前我们只需要知道 KDE 被认为是一种可以用来填补数据的空隙并补充上平滑变化数据的方法就足够了。快速和简单的 KDE 算法已经在scipy.stats模块中有了成熟的实现。下面我们就一个简单的例子来说明如何使用 KDE 和绘制相应的二维直方图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> gaussian_kde</span><br><span class="line"></span><br><span class="line"><span class="comment"># 产生和处理数据，初始化KDE</span></span><br><span class="line">data = np.vstack([x, y])</span><br><span class="line">kde = gaussian_kde(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在通用的网格中计算得到Z的值</span></span><br><span class="line">xgrid = np.linspace(<span class="number">-3.5</span>, <span class="number">3.5</span>, <span class="number">40</span>)</span><br><span class="line">ygrid = np.linspace(<span class="number">-6</span>, <span class="number">6</span>, <span class="number">40</span>)</span><br><span class="line">Xgrid, Ygrid = np.meshgrid(xgrid, ygrid)</span><br><span class="line">Z = kde.evaluate(np.vstack([Xgrid.ravel(), Ygrid.ravel()]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将图表绘制成一张图像</span></span><br><span class="line">plt.imshow(Z.reshape(Xgrid.shape),</span><br><span class="line">           origin=<span class="string">'lower'</span>, aspect=<span class="string">'auto'</span>,</span><br><span class="line">           extent=[<span class="number">-3.5</span>, <span class="number">3.5</span>, <span class="number">-6</span>, <span class="number">6</span>],</span><br><span class="line">           cmap=<span class="string">'Blues'</span>)</span><br><span class="line">cb = plt.colorbar()</span><br><span class="line">cb.set_label(<span class="string">"density"</span>)</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224313.png" alt=""></p><p>KDE 有着光滑的长度，可以在细节和光滑度中有效的进行调节（一个例子是方差偏差权衡）。这方面有大量的文献介绍：高斯核密度估计gaussian_kde使用了经验法则来寻找输入数据附近的优化光滑长度值。</p><p>其他的 KDE 实现也可以在 SciPy 中找到，每一种都有它的优点和缺点；参见sklearn.neighbors.KernelDensity和statsmodels.nonparametric.kernel_density.KDEMultivariate。要绘制基于 KDE 进行可视化的图表，Matplotlib 写出的代码会比较冗长。</p><h1 id="6-自定义图标图例"><a href="#6-自定义图标图例" class="headerlink" title="6.自定义图标图例"></a><strong>6.自定义图标图例</strong></h1><p>图例可以为可视化赋予实际含义，为不同的图标元素附上明确说明。我们前面看到了一些简单的图例创建例子；本小节中我们来介绍一下在 Matplotlib 中自定义图例的位置和进行美化的方法。</p><p>可以使用plt.legend()函数来创建最简单的图例，这个函数能自动创建任何带有标签属性的图表元素的图例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.style.use(<span class="string">'classic'</span>)</span><br><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">10</span>, <span class="number">1000</span>)</span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line">ax.plot(x, np.sin(x), <span class="string">'-b'</span>, label=<span class="string">'Sine'</span>)</span><br><span class="line">ax.plot(x, np.cos(x), <span class="string">'--r'</span>, label=<span class="string">'Cosine'</span>)</span><br><span class="line">ax.axis(<span class="string">'equal'</span>)</span><br><span class="line">leg = ax.legend();</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224317.png" alt=""></p><p>但除此之外还有很多能自定义图例的方法。例如，我们可以指定图例位置并且去除边框：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ax.legend(loc=<span class="string">'upper left'</span>, frameon=<span class="literal">False</span>)</span><br><span class="line">fig</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224322.png" alt=""></p><p>我们可以使用ncol属性设置图例中每行的列数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ax.legend(frameon=<span class="literal">False</span>, loc=<span class="string">'lower center'</span>, ncol=<span class="number">2</span>)</span><br><span class="line">fig</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224325.png" alt=""></p><p>还可以使用圆角方框（fancybox）或者增加阴影，设置方框的透明度（alpha 值）或修改文字的边距：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ax.legend(fancybox=<span class="literal">True</span>, framealpha=<span class="number">1</span>, shadow=<span class="literal">True</span>, borderpad=<span class="number">1</span>)</span><br><span class="line">fig</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224328.png" alt=""></p><p>要获取更多 legend 函数的可用选项信息，请参考plt.legend的文档字符串。</p><h2 id="选择设置图例的元素"><a href="#选择设置图例的元素" class="headerlink" title="选择设置图例的元素"></a><strong>选择设置图例的元素</strong></h2><p>正如我们前面例子所示，绘制的图例默认包括所有带标签的元素。如果这不是想要的效果，我们可以调整哪些元素和标签会出现在图例当中，这可以通过设置 plot 函数或方法返回的对象实现。plt.plot函数能够同时产生多条折线，然后将这些线条的实例列表返回。将其中的部分实例传递到plt.legend()函数就能设置哪些线条会出现在图例中，再通过一个标签的列表指定图例的名称：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">y = np.sin(x[:, np.newaxis] + np.pi * np.arange(<span class="number">0</span>, <span class="number">2</span>, <span class="number">0.5</span>))</span><br><span class="line">lines = plt.plot(x, y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># lines是一个线条实例的列表</span></span><br><span class="line">plt.legend(lines[:<span class="number">2</span>], [<span class="string">'first'</span>, <span class="string">'second'</span>]);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224332.png" alt=""></p><p>作者更加倾向于使用第一种方式，因为更加清晰。通过将标签应用在图表元素上，然后绘制到图例中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(x, y[:, <span class="number">0</span>], label=<span class="string">'first'</span>)</span><br><span class="line">plt.plot(x, y[:, <span class="number">1</span>], label=<span class="string">'second'</span>)</span><br><span class="line">plt.plot(x, y[:, <span class="number">2</span>:])</span><br><span class="line">plt.legend(framealpha=<span class="number">1</span>, frameon=<span class="literal">True</span>);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224336.png" alt=""></p><p>请注意默认情况下，legend 会忽略所有不带标签的元素。</p><h2 id="散点大小的图例"><a href="#散点大小的图例" class="headerlink" title="散点大小的图例"></a><strong>散点大小的图例</strong></h2><p>某些情况下默认的图例不足以满足特定的可视化需求。例如，你在使用散点的大小来标记数据的某个特征，然后希望创建一个相应的图例。下面的例子是加州城市人口的散点图，我们使用散点的大小表现该城市的面积，散点的颜色来表现城市的人口数量（自然对数值）。我们希望使用一个图例来指明散点尺寸的比例，同时用一个颜色条来说明人口数量，我们可以通过自定义绘制一些标签数据来实现尺寸图例：</p><p>译者注：新版 Matplotlib 已经取消 aspect 参数，此处改为使用新的’scaled’参数调用 axis 函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">cities = pd.read_csv(<span class="string">r'D:\python\Github学习材料\Python数据科学手册\data\california_cities.csv'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取我们感兴趣的数据</span></span><br><span class="line">lat, lon = cities[<span class="string">'latd'</span>], cities[<span class="string">'longd'</span>]</span><br><span class="line">population, area = cities[<span class="string">'population_total'</span>], cities[<span class="string">'area_total_km2'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制散点图，使用尺寸代表面积，颜色代表人口，不带标签</span></span><br><span class="line">plt.scatter(lon, lat, label=<span class="literal">None</span>,</span><br><span class="line">            c=np.log10(population), cmap=<span class="string">'viridis'</span>,</span><br><span class="line">            s=area, linewidth=<span class="number">0</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line">plt.axis(<span class="string">'scaled'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'longitude'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'latitude'</span>)</span><br><span class="line">plt.colorbar(label=<span class="string">'log$_&#123;10&#125;$(population)'</span>)</span><br><span class="line">plt.clim(<span class="number">3</span>, <span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面我们创建图例：</span></span><br><span class="line"><span class="comment"># 使用空列表绘制图例中的散点，使用不同面积和标签，带透明度</span></span><br><span class="line"><span class="keyword">for</span> area <span class="keyword">in</span> [<span class="number">100</span>, <span class="number">300</span>, <span class="number">500</span>]:</span><br><span class="line">    plt.scatter([], [], c=<span class="string">'k'</span>, alpha=<span class="number">0.3</span>, s=area,</span><br><span class="line">                label=str(area) + <span class="string">' km$^2$'</span>)</span><br><span class="line">plt.legend(scatterpoints=<span class="number">1</span>, frameon=<span class="literal">False</span>, labelspacing=<span class="number">1</span>, title=<span class="string">'City Area'</span>)</span><br><span class="line"></span><br><span class="line">plt.title(<span class="string">'California Cities: Area and Population'</span>);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224339.png" alt=""></p><p>之前的图例都关联着图表上的一些对象，因此如果我们需要展示图例的话我们首先需要绘制图表元素。在上例中，我们需要的图例对象（灰色圆圈）不在图表上，因此我们采用绘制空列表的方式将它们仿造在图表上（实际上图上没有点），但是还是需要注意，只有那些带标签的元素才会出现在图例中。</p><p>通过绘制空列表，我们创建了三个带标签的对象，然后就可以出现在图例当中，这个图例就能表示出有关城市面积的相关信息。这个策略在很多复杂可视化图表构建过程中都被用到。</p><p>最后我们注意到这个图表实际上是一个地理位置图表，如果我们能在上面绘制州界线或其他地图相关的元素的话，会更加清晰。Matplotlib 提供了一个 Basemap 额外工具集来实现这个目标。</p><h2 id="多重图例"><a href="#多重图例" class="headerlink" title="多重图例"></a><strong>多重图例</strong></h2><p>有时候我们可能需要在同一个图表维度中设计多个图例。不幸的是，Matplotlib 并没有提供很简单的方式实现：通过标准的legend接口，只能在整张图表上创建一个图例。如果你试图使用plt.legend()或ax.legend()创建第二个图例，那么第二条语句创建的图例会覆盖第一条语句创建的。我们只能通过从底层开始来创建一个新的图例 artist 这种方法来解决这个问题，然后使用ax.add_artist()的底层方法手动将第二个作者加到图表上：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots()</span><br><span class="line"></span><br><span class="line">lines = []</span><br><span class="line">styles = [<span class="string">'-'</span>, <span class="string">'--'</span>, <span class="string">'-.'</span>, <span class="string">':'</span>]</span><br><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">10</span>, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">    lines += ax.plot(x, np.sin(x - i * np.pi / <span class="number">2</span>),</span><br><span class="line">                     styles[i], color=<span class="string">'black'</span>)</span><br><span class="line">ax.axis(<span class="string">'equal'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定第一个图例的线条和标签</span></span><br><span class="line">ax.legend(lines[:<span class="number">2</span>], [<span class="string">'line A'</span>, <span class="string">'line B'</span>],</span><br><span class="line">          loc=<span class="string">'upper right'</span>, frameon=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 手动创建第二个图例，并将作者添加到图表中</span></span><br><span class="line"><span class="keyword">from</span> matplotlib.legend <span class="keyword">import</span> Legend</span><br><span class="line">leg = Legend(ax, lines[<span class="number">2</span>:], [<span class="string">'line C'</span>, <span class="string">'line D'</span>],</span><br><span class="line">             loc=<span class="string">'lower right'</span>, frameon=<span class="literal">False</span>)</span><br><span class="line">ax.add_artist(leg);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224343.png" alt=""></p><p>上例展示了用来组成任何 Matplotlib 图表的底层 artist 对象的简单说明。如果你去查看ax.legend()的源代码（你可以通过 IPython 的ax.legend帮助工具做到），你可以看到这个方法包含了用来构建合适Legend的 artist 对象的逻辑，构建的对象被保存在legend_属性当中，当绘制时被添加到图表上进行展示。</p><h1 id="7-个性化颜色条"><a href="#7-个性化颜色条" class="headerlink" title="7.个性化颜色条"></a><strong>7.个性化颜色条</strong></h1><p>图例可以将离散的点标示为离散的标签。对于建立在不同颜色之上的连续的值（点线面）来说，标注了的颜色条是非常方便的工具。Matplotlib 的颜色条是独立于图表之外的一个类似于比色卡的图形，用来展示图表中不同颜色的数值含义。因为本书是使用黑白打印的，本节内容中的所有带色彩的图都可以在(<a href="https://github.com/wangyingsm/Python-Data-Science-Handbook)中找到。我们还是首先导入本节需要的包和模块：" target="_blank" rel="noopener">https://github.com/wangyingsm/Python-Data-Science-Handbook)中找到。我们还是首先导入本节需要的包和模块：</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.style.use(<span class="string">'classic'</span>)</span><br><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><p>通过plt.colorbar函数可以创建最简单的颜色条，在本节中我们会多次看到：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">10</span>, <span class="number">1000</span>)</span><br><span class="line">I = np.sin(x) * np.cos(x[:, np.newaxis])</span><br><span class="line"></span><br><span class="line">plt.imshow(I)</span><br><span class="line">plt.colorbar();</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224347.png" alt=""></p><p>我们下面来讨论如何个性化颜色条以及在不同的场合高效的使用它们。</p><h2 id="自定义颜色条"><a href="#自定义颜色条" class="headerlink" title="自定义颜色条"></a><strong>自定义颜色条</strong></h2><p>颜色条可以通过cmap参数指定使用的色谱系统（或叫色图）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.imshow(I, cmap=<span class="string">'gray'</span>);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224352.png" alt=""></p><p>所有可用的色图都可以在plt.cm模块中找到；在 IPython 中使用 Tab 自动补全功能能列出所有的色图列表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.cm.&lt;TAB&gt;</span><br></pre></td></tr></table></figure><p>但是知道在哪里选择色图只是第一步，更重要的是在各种选项中选出合适的色图。这个选择比你预料的要微妙的多。</p><h3 id="选择色图"><a href="#选择色图" class="headerlink" title="选择色图"></a><strong>选择色图</strong></h3><p>在可视化方案中选择颜色完整的介绍说明超出了本书的范围，如果你对这个课题和相关内容有兴趣，可以参考文章<a href="http://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1003833" target="_blank" rel="noopener">“绘制更漂亮图表的 10 个简单规则”</a>。Matplotlib 的在线文档也有一章关于色图选择的有趣讨论[5]。</p><p>通常来说，你应该注意以下三种不同类型的色图：</p><ul><li>序列色图：这类型的色谱只包括一个连续序列的色系（例如binary或viridis）。</li><li>分化色图：这类型的色谱包括两种独立的色系，这两种颜色有着非常大的对比度（例如RdBu或PuOr）。</li><li>定性色图：这类型的色图混合了非特定连续序列的颜色（例如rainbow或jet）。</li></ul><p>jet色图，在 Matplotlib 2.0 版本之前都是默认的色图，是定性色图的一个例子。jet作为默认色图的位置其实有点尴尬，因为定性图通常都不是对定量数据进行展示的好选择。原因是定性图通常都不能在范围增加时提供亮度的均匀增长。</p><p>我们可以通过将jet颜色条转换为黑白来看到这点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.colors <span class="keyword">import</span> LinearSegmentedColormap</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grayscale_cmap</span><span class="params">(cmap)</span>:</span></span><br><span class="line">    <span class="string">"""返回给定色图的灰度版本"""</span></span><br><span class="line">    cmap = plt.cm.get_cmap(cmap) <span class="comment"># 使用名称获取色图对象</span></span><br><span class="line">    colors = cmap(np.arange(cmap.N)) <span class="comment"># 将色图对象转为RGBA矩阵，形状为N×4</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将RGBA颜色转换为灰度</span></span><br><span class="line">    <span class="comment"># 参考 http://alienryderflex.com/hsp.html</span></span><br><span class="line">    RGB_weight = [<span class="number">0.299</span>, <span class="number">0.587</span>, <span class="number">0.114</span>] <span class="comment"># RGB三色的权重值</span></span><br><span class="line">    luminance = np.sqrt(np.dot(colors[:, :<span class="number">3</span>] ** <span class="number">2</span>, RGB_weight)) <span class="comment"># RGB平方值和权重的点积开平方根</span></span><br><span class="line">    colors[:, :<span class="number">3</span>] = luminance[:, np.newaxis] <span class="comment"># 得到灰度值矩阵</span></span><br><span class="line">    <span class="comment"># 返回相应的灰度值色图</span></span><br><span class="line">    <span class="keyword">return</span> LinearSegmentedColormap.from_list(cmap.name + <span class="string">"_gray"</span>, colors, cmap.N)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">view_colormap</span><span class="params">(cmap)</span>:</span></span><br><span class="line">    <span class="string">"""将色图对应的灰度版本绘制出来"""</span></span><br><span class="line">    cmap = plt.cm.get_cmap(cmap)</span><br><span class="line">    colors = cmap(np.arange(cmap.N))</span><br><span class="line"></span><br><span class="line">    cmap = grayscale_cmap(cmap)</span><br><span class="line">    grayscale = cmap(np.arange(cmap.N))</span><br><span class="line"></span><br><span class="line">    fig, ax = plt.subplots(<span class="number">2</span>, figsize=(<span class="number">6</span>, <span class="number">2</span>),</span><br><span class="line">                           subplot_kw=dict(xticks=[], yticks=[]))</span><br><span class="line">    ax[<span class="number">0</span>].imshow([colors], extent=[<span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">    ax[<span class="number">1</span>].imshow([grayscale], extent=[<span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">view_colormap(<span class="string">'jet'</span>)</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224358.png" alt=""></p><p>注意一下上面的灰度图中亮条纹的位置。即使在上述彩色图中，也出现了这种不规则的亮条纹，这会导致眼睛被区域中亮条纹所吸引，这很可能造成阅读者被不重要的数据集部分干扰了。更好的选择是使用类似viridis这样的色图（Matplotlib 2.0 后默认色图），它们被设计为有着均匀的亮度变化。因此它们无论是在彩色图中还是在灰度图中都有着同样的亮度变化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view_colormap(<span class="string">'viridis'</span>)</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224401.png" alt=""></p><p>如果你更喜欢彩虹方案，另一个好的选择是使用cubehelix色图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view_colormap(<span class="string">'cubehelix'</span>)</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224404.png" alt=""></p><p>对于其他的情况，例如某种正负分布的数据集，双色颜色条如RdBu（Red-Blue）会很常用。然而正如你从下面例子看到的，如果将双色颜色条转化为灰度的话，正负或两级的信息就会丢失：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view_colormap(<span class="string">'RdBu'</span>)</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224407.png" alt=""></p><p>后面我们会看到更多使用这些色图的例子。</p><p>Matplotlib 中有大量可用的色图；要看到它们的列表，你可以使用 IPython 来探索plt.cm模块。要在 Python 中更加正规的使用颜色，你可以查看 Seaborn 库的工具和文档。</p><h3 id="颜色限制和扩展"><a href="#颜色限制和扩展" class="headerlink" title="颜色限制和扩展"></a><strong>颜色限制和扩展</strong></h3><p>Matplotlib 允许你对颜色条进行大量的自定义。颜色条本身就是一个plt.Axes对象，因此所有轴和刻度定制的技巧都可以应用在上面。颜色条也有着一些有趣的自定义行为：例如，我们可以缩小颜色的范围并且通过设置extend参数将超出范围之外的数值展示为顶部和底部的三角箭头形状。这对于展示一些受到噪声干扰的数据时非常方便：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在I数组中人为生成不超过1%的噪声</span></span><br><span class="line">speckles = (np.random.random(I.shape) &lt; <span class="number">0.01</span>)</span><br><span class="line">I[speckles] = np.random.normal(<span class="number">0</span>, <span class="number">3</span>, np.count_nonzero(speckles))</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">3.5</span>))</span><br><span class="line"><span class="comment"># 不考虑去除噪声时的颜色分布</span></span><br><span class="line">plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">plt.imshow(I, cmap=<span class="string">'RdBu'</span>)</span><br><span class="line">plt.colorbar()</span><br><span class="line"><span class="comment"># 设置去除噪声时的颜色分布</span></span><br><span class="line">plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">plt.imshow(I, cmap=<span class="string">'RdBu'</span>)</span><br><span class="line">plt.colorbar(extend=<span class="string">'both'</span>)</span><br><span class="line">plt.clim(<span class="number">-1</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224412.png" alt=""></p><p>注意到在左边的图表中，默认的颜色阈值是包括了噪声的，因此整体的条纹形状都被噪声数据冲刷淡化了。而右边的图表，我们手动设置了颜色的阈值，并在绘制颜色条是加上了extend参数来表示超出阈值的数据。对于我们的数据来说，右图比左图要好的多。</p><h3 id="离散颜色条"><a href="#离散颜色条" class="headerlink" title="离散颜色条"></a><strong>离散颜色条</strong></h3><p>色图默认是连续的，但是在某些情况下你可能需要展示离散值。最简单的方法是使用plt.cm.get_cmap()函数，在传递某个色图名称的同时，还额外传递一个颜色分桶的数量值参数给该函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plt.imshow(I, cmap=plt.cm.get_cmap(<span class="string">'Blues'</span>, <span class="number">6</span>))</span><br><span class="line">plt.colorbar()</span><br><span class="line">plt.clim(<span class="number">-1</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224415.png" alt=""></p><p>离散色图的使用方式和其他色图没有任何区别。</p><h2 id="例子：手写数字"><a href="#例子：手写数字" class="headerlink" title="例子：手写数字"></a><strong>例子：手写数字</strong></h2><p>最后我们来看一个很有实用价值的例子，让我们实现对一些手写数字图像数据的可视化分析。这个数据包含在 Sciki-Learn 中，以供包含有将近 2,000 张  大小的不同笔迹的手写数字缩略图。</p><p>首先，我们下载这个数据集，然后使用plt.imshow()将其中部分数据展示出来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读取数字0-5的手写图像，然后使用Matplotlib展示头64张缩略图</span></span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_digits</span><br><span class="line">digits = load_digits(n_class=<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(<span class="number">8</span>, <span class="number">8</span>, figsize=(<span class="number">6</span>, <span class="number">6</span>))</span><br><span class="line"><span class="keyword">for</span> i, axi <span class="keyword">in</span> enumerate(ax.flat):</span><br><span class="line">    axi.imshow(digits.images[i], cmap=<span class="string">'binary'</span>)</span><br><span class="line">    axi.set(xticks=[], yticks=[])</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224419.png" alt=""></p><p>因为每个数字都是使用 64 个像素点渲染出来的，我们可以认为每个数字是一个 64 维空间中的点：每个维度代表这其中一个像素的灰度值。但是要在图表中将这么高维度空间的联系可视化出来是非常困难的。有一种做法是使用降维技术，比方说使用流形学习来减少数据的维度然而不会丢失数据中有效的信息。</p><p>我们来看一下将这些手写数字图像数据映射到二维流形学习当中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用Isomap将手写数字图像映射到二维流形学习中</span></span><br><span class="line"><span class="keyword">from</span> sklearn.manifold <span class="keyword">import</span> Isomap</span><br><span class="line">iso = Isomap(n_components=<span class="number">2</span>)</span><br><span class="line">projection = iso.fit_transform(digits.data)</span><br></pre></td></tr></table></figure><p>我们使用离散颜色条来展示结果，设置ticks和clim来进一步美化结果的颜色条：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 绘制图表结果</span></span><br><span class="line">plt.scatter(projection[:, <span class="number">0</span>], projection[:, <span class="number">1</span>], lw=<span class="number">0.1</span>,</span><br><span class="line">            c=digits.target, cmap=plt.cm.get_cmap(<span class="string">'cubehelix'</span>, <span class="number">6</span>))</span><br><span class="line">plt.colorbar(ticks=range(<span class="number">6</span>), label=<span class="string">'digit value'</span>)</span><br><span class="line">plt.clim(<span class="number">-0.5</span>, <span class="number">5.5</span>)</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224423.png" alt=""></p><p>我们从流形学习中的映射中可以观察到一些有趣现象：例如，图表中 5 和 3 有一些重叠的部分，这表示一些手写体中 5 和 3 是比较难以辨别的，因此对于自动识别算法来说这是比较容易混淆的部分。而 0 和 1，它们在图表中距离很远，这表示两者比较容易辨别，不太可能造成混淆。这个图表分析与我们的直觉一致，因为 5 和 3 显然比 0 和 1 看起来更加接近。</p><h1 id="8-多个子图表"><a href="#8-多个子图表" class="headerlink" title="8.多个子图表"></a><strong>8.多个子图表</strong></h1><p>在一些情况中，如果能将不同的数据图表并列展示，对于我们进行数据分析和比较会很有帮助。Matplotlib 提供了子图表的概念来实现这一点：单个图表中可以包括一组小的 axes 用来展示多个子图表。这些子图表可以是插图，网格状分布或其他更复杂的布局。在本节中我们会介绍 Matplotlib 中用来构建子图表的四个函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.style.use(<span class="string">'seaborn-white'</span>)</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><h2 id="plt-axes：手动构建子图表"><a href="#plt-axes：手动构建子图表" class="headerlink" title="plt.axes：手动构建子图表"></a><strong>plt.axes：手动构建子图表</strong></h2><p>构建 axes 作为子图表的最基础方法就是使用plt.axes函数。正如我们前面已经看到，默认情况下，这个函数够创建一个标准的 axes 对象填满整个图表区域。plt.axes函数也可以接收一个可选的列表参数用来指定在 axes 在整个图表中的坐标点位置。列表中有四个数值分别为[left, bottom, width, height]（取值都是 0-1），代表着子图表的左边、底部、宽度、高度在整个图表中左边、底部、宽度、高度所占的比例值。</p><p>例如，我们可以在距离左边和底部 65%的位置，以插图的形式放置一个宽度和高度都是 20%子图表，上述数值应该为[0.65, 0.65, 0.2, 0.2]：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ax1 = plt.axes()  <span class="comment"># 标准图表</span></span><br><span class="line">ax2 = plt.axes([<span class="number">0.65</span>, <span class="number">0.65</span>, <span class="number">0.2</span>, <span class="number">0.2</span>]) <span class="comment">#子图表</span></span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224427.png" alt=""></p><p>与上述等价的面向对象接口的语法是fig.add_axes()。我们使用这个方法来创建两个垂直堆叠的子图表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fig = plt.figure() <span class="comment"># 获得figure对象</span></span><br><span class="line">ax1 = fig.add_axes([<span class="number">0.1</span>, <span class="number">0.5</span>, <span class="number">0.8</span>, <span class="number">0.4</span>],</span><br><span class="line">                   xticklabels=[], ylim=(<span class="number">-1.2</span>, <span class="number">1.2</span>)) <span class="comment"># 左边10% 底部50% 宽80% 高40%</span></span><br><span class="line">ax2 = fig.add_axes([<span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.8</span>, <span class="number">0.4</span>],</span><br><span class="line">                   ylim=(<span class="number">-1.2</span>, <span class="number">1.2</span>)) <span class="comment"># 左边10% 底部10% 宽80% 高40%</span></span><br><span class="line"></span><br><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">ax1.plot(np.sin(x))</span><br><span class="line">ax2.plot(np.cos(x));</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224430.png" alt=""></p><p>这样我们就有两个子图表（上面的子图表没有 x 轴刻度），这两个子图表正好吻合：上面图表的底部是整个图表高度 50%位置，而下面图表的顶部也是整个图表的 50%位置（0.1+0.4）。</p><h2 id="plt-subplot：简单网格的子图表"><a href="#plt-subplot：简单网格的子图表" class="headerlink" title="plt.subplot：简单网格的子图表"></a><strong>plt.subplot：简单网格的子图表</strong></h2><p>将子图表的行与列对齐是一个很常见的需求，因此 Matplotlib 提供了一些简单的函数来实现它们。这些函数当中最底层的是plt.subplot()，它会在网格中创建一个子图表。函数接受三个整数参数，网格行数，网格列数以及该网格子图表的序号（从左上角向右下角递增）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">7</span>):</span><br><span class="line">    plt.subplot(<span class="number">2</span>, <span class="number">3</span>, i)</span><br><span class="line">    plt.text(<span class="number">0.5</span>, <span class="number">0.5</span>, str((<span class="number">2</span>, <span class="number">3</span>, i)),</span><br><span class="line">             fontsize=<span class="number">18</span>, ha=<span class="string">'center'</span>)</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224433.png" alt=""></p><p>plt.subplots_adjust函数用来调整这些子图表之间的距离。下面的代码使用了与plt.subplot()等价的面向对象接口方法fig.add_subplot()：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fig = plt.figure()</span><br><span class="line">fig.subplots_adjust(hspace=<span class="number">0.4</span>, wspace=<span class="number">0.4</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">7</span>):</span><br><span class="line">    ax = fig.add_subplot(<span class="number">2</span>, <span class="number">3</span>, i)</span><br><span class="line">    ax.text(<span class="number">0.5</span>, <span class="number">0.5</span>, str((<span class="number">2</span>, <span class="number">3</span>, i)),</span><br><span class="line">           fontsize=<span class="number">18</span>, ha=<span class="string">'center'</span>)</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224437.png" alt=""></p><p>上例中我们指定了plt.subplots_adjust函数的hspace和wspace参数，它们代表这沿着高度和宽度方向子图表之间的距离，单位是子图表的大小（在本例中，距离是子图表宽度和高度的 40%）。</p><h2 id="plt-subplots：一句代码设置所有网格子图表"><a href="#plt-subplots：一句代码设置所有网格子图表" class="headerlink" title="plt.subplots：一句代码设置所有网格子图表"></a><strong>plt.subplots：一句代码设置所有网格子图表</strong></h2><p>上面的方法在我们需要创建大量的子图表网格时会变得非常冗长乏味，特别是如果我们需要将内部图表 x 轴和 y 轴标签隐藏的情况下。因此，plt.subplots在这种情况下是一个合适的工具（注意末尾有个 s）。这个函数会一次性创建所有的网格子图表，而不是单个网格，并将它们存储在一个 NumPy 数组中返回。参数是行数和列数，还有两个可选的关键字参数sharex和sharey，可以让你指定不同子图表之间的关联。</p><p>下面我们来创建一个  网格的子图表，其中每一行的子图表共享它们的 y 轴，而每一列的子图表共享它们的 x 轴：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(<span class="number">2</span>, <span class="number">3</span>, sharex=<span class="string">'col'</span>, sharey=<span class="string">'row'</span>)</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224441.png" alt=""></p><p>注意上面我们设置了sharex和sharey之后，内部子图表的 x 轴和 y 轴的标签就自动被去掉了。返回值中 ax 是一个 NumPy 数组，里面含有每一个子图表的实例，你可以使用 NumPy 索引的语法很简单的获得它们：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># axes是一个2×3的数组，可以通过[row, col]进行索引访问</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        ax[i, j].text(<span class="number">0.5</span>, <span class="number">0.5</span>, str((i, j)),</span><br><span class="line">                      fontsize=<span class="number">18</span>, ha=<span class="string">'center'</span>)</span><br><span class="line">fig</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224444.png" alt=""></p><p>并且相对于plt.subplot，plt.subplots()更复合 Python 从 0 开始进行索引的习惯。</p><h2 id="plt-GridSpec：更复杂的排列"><a href="#plt-GridSpec：更复杂的排列" class="headerlink" title="plt.GridSpec：更复杂的排列"></a><strong>plt.GridSpec：更复杂的排列</strong></h2><p>当你需要子图表在网格中占据多行或多列时，plt.GridSpec()正是你所需要的。plt.GridSpec()对象并不自己创建图表；它只是一个可以被传递给plt.subplot()的参数。例如，一个两行三列并带有指定的宽度高度间隔的 gridspec 可以如下创建：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grid = plt.GridSpec(<span class="number">2</span>, <span class="number">3</span>, wspace=<span class="number">0.4</span>, hspace=<span class="number">0.3</span>)</span><br></pre></td></tr></table></figure><p>使用这个对象我们可以指定子图表的位置和占据的网格，仅需要使用熟悉的 Python 切片语法即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plt.subplot(grid[<span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line">plt.subplot(grid[<span class="number">0</span>, <span class="number">1</span>:])</span><br><span class="line">plt.subplot(grid[<span class="number">1</span>, :<span class="number">2</span>])</span><br><span class="line">plt.subplot(grid[<span class="number">1</span>, <span class="number">2</span>]);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224449.png" alt=""></p><p>这种灵活的网格对齐控制方式有着广泛的应用。作者经常在需要创建多个直方图的联合图表中使用这种方法，如下例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构建二维正态分布数据</span></span><br><span class="line">mean = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">cov = [[<span class="number">1</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">2</span>]]</span><br><span class="line">x, y = np.random.multivariate_normal(mean, cov, <span class="number">3000</span>).T</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用GridSpec创建网格并加入子图表</span></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">6</span>, <span class="number">6</span>))</span><br><span class="line">grid = plt.GridSpec(<span class="number">4</span>, <span class="number">4</span>, hspace=<span class="number">0.2</span>, wspace=<span class="number">0.2</span>)</span><br><span class="line">main_ax = fig.add_subplot(grid[:<span class="number">-1</span>, <span class="number">1</span>:])</span><br><span class="line">y_hist = fig.add_subplot(grid[:<span class="number">-1</span>, <span class="number">0</span>], xticklabels=[], sharey=main_ax)</span><br><span class="line">x_hist = fig.add_subplot(grid[<span class="number">-1</span>, <span class="number">1</span>:], yticklabels=[], sharex=main_ax)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在主图表中绘制散点图</span></span><br><span class="line">main_ax.plot(x, y, <span class="string">'ok'</span>, markersize=<span class="number">3</span>, alpha=<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分别在x轴和y轴方向绘制直方图</span></span><br><span class="line">x_hist.hist(x, <span class="number">40</span>, histtype=<span class="string">'stepfilled'</span>,</span><br><span class="line">            orientation=<span class="string">'vertical'</span>, color=<span class="string">'gray'</span>)</span><br><span class="line">x_hist.invert_yaxis() <span class="comment"># x轴方向（右下）直方图倒转y轴方向</span></span><br><span class="line"></span><br><span class="line">y_hist.hist(y, <span class="number">40</span>, histtype=<span class="string">'stepfilled'</span>,</span><br><span class="line">            orientation=<span class="string">'horizontal'</span>, color=<span class="string">'gray'</span>)</span><br><span class="line">y_hist.invert_xaxis() <span class="comment"># y轴方向（左上）直方图倒转x轴方向</span></span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224452.png" alt=""></p><p>这种沿着数据各自方向分布并绘制相应图表的需求是很通用的，因此在 Seaborn 包中它们有专门的 API 来实现。</p><h1 id="9-文本和标注"><a href="#9-文本和标注" class="headerlink" title="9.文本和标注"></a><strong>9.文本和标注</strong></h1><p>创建一个优秀的可视化图表的关键在于引导读者，让他们能理解图表所讲述的故事。在一些情况下，这个故事可以通过纯图像的方式表达，不需要额外添加文字，但是在另外一些情况中，图表需要文字的提示和标签才能将故事讲好。也许标注最基本的类型就是图表的标签和标题，但是其中的选项参数却有很多。让我们在本节中使用一些数据来创建可视化图表并标注这些图表来表达这些有趣的信息。首先还是需要将要用到的模块和包导入 notebook：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> mpl</span><br><span class="line">plt.style.use(<span class="string">'seaborn-whitegrid'</span>)</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br></pre></td></tr></table></figure><h2 id="例子：节假日对美国出生率的影响"><a href="#例子：节假日对美国出生率的影响" class="headerlink" title="例子：节假日对美国出生率的影响"></a><strong>例子：节假日对美国出生率的影响</strong></h2><p>本例中的数据可以在 <a href="https://raw.githubusercontent.com/jakevdp/data-CDCbirths/master/births.csv" target="_blank" rel="noopener">https://raw.githubusercontent.com/jakevdp/data-CDCbirths/master/births.csv</a> 下载。</p><p>我们先按照前面的方式进行同样的数据清洗程序，然后以图表展示这个结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">births = pd.read_csv(<span class="string">r'D:\python\Github学习材料\Python数据科学手册\data\births.csv'</span>)</span><br><span class="line"></span><br><span class="line">quartiles = np.percentile(births[<span class="string">'births'</span>], [<span class="number">25</span>, <span class="number">50</span>, <span class="number">75</span>])</span><br><span class="line">mu, sig = quartiles[<span class="number">1</span>], <span class="number">0.74</span> * (quartiles[<span class="number">2</span>] - quartiles[<span class="number">0</span>])</span><br><span class="line">births = births.query(<span class="string">'(births &gt; @mu - 5 * @sig) &amp; (births &lt; @mu + 5 * @sig)'</span>)</span><br><span class="line"></span><br><span class="line">births[<span class="string">'day'</span>] = births[<span class="string">'day'</span>].astype(int)</span><br><span class="line"></span><br><span class="line">births.index = pd.to_datetime(<span class="number">10000</span> * births.year +</span><br><span class="line">                              <span class="number">100</span> * births.month +</span><br><span class="line">                              births.day, format=<span class="string">'%Y%m%d'</span>)</span><br><span class="line">births_by_date = births.pivot_table(<span class="string">'births'</span>,</span><br><span class="line">                                    [births.index.month, births.index.day])</span><br><span class="line">births_by_date.index = [pd.datetime(<span class="number">2012</span>, month, day)</span><br><span class="line">                        <span class="keyword">for</span> (month, day) <span class="keyword">in</span> births_by_date.index]</span><br></pre></td></tr></table></figure><p>C:\Users\gdc\Anaconda3\lib\site-packages\ipykernel_launcher.py:15: FutureWarning: The pandas.datetime class is deprecated and will be removed from pandas in a future version. Import from datetime module instead.<br>  from ipykernel import kernelapp as app</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">12</span>, <span class="number">4</span>))</span><br><span class="line">births_by_date.plot(ax=ax);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224456.png" alt=""></p><p>当我们绘制了这样的图表来表达数据时，如果我们能对一些图表的特性作出标注来，这对吸引读者的注意力通常是非常有帮助的。这可以通过调用plt.text或ax.text函数来实现，它们可以在某个特定的 x，y 轴位置输出一段文字：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">12</span>, <span class="number">4</span>))</span><br><span class="line">births_by_date.plot(ax=ax)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在折线的特殊位置标注文字</span></span><br><span class="line">style = dict(size=<span class="number">10</span>, color=<span class="string">'gray'</span>)</span><br><span class="line"></span><br><span class="line">ax.text(<span class="string">'2012-1-1'</span>, <span class="number">3950</span>, <span class="string">"New Year's Day"</span>, **style)</span><br><span class="line">ax.text(<span class="string">'2012-7-4'</span>, <span class="number">4250</span>, <span class="string">"Independence Day"</span>, ha=<span class="string">'center'</span>, **style)</span><br><span class="line">ax.text(<span class="string">'2012-9-4'</span>, <span class="number">4850</span>, <span class="string">"Labor Day"</span>, ha=<span class="string">'center'</span>, **style)</span><br><span class="line">ax.text(<span class="string">'2012-10-31'</span>, <span class="number">4600</span>, <span class="string">"Halloween"</span>, ha=<span class="string">'right'</span>, **style)</span><br><span class="line">ax.text(<span class="string">'2012-11-25'</span>, <span class="number">4450</span>, <span class="string">"Thanksgiving"</span>, ha=<span class="string">'center'</span>, **style)</span><br><span class="line">ax.text(<span class="string">'2012-12-25'</span>, <span class="number">3850</span>, <span class="string">"Christmas "</span>, ha=<span class="string">'right'</span>, **style)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置标题和y轴标签</span></span><br><span class="line">ax.set(title=<span class="string">'USA births by day of year (1969-1988)'</span>,</span><br><span class="line">       ylabel=<span class="string">'average daily births'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置x轴标签月份居中</span></span><br><span class="line">ax.xaxis.set_major_locator(mpl.dates.MonthLocator())</span><br><span class="line">ax.xaxis.set_minor_locator(mpl.dates.MonthLocator(bymonthday=<span class="number">15</span>))</span><br><span class="line">ax.xaxis.set_major_formatter(plt.NullFormatter())</span><br><span class="line">ax.xaxis.set_minor_formatter(mpl.dates.DateFormatter(<span class="string">'%h'</span>));</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224500.png" alt=""></p><p>ax.text方法接收 x 位置、y 位置、一个字符串和额外可选的关键字参数可以用来设置颜色、大小、样式、对齐等文本格式。上面我们使用了ha=’right’和ha=’center’，这里的ha是<em>hirizonal alignment（水平对齐）</em>的缩写。要查阅更多的可用参数，请查看plt.text()和mpl.text.Text()的文档字符串内容。</p><h2 id="转换和文本位置"><a href="#转换和文本位置" class="headerlink" title="转换和文本位置"></a><strong>转换和文本位置</strong></h2><p>在刚才的例子中，我们将文字标注根据数据位置进行了定位。有些时候我们需要将文字标注独立于数据位置而根据图表位置进行定位。Matplotlib 通过转换完成这项工作。</p><p>任何的图形显示框架都需要在坐标系统之间进行转换的机制。例如，一个数据点位于  被转换为图表中的某个位置，进而转换为屏幕上显示的像素。这样的坐标转换在数学上都相对来说比较直接，而且 Matplotlib 提供了一系列的工具实现了转换（这些工具可以在matplotlib.transforms模块中找到）。</p><p>一般来说，用户很少需要关注这些转换的细节，但是当考虑将文本在图表上展示时，这些知识却比较有用。在这种情况中，下面三种定义好的转换是比较有用的：</p><ul><li>ax.transData：与数据坐标相关的转换</li><li>ax.tranAxes：与 Axes 尺寸相关的转换（单位是 axes 的宽和高）</li><li>ax.tranFigure：与 figure 尺寸相关的转换（单位是 figure 的宽和高）</li></ul><p>下面我们来看看使用这些转换将文字写在图表中不同位置的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(facecolor=<span class="string">'lightgray'</span>)</span><br><span class="line">ax.axis([<span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">10</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># transform=ax.transData是默认的，这里写出来是为了明确对比</span></span><br><span class="line">ax.text(<span class="number">1</span>, <span class="number">5</span>, <span class="string">". Data: (1, 5)"</span>, transform=ax.transData)</span><br><span class="line">ax.text(<span class="number">0.5</span>, <span class="number">0.1</span>, <span class="string">". Axes: (0.5, 0.1)"</span>, transform=ax.transAxes)</span><br><span class="line">ax.text(<span class="number">0.2</span>, <span class="number">0.2</span>, <span class="string">". Figure: (0.2, 0.2)"</span>, transform=fig.transFigure);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224504.png" alt=""></p><p>注意默认情况下，文字是在指定坐标位置靠左对齐的：这里每个字符串开始的”.”的位置就是每种转换的坐标位置。</p><p>transData坐标给定的是通常使用的 x 和 y 轴坐标位置。transAxes坐标给定的是从 axes 左下角开始算起（白色区域）的坐标位置，使用的是宽度和长度的占比。transFigure坐标类似，给定的是从 figure 左下角开始算起（灰色区域）的坐标位置，使用的也是宽度和长度的占比。</p><p>因此如果我们改变了轴的最大长度，只有transData坐标会收到影响，其他两个还是保持在相同位置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ax.set_xlim(<span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">ax.set_ylim(<span class="number">-6</span>, <span class="number">6</span>)</span><br><span class="line">fig</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224507.png" alt=""></p><p>这个变化可以通过动态改变轴的最大长度看的更加清楚：如果你在 notebook 执行这段代码，你可以将%matplotlib inline改为%matplotlib notebook，然后使用图表的菜单来交互式的改变图表。</p><h2 id="箭头和标注"><a href="#箭头和标注" class="headerlink" title="箭头和标注"></a><strong>箭头和标注</strong></h2><p>除了刻度标签和文字标签，另一种常用的标注是箭头。</p><p>在 Matplotlib 中绘制箭头通常比你想象的难得多。虽然有plt.arrow()函数，作者不建议使用它：这个函数绘制的箭头是一个 SVG 对象，因此在图表使用不同的比例的情况会产生问题，结果通常不能让用户满意。因此，作者建议使用plt.annotate()函数。这个函数会绘制一些文字以及一个箭头，并且箭头可以非常灵活的进行配置。</p><p>下面我们提供一些参数来使用annotate函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line"></span><br><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">20</span>, <span class="number">1000</span>)</span><br><span class="line">ax.plot(x, np.cos(x))</span><br><span class="line">ax.axis(<span class="string">'equal'</span>)</span><br><span class="line"></span><br><span class="line">ax.annotate(<span class="string">'local maximum'</span>, xy=(<span class="number">6.28</span>, <span class="number">1</span>), xytext=(<span class="number">10</span>, <span class="number">4</span>),</span><br><span class="line">            arrowprops=dict(facecolor=<span class="string">'black'</span>, shrink=<span class="number">0.05</span>))</span><br><span class="line"></span><br><span class="line">ax.annotate(<span class="string">'local minimum'</span>, xy=(<span class="number">5</span> * np.pi, <span class="number">-1</span>), xytext=(<span class="number">2</span>, <span class="number">-6</span>),</span><br><span class="line">            arrowprops=dict(arrowstyle=<span class="string">"-&gt;"</span>,</span><br><span class="line">                            connectionstyle=<span class="string">"angle3,angleA=0,angleB=-90"</span>));</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224511.png" alt=""></p><p>箭头的样式是使用箭头属性字典值进行控制的，里面有很多可用的参数。这些参数在 Matplotlib 的在线文档中已经有了很详细的说明，因此在这里就不将这部分内容重复介绍一遍了。我们在前面出生率图上再使用一些参数进行更多的说明：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">12</span>, <span class="number">4</span>))</span><br><span class="line">births_by_date.plot(ax=ax)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为图表添加标注</span></span><br><span class="line">ax.annotate(<span class="string">"New Year's Day"</span>, xy=(<span class="string">'2012-1-1'</span>, <span class="number">4100</span>),  xycoords=<span class="string">'data'</span>,</span><br><span class="line">            xytext=(<span class="number">50</span>, <span class="number">-30</span>), textcoords=<span class="string">'offset points'</span>,</span><br><span class="line">            arrowprops=dict(arrowstyle=<span class="string">"-&gt;"</span>,</span><br><span class="line">                            connectionstyle=<span class="string">"arc3,rad=-0.2"</span>))</span><br><span class="line"></span><br><span class="line">ax.annotate(<span class="string">"Independence Day"</span>, xy=(<span class="string">'2012-7-4'</span>, <span class="number">4250</span>),  xycoords=<span class="string">'data'</span>,</span><br><span class="line">            bbox=dict(boxstyle=<span class="string">"round"</span>, fc=<span class="string">"none"</span>, ec=<span class="string">"gray"</span>),</span><br><span class="line">            xytext=(<span class="number">10</span>, <span class="number">-40</span>), textcoords=<span class="string">'offset points'</span>, ha=<span class="string">'center'</span>,</span><br><span class="line">            arrowprops=dict(arrowstyle=<span class="string">"-&gt;"</span>))</span><br><span class="line"></span><br><span class="line">ax.annotate(<span class="string">'Labor Day'</span>, xy=(<span class="string">'2012-9-4'</span>, <span class="number">4850</span>), xycoords=<span class="string">'data'</span>, ha=<span class="string">'center'</span>,</span><br><span class="line">            xytext=(<span class="number">0</span>, <span class="number">-20</span>), textcoords=<span class="string">'offset points'</span>)</span><br><span class="line">ax.annotate(<span class="string">''</span>, xy=(<span class="string">'2012-9-1'</span>, <span class="number">4850</span>), xytext=(<span class="string">'2012-9-7'</span>, <span class="number">4850</span>),</span><br><span class="line">            xycoords=<span class="string">'data'</span>, textcoords=<span class="string">'data'</span>,</span><br><span class="line">            arrowprops=&#123;<span class="string">'arrowstyle'</span>: <span class="string">'|-|,widthA=0.2,widthB=0.2'</span>, &#125;)</span><br><span class="line"></span><br><span class="line">ax.annotate(<span class="string">'Halloween'</span>, xy=(<span class="string">'2012-10-31'</span>, <span class="number">4600</span>),  xycoords=<span class="string">'data'</span>,</span><br><span class="line">            xytext=(<span class="number">-80</span>, <span class="number">-40</span>), textcoords=<span class="string">'offset points'</span>,</span><br><span class="line">            arrowprops=dict(arrowstyle=<span class="string">"fancy"</span>,</span><br><span class="line">                            fc=<span class="string">"0.6"</span>, ec=<span class="string">"none"</span>,</span><br><span class="line">                            connectionstyle=<span class="string">"angle3,angleA=0,angleB=-90"</span>))</span><br><span class="line"></span><br><span class="line">ax.annotate(<span class="string">'Thanksgiving'</span>, xy=(<span class="string">'2012-11-25'</span>, <span class="number">4500</span>),  xycoords=<span class="string">'data'</span>,</span><br><span class="line">            xytext=(<span class="number">-120</span>, <span class="number">-60</span>), textcoords=<span class="string">'offset points'</span>,</span><br><span class="line">            bbox=dict(boxstyle=<span class="string">"round4,pad=.5"</span>, fc=<span class="string">"0.9"</span>),</span><br><span class="line">            arrowprops=dict(arrowstyle=<span class="string">"-&gt;"</span>,</span><br><span class="line">                            connectionstyle=<span class="string">"angle,angleA=0,angleB=80,rad=20"</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ax.annotate(<span class="string">'Christmas'</span>, xy=(<span class="string">'2012-12-25'</span>, <span class="number">3850</span>),  xycoords=<span class="string">'data'</span>,</span><br><span class="line">             xytext=(<span class="number">-30</span>, <span class="number">0</span>), textcoords=<span class="string">'offset points'</span>,</span><br><span class="line">             size=<span class="number">13</span>, ha=<span class="string">'right'</span>, va=<span class="string">"center"</span>,</span><br><span class="line">             bbox=dict(boxstyle=<span class="string">"round"</span>, alpha=<span class="number">0.1</span>),</span><br><span class="line">             arrowprops=dict(arrowstyle=<span class="string">"wedge,tail_width=0.5"</span>, alpha=<span class="number">0.1</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置图表标题和坐标轴标记</span></span><br><span class="line">ax.set(title=<span class="string">'USA births by day of year (1969-1988)'</span>,</span><br><span class="line">       ylabel=<span class="string">'average daily births'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置月份坐标居中显示</span></span><br><span class="line">ax.xaxis.set_major_locator(mpl.dates.MonthLocator())</span><br><span class="line">ax.xaxis.set_minor_locator(mpl.dates.MonthLocator(bymonthday=<span class="number">15</span>))</span><br><span class="line">ax.xaxis.set_major_formatter(plt.NullFormatter())</span><br><span class="line">ax.xaxis.set_minor_formatter(mpl.dates.DateFormatter(<span class="string">'%h'</span>));</span><br><span class="line"></span><br><span class="line">ax.set_ylim(<span class="number">3600</span>, <span class="number">5400</span>);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224515.png" alt=""></p><p>上图中箭头和文字框都非常详尽了：可以看出你几乎可以使用plt.annotate创建任何你想要的箭头样式。不幸的是，这意味着这种特性都需要手工进行调整，因此如果需要获得印刷质量的图像，这将是一个非常耗费时间的工作。最后，必须指出，上述这种多种样式混合的方式来展现数据肯定不是最佳实践，这里只是为了尽可能多的介绍可用的参数。</p><p>更多关于 Matplotlib 的箭头和标注样式的讨论和例子可以访问 Matplotlib gallery，特别是标注演示[6]。</p><h1 id="10-自定义刻度"><a href="#10-自定义刻度" class="headerlink" title="10.自定义刻度"></a><strong>10.自定义刻度</strong></h1><p>Matplotlib 默认的刻度标志和格式被设计成能满足许多通用场景的需求，但是不会是所有图表的最佳选择。本节会介绍一些调整刻度位置和格式的例子来说明自定义刻度的使用。</p><p>在介绍例子之前，我们应该加深对 Matplotlib 图表的对象层次的理解。Matplotlib 的设计目标是展示在图表中的所有内容都会表达成为 Python 的对象：例如，回忆前面我们介绍过figure指的是用来展示图表所有内容的方框。每个 Matplotlib 对象也被设计为其子对象的一个容器：例如figure对象中可以包含一个或多个axes对象，每个axes对象都依次包含着其他用来展示图表的内容对象。</p><p>刻度也不例外。每个axes对象都有着属性xaxis和yaxis，表示 x 和 y 轴，其中包含着所有的属性用来指代轴的线、刻度和标签。</p><h2 id="主要的和次要的刻度"><a href="#主要的和次要的刻度" class="headerlink" title="主要的和次要的刻度"></a><strong>主要的和次要的刻度</strong></h2><p>在每个坐标轴上，都有主要的刻度和次要的刻度概念。正如名字指代的，主要刻度通常是大的和更多用到的，而次要刻度通常是小的。默认 Matplotlib 很少使用次要刻度，但是在对数图表中我们可能会看到它们：</p><p>在 Matplotlib 2.0 之后，当 axis 的跨度过大时，默认次要刻度将会不再展示，因此，下面的代码经过了修改，加上了 xlim 和 ylim 参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.style.use(<span class="string">'classic'</span>)</span><br><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">ax = plt.axes(xscale=<span class="string">'log'</span>, yscale=<span class="string">'log'</span>, xlim=[<span class="number">10e-5</span>, <span class="number">10e5</span>], ylim=[<span class="number">10e-5</span>, <span class="number">10e5</span>])</span><br><span class="line">ax.grid();</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224519.png" alt=""></p><p>我们看到每个主要刻度显示了一个大的标志和标签，而每个次要刻度显示了一个小的刻度标志没有标签。</p><p>这些刻度属性，位置和标签，都可以使用每个轴的formatter和locator对象进行个性化设置。下面我们来查看一下 x 轴的相应对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(ax.xaxis.get_major_locator())</span><br><span class="line">print(ax.xaxis.get_minor_locator())</span><br></pre></td></tr></table></figure><p><matplotlib.ticker.LogLocator object at 0x000001E8074AF108></p><matplotlib.ticker.LogLocator object at 0x000001E8074AD908><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(ax.xaxis.get_major_formatter())</span><br><span class="line">print(ax.xaxis.get_minor_formatter())</span><br></pre></td></tr></table></figure><p><matplotlib.ticker.LogFormatterSciNotation object at 0x000001E8074AEB88></p><matplotlib.ticker.LogFormatterSciNotation object at 0x000001E8074ADB48><p><matplotlib.ticker.LogFormatterSciNotation object at 0x000001E8074AEB88></p><matplotlib.ticker.LogFormatterSciNotation object at 0x000001E8074ADB48><p>我们看到主要和次要刻度的位置都是使用LogLocator来设置的（对于对数图表来说那是理所当然的）。然而次要刻度的标签的格式是NullFormatter：这表示次要刻度不会显示标签。</p><p>译者注：新版 Matplotlib 已经修改，可以看到 Formatter 都统一成为了 LogFormatterSciNotation，再根据图表实际情况选择是否展示标签。</p><p>下面我们就可以开始介绍一些设置这些 locator 和 formatter 的例子了。</p><h2 id="隐藏刻度和标签"><a href="#隐藏刻度和标签" class="headerlink" title="隐藏刻度和标签"></a><strong>隐藏刻度和标签</strong></h2><p>也许最常见的刻度/标签格式设置的操作是隐藏刻度或标签。这可以通过使用plt.NullLocator()和plt.NullFormatter()来设置，如下例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ax &#x3D; plt.axes()</span><br><span class="line">ax.plot(np.random.rand(50))</span><br><span class="line"></span><br><span class="line">ax.yaxis.set_major_locator(plt.NullLocator())</span><br><span class="line">ax.xaxis.set_major_formatter(plt.NullFormatter())</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224522.png" alt=""></p><p>注意上图中我们去除了 x 轴的标签（但是保留了刻度或网格线），y 轴的刻度和标签都被去除了。图表中没有刻度和标签在很多情况下很有用，例如，当你希望展示一个图像的网格。比方说，考虑下面的图表，包含着不同的头像，一个很常见的监督机器学习问题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(<span class="number">5</span>, <span class="number">5</span>, figsize=(<span class="number">5</span>, <span class="number">5</span>))</span><br><span class="line">fig.subplots_adjust(hspace=<span class="number">0</span>, wspace=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从scikit-learn载入头像数据集</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> fetch_olivetti_faces</span><br><span class="line">faces = fetch_olivetti_faces().images</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        ax[i, j].xaxis.set_major_locator(plt.NullLocator())</span><br><span class="line">        ax[i, j].yaxis.set_major_locator(plt.NullLocator())</span><br><span class="line">        ax[i, j].imshow(faces[<span class="number">10</span> * i + j], cmap=<span class="string">"bone"</span>)</span><br></pre></td></tr></table></figure><p>downloading Olivetti faces from<br><a href="https://ndownloader.figshare.com/files/5976027" target="_blank" rel="noopener">https://ndownloader.figshare.com/files/5976027</a><br>to C:\Users\gdc\scikit_learn_data</p><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224526.png" alt=""></p><p>注意上图中每张图像都有它自己的 axes，我们将每一个 axes 的 locator 都设置为 null 因为这些刻度值（像素值）在这里并没有任何实际意义。</p><h2 id="减少或增加刻度的数量"><a href="#减少或增加刻度的数量" class="headerlink" title="减少或增加刻度的数量"></a><strong>减少或增加刻度的数量</strong></h2><p>默认设置的一个常见问题是当子图表较小时，刻度标签可能会粘在一起。我们可以从下面例子看到：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(<span class="number">4</span>, <span class="number">4</span>, sharex=<span class="literal">True</span>, sharey=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224529.png" alt=""></p><p>特别是 x 轴，标签的数字就快重叠在一起了，这让这些标签难以认清。我们可以通过plt.MaxNLocator()来修正这点，用它可以设置最大展示刻度的数量。Matplotlib 会自己计算按照这个最大数量计算的刻度位置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对x和y轴设置刻度最大数量</span></span><br><span class="line"><span class="keyword">for</span> axi <span class="keyword">in</span> ax.flat:</span><br><span class="line">    axi.xaxis.set_major_locator(plt.MaxNLocator(<span class="number">3</span>))</span><br><span class="line">    axi.yaxis.set_major_locator(plt.MaxNLocator(<span class="number">3</span>))</span><br><span class="line">fig</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224532.png" alt=""></p><p>上图就清晰多了。如果你希望对于刻度位置进行更加精细的控制，你可以使用plt.MultipleLocator，我们会接下来讨论这个对象。</p><h2 id="复杂的刻度格式"><a href="#复杂的刻度格式" class="headerlink" title="复杂的刻度格式"></a><strong>复杂的刻度格式</strong></h2><p>Matplotlib 的默认刻度格式只能在很多常见情况下工作良好，但是在特殊情况下你会希望能够更多的进行个性化。考虑下面的正弦和余弦图表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 绘制正弦和余弦图表</span></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">3</span> * np.pi, <span class="number">1000</span>)</span><br><span class="line">ax.plot(x, np.sin(x), lw=<span class="number">3</span>, label=<span class="string">'Sine'</span>)</span><br><span class="line">ax.plot(x, np.cos(x), lw=<span class="number">3</span>, label=<span class="string">'Cosine'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置网格、图例和轴极限</span></span><br><span class="line">ax.grid(<span class="literal">True</span>)</span><br><span class="line">ax.legend(frameon=<span class="literal">False</span>)</span><br><span class="line">ax.axis(<span class="string">'equal'</span>)</span><br><span class="line">ax.set_xlim(<span class="number">0</span>, <span class="number">3</span> * np.pi);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224535.png" alt=""></p><p>这里有几个我们希望进行的改变。首先，如果刻度的间距和网格线是  的倍数会显得更加自然。我们可以通过MultipleLocator来设置它，这个对象用来设置刻度的配置。为了更直观，我们设置主要刻度为  位置，设置次要刻度为  位置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ax.xaxis.set_major_locator(plt.MultipleLocator(np.pi / <span class="number">2</span>))</span><br><span class="line">ax.xaxis.set_minor_locator(plt.MultipleLocator(np.pi / <span class="number">4</span>))</span><br><span class="line">fig</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224538.png" alt=""></p><p>但是上图看起来有点傻：我们可以看出刻度确实是  的倍数，但是使用了小数的展示让它们看起来很奇怪。要修正这些标签，我们需要修改刻度的 formatter。在这种情况中，没有內建的 formatter 可以给我们使用，因此我们使用<code>plt.FuncFormatter</code>，这个对象能够接受一个用户自定义的函数来提供对于刻度标签的精细控制：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">format_func</span><span class="params">(value, tick_number)</span>:</span></span><br><span class="line">    <span class="comment"># N是pi/2的倍数</span></span><br><span class="line">    N = int(np.round(<span class="number">2</span> * value / np.pi))</span><br><span class="line">    <span class="keyword">if</span> N == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"0"</span> <span class="comment"># 0点</span></span><br><span class="line">    <span class="keyword">elif</span> N == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">r"$\frac&#123;\pi&#125;&#123;2&#125;$"</span> <span class="comment"># pi/2</span></span><br><span class="line">    <span class="keyword">elif</span> N == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">r"$\pi$"</span> <span class="comment"># pi</span></span><br><span class="line">    <span class="keyword">elif</span> N % <span class="number">2</span> &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">r"$\frac&#123;&#123;%d&#125;\pi&#125;&#123;2&#125;$"</span> %N <span class="comment"># n*pi/2 n是奇数</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">r"$&#123;0&#125;\pi$"</span>.format(N // <span class="number">2</span>) <span class="comment"># n*pi n是整数</span></span><br><span class="line"></span><br><span class="line">ax.xaxis.set_major_formatter(plt.FuncFormatter(format_func))</span><br><span class="line">fig</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224541.png" alt=""></p><p>上图看起来好多了。注意到我们使用到了 Matplotlib 的 LaTeX 支持，使用美元符号将 LaTeX 字符串括起来。这是用来展示数学符号和公式的简便方法：在这个例子中”$\pi$”被渲染成希腊字母 。</p><p>plt.FuncFomatter()提供了对于图表刻度最高级的自定义和精细控制，并且当你需要创建需要印刷或出版的图表时非常方便。</p><h2 id="Formatter-和-Locator-总结"><a href="#Formatter-和-Locator-总结" class="headerlink" title="Formatter 和 Locator 总结"></a><strong>Formatter 和 Locator 总结</strong></h2><p>我们已经介绍了一些 formatter 和 locator。在最后我们通过将內建的 locator 和 formatter 参数列出来对本节做一个总结。要获得更多相关内容，请参阅文档或 Matplotlib 的在线文档。下表中列出的对象在plt命名空间中都是有效的：</p><div class="table-container"><table><thead><tr><th style="text-align:left">Locator 对象</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>NullLocator</code></td><td style="text-align:left">无刻度</td></tr><tr><td style="text-align:left"><code>FixedLocator</code></td><td style="text-align:left">固定刻度位置</td></tr><tr><td style="text-align:left"><code>IndexLocator</code></td><td style="text-align:left">序号图表刻度 (例如 x = range(len(y)))</td></tr><tr><td style="text-align:left"><code>LinearLocator</code></td><td style="text-align:left">从最小到最大值的均匀分割刻度</td></tr><tr><td style="text-align:left"><code>LogLocator</code></td><td style="text-align:left">从最小到最大值的对数分割刻度</td></tr><tr><td style="text-align:left"><code>MultipleLocator</code></td><td style="text-align:left">某个基数的倍数刻度</td></tr><tr><td style="text-align:left"><code>MaxNLocator</code></td><td style="text-align:left">刻度数量最大值</td></tr><tr><td style="text-align:left"><code>AutoLocator</code></td><td style="text-align:left">默认的刻度数量最大值</td></tr><tr><td style="text-align:left"><code>AutoMinorLocator</code></td><td style="text-align:left">默认的次要刻度</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:left">Formatter 对象</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>NullFormatter</code></td><td style="text-align:left">无标签</td></tr><tr><td style="text-align:left"><code>IndexFormatter</code></td><td style="text-align:left">从一个列表获得标签</td></tr><tr><td style="text-align:left"><code>FixedFormatter</code></td><td style="text-align:left">从固定的字符串设置标签</td></tr><tr><td style="text-align:left"><code>FuncFormatter</code></td><td style="text-align:left">使用自定义函数设置标签</td></tr><tr><td style="text-align:left"><code>FormatStrFormatter</code></td><td style="text-align:left">使用一个格式化字符串设置标签</td></tr><tr><td style="text-align:left"><code>ScalarFormatter</code></td><td style="text-align:left">默认的标量标签</td></tr><tr><td style="text-align:left"><code>LogFormatter</code></td><td style="text-align:left">默认的对数标签</td></tr></tbody></table></div><h1 id="11-在-matplotlib-中创建三维图表"><a href="#11-在-matplotlib-中创建三维图表" class="headerlink" title="11.在 matplotlib 中创建三维图表"></a><strong>11.在 matplotlib 中创建三维图表</strong></h1><p>Matplotlib 最开始被设计为仅支持二维的图表。到 1.0 版本发布左右，一些三维图表的工具在二维展示的基础上被创建了出来，结果就是 Matplotlib 提供了一个方便的（同时也是有限的）的可用于三维数据可视化的一套工具。三维图表可以使用载入mplot3d工具包来激活，这个包会随着 Matplotlib 自动安装：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mpl_toolkits <span class="keyword">import</span> mplot3d</span><br></pre></td></tr></table></figure><p>一旦模块被导入，三维 axes 就可以像其他普通 axes 一样通过关键字参数projection=’3d’来创建：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax = plt.axes(projection=<span class="string">'3d'</span>)</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224547.png" alt=""></p><p>三维 axes 激活后，我们可以在上面绘制不同的三维图表类型。三维图表在 notebook 中使用交互式图表展示会优于使用静态展示；回忆我们前面介绍过，你可以使用%matplotlib notebook而不是%matplotlib inline来激活交互式展示模式。</p><h2 id="三维的点和线"><a href="#三维的点和线" class="headerlink" title="三维的点和线"></a><strong>三维的点和线</strong></h2><p>三维图表中最基础的是使用(x, y, z)坐标定义的一根线或散点的集合。前面介绍过普通的二维图表，作为类比，使用ax.plot3D和ax.scatter3D函数可以创建三维折线和散点图。这两个函数的签名与二维的版本基本一致，你可以参考[简单折线图]和[简单散点图]来复习一下这部分的内容。下面我们绘制一个三维中的三角螺旋，在线的附近在绘制一些随机的点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ax = plt.axes(projection=<span class="string">'3d'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 三维螺旋线的数据</span></span><br><span class="line">zline = np.linspace(<span class="number">0</span>, <span class="number">15</span>, <span class="number">1000</span>)</span><br><span class="line">xline = np.sin(zline)</span><br><span class="line">yline = np.cos(zline)</span><br><span class="line">ax.plot3D(xline, yline, zline, <span class="string">'gray'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 三维散点的数据</span></span><br><span class="line">zdata = <span class="number">15</span> * np.random.random(<span class="number">100</span>)</span><br><span class="line">xdata = np.sin(zdata) + <span class="number">0.1</span> * np.random.randn(<span class="number">100</span>)</span><br><span class="line">ydata = np.cos(zdata) + <span class="number">0.1</span> * np.random.randn(<span class="number">100</span>)</span><br><span class="line">ax.scatter3D(xdata, ydata, zdata, c=zdata, cmap=<span class="string">'Greens'</span>);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224555.png" alt=""></p><p>注意默认情况下，图中的散点会有透明度的区别，用于体现在图中散点的深度。虽然三维效果在静态图像中难以显示，你可以使用交互式的视图来获得更佳的三维直观效果。</p><h2 id="三维轮廓图"><a href="#三维轮廓图" class="headerlink" title="三维轮廓图"></a><strong>三维轮廓图</strong></h2><p>类似于我们在[密度和轮廓图]中介绍的内容，mplot3d也包含着能够创建三维浮雕图像的工具。就像二维的ax.contour图表，ax.contour3D要求输入数据的格式是二维普通网格上计算得到的 Z 轴的数据值。下面我们展示一个三维的正弦函数轮廓图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> np.sin(np.sqrt(x ** <span class="number">2</span> + y ** <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">x = np.linspace(<span class="number">-6</span>, <span class="number">6</span>, <span class="number">30</span>)</span><br><span class="line">y = np.linspace(<span class="number">-6</span>, <span class="number">6</span>, <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">X, Y = np.meshgrid(x, y)</span><br><span class="line">Z = f(X, Y)</span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax = plt.axes(projection=<span class="string">'3d'</span>)</span><br><span class="line">ax.contour3D(X, Y, Z, <span class="number">50</span>, cmap=<span class="string">'binary'</span>)</span><br><span class="line">ax.set_xlabel(<span class="string">'x'</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">'y'</span>)</span><br><span class="line">ax.set_zlabel(<span class="string">'z'</span>);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224600.png" alt=""></p><p>有时候默认的视角角度不是最理想的，在这种情况下我们可以使用view_init函数来设置水平角和方位角。在下面的例子中，我们使用的是 60° 的水平角（即以 60° 俯视 x-y 平面）和 35° 的方位角（即将 z 轴逆时针旋转 35°）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ax.view_init(<span class="number">60</span>, <span class="number">35</span>)</span><br><span class="line">fig</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224603.png" alt=""></p><p>同样，注意到当使用 Matplotlib 交互式展示时，这样的旋转可以通过鼠标点击和拖拽来实现。</p><h2 id="框线图和表面图"><a href="#框线图和表面图" class="headerlink" title="框线图和表面图"></a><strong>框线图和表面图</strong></h2><p>使用网格数据生成的三维图表还有框线图和表面图。这两种图表将网格数据投射到特定的三维表面，能够使得结果图像非常直观和具有说服力。下面是一个框线图的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fig = plt.figure()</span><br><span class="line">ax = plt.axes(projection=<span class="string">'3d'</span>)</span><br><span class="line">ax.plot_wireframe(X, Y, Z, color=<span class="string">'black'</span>)</span><br><span class="line">ax.set_title(<span class="string">'wireframe'</span>);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224606.png" alt=""></p><p>表面图类似框线图，区别在于每个框线构成的多边形都使用颜色进行了填充。添加色图用于填充多边形能够让图形表面展示出来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ax = plt.axes(projection=<span class="string">'3d'</span>)</span><br><span class="line">ax.plot_surface(X, Y, Z, rstride=<span class="number">1</span>, cstride=<span class="number">1</span>,</span><br><span class="line">                cmap=<span class="string">'viridis'</span>, edgecolor=<span class="string">'none'</span>)</span><br><span class="line">ax.set_title(<span class="string">'surface'</span>);</span><br></pre></td></tr></table></figure><p>注意虽<img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224611.png" alt="">然每个颜色填充的表面都是二维的，但是表面的边缘不需要是直线构成的。下面的例子使用surface3D绘制了一个部分极坐标网格，能够让我们切入到函数内部观察效果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">r = np.linspace(<span class="number">0</span>, <span class="number">6</span>, <span class="number">20</span>)</span><br><span class="line">theta = np.linspace(<span class="number">-0.9</span> * np.pi, <span class="number">0.8</span> * np.pi, <span class="number">40</span>)</span><br><span class="line">r, theta = np.meshgrid(r, theta)</span><br><span class="line"></span><br><span class="line">X = r * np.sin(theta)</span><br><span class="line">Y = r * np.cos(theta)</span><br><span class="line">Z = f(X, Y)</span><br><span class="line"></span><br><span class="line">ax = plt.axes(projection=<span class="string">'3d'</span>)</span><br><span class="line">ax.plot_surface(X, Y, Z, rstride=<span class="number">1</span>, cstride=<span class="number">1</span>,</span><br><span class="line">                cmap=<span class="string">'viridis'</span>, edgecolor=<span class="string">'none'</span>);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224615.png" alt=""></p><h2 id="表面三角剖分"><a href="#表面三角剖分" class="headerlink" title="表面三角剖分"></a><strong>表面三角剖分</strong></h2><p>在一些应用场合中，上面的这种均匀网格绘制的图表方式太过于局限和不方便。在这些情况下，三角剖分的图表可以派上用场。如果我们并不是使用笛卡尔坐标系或极坐标系的网格来绘制三维图表，而是使用一组随机的点来绘制三维图表呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">theta = <span class="number">2</span> * np.pi * np.random.random(<span class="number">1000</span>)</span><br><span class="line">r = <span class="number">6</span> * np.random.random(<span class="number">1000</span>)</span><br><span class="line">x = np.ravel(r * np.sin(theta))</span><br><span class="line">y = np.ravel(r * np.cos(theta))</span><br><span class="line">z = f(x, y)</span><br></pre></td></tr></table></figure><p>有了上面的数据之后，我们可以使用它们来绘制一张散点图表现出样本所在表面的情况：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ax = plt.axes(projection=<span class="string">'3d'</span>)</span><br><span class="line">ax.scatter(x, y, z, c=z, cmap=<span class="string">'viridis'</span>, linewidth=<span class="number">0.5</span>);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224628.png" alt=""></p><p>上图并未形象的表示出表面情况。这种情况下我们可以使用ax.plot_trisurf函数，它能首先根据我们的数据输入找到各点内在的三角函数形式，然后绘制表面（注意的是这里的 x，y，z 是一维的数组）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ax = plt.axes(projection=<span class="string">'3d'</span>)</span><br><span class="line">ax.plot_trisurf(x, y, z,</span><br><span class="line">                cmap=<span class="string">'viridis'</span>, edgecolor=<span class="string">'none'</span>);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224632.png" alt=""></p><p>上图的结果很显然没有使用网格绘制表面图那么清晰，但是对于我们并不是使用函数构建数据样本（数据样本通常来自真实世界的采样）的情况下，这能提供很大的帮助。例如我们下面会看到，能使用这种方法绘制一条三维的莫比乌斯环。</p><h3 id="例子：绘制莫比乌斯环"><a href="#例子：绘制莫比乌斯环" class="headerlink" title="例子：绘制莫比乌斯环"></a><strong>例子：绘制莫比乌斯环</strong></h3><p>莫比乌斯环是使用一条纸条，一端翻折后与另一端粘起来形成的环形。在拓扑学中这是非常有趣的一个形状，因为它只有一个面。我们下面使用 Matplotlib 的三维工具绘制莫比乌斯环。创建莫比乌斯环的关键在于能参数化它：莫比乌斯环是一个二维的环状结构，因此我们需要两个特定的维度。一个我们称为 ，取值范围是  表示整个环状，还有一个称为 ，取值范围是  表示纸带的宽度：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">theta = np.linspace(<span class="number">0</span>, <span class="number">2</span> * np.pi, <span class="number">30</span>)</span><br><span class="line">w = np.linspace(<span class="number">-0.25</span>, <span class="number">0.25</span>, <span class="number">8</span>)</span><br><span class="line">w, theta = np.meshgrid(w, theta)</span><br></pre></td></tr></table></figure><p>有了这两个参数之后，我们需要确定莫比乌斯环上<em>(x, y, z)</em>坐标的位置。</p><p>仔细思考一下，我们会发现在莫比乌斯环上有两个自转发生：一个是纸带绕环形中央位置的旋转（我们称为 ），另一个纸带绕着中间轴线的旋转（我们称为 ）。纸带中央位置旋转一整圈  时，纸带绕中间轴线旋转刚好半圈 ，我们将整个旋转均匀分布在纸带上时，就会有 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">phi = <span class="number">0.5</span> * theta</span><br></pre></td></tr></table></figure><p>现在我们已经有了所有需要获得三维坐标值的参数了。我们定义  为每个坐标点距离环形中间的位置，使用它来计算最终  三维坐标系的坐标值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># r是坐标点距离环形中心的距离值</span></span><br><span class="line">r = <span class="number">1</span> + w * np.cos(phi)</span><br><span class="line"><span class="comment"># 利用简单的三角函数知识算得x，y，z坐标值</span></span><br><span class="line">x = np.ravel(r * np.cos(theta))</span><br><span class="line">y = np.ravel(r * np.sin(theta))</span><br><span class="line">z = np.ravel(w * np.sin(phi))</span><br></pre></td></tr></table></figure><p>最后，为了绘制对象，我们必须保证三角剖分是正确的。实现这个最好的方法是在底层的参数上面实现三角剖分，最后让 Matplotlib 将这个三角剖分投射到三维空间中形成莫比乌斯环。下面的代码最终绘制图形：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在底层参数的基础上进行三角剖分</span></span><br><span class="line"><span class="keyword">from</span> matplotlib.tri <span class="keyword">import</span> Triangulation</span><br><span class="line">tri = Triangulation(np.ravel(w), np.ravel(theta))</span><br><span class="line"></span><br><span class="line">ax = plt.axes(projection=<span class="string">'3d'</span>)</span><br><span class="line">ax.plot_trisurf(x, y, z, triangles=tri.triangles,</span><br><span class="line">                cmap=<span class="string">'viridis'</span>, linewidths=<span class="number">0.2</span>);</span><br><span class="line"></span><br><span class="line">ax.set_xlim(<span class="number">-1</span>, <span class="number">1</span>); ax.set_ylim(<span class="number">-1</span>, <span class="number">1</span>); ax.set_zlim(<span class="number">-1</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224638.png" alt=""></p><p>结合这些技巧，能够为你提供在 Matplotlib 创建和展现大量三维对象和模式的能力。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h3><p>[1]PythonDataScienceHandbook:<a href="https://github.com/jakevdp/PythonDataScienceHandbook/tree/master/notebooks" target="_blank" rel="noopener">https://github.com/jakevdp/PythonDataScienceHandbook/tree/master/notebooks</a></p><p>[2]Pythons数据科学:<a href="https://github.com/wangyingsm/Python-Data-Science-Handbook/tree/master/notebooks" target="_blank" rel="noopener">https://github.com/wangyingsm/Python-Data-Science-Handbook/tree/master/notebooks</a></p><p>[3]颜色代码:<a href="https://www.w3schools.com/colors/colors_names.asp" target="_blank" rel="noopener">https://www.w3schools.com/colors/colors_names.asp</a></p><p>[4]秒差距:<a href="https://zh.wikipedia.org/wiki/%E7%A7%92%E5%B7%AE%E8%B7%9D" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E7%A7%92%E5%B7%AE%E8%B7%9D</a></p><p>[5]有趣讨论:<a href="http://Matplotlib.org/1.4.1/users/colormaps.html" target="_blank" rel="noopener">http://Matplotlib.org/1.4.1/users/colormaps.html</a></p><p>[6]标注示:<a href="http://matplotlib.org/examples/pylab_examples/annotation_demo2.html" target="_blank" rel="noopener">http://matplotlib.org/examples/pylab_examples/annotation_demo2.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Matplotlib </tag>
            
            <tag> 数据可视化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习之神经网络实现MNIST手写字识别</title>
      <link href="/2020/10/25/Neural-networks-realizes-MNIST-handwriting-recognition/"/>
      <url>/2020/10/25/Neural-networks-realizes-MNIST-handwriting-recognition/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="一、神经网络原理"><a href="#一、神经网络原理" class="headerlink" title="一、神经网络原理"></a>一、神经网络原理</h2><p>线性回归（Linear Regression）和逻辑回归（Logistic Regression）通常用来处理线性模型，如果利用线性回归或逻辑回归对多特征的非线性问题进行分类，则涉及太多特征组合的计算，往往导致计算负荷增大，并不适合解决这类问题。</p><p>假设我们需要训练一个模型用来判断一张图片中是否出现汽车，可能有很多用来训练模型的数据，这些图片有的包含小汽车，有的没有，利用这些图片的一个个像素值作为特征，训练一个满足这样功能的模型。训练过程需要处理可能百万级别甚至更多的数据，对于这样问题通常采用神经网络（Neural Networks）解决。</p><a id="more"></a><h3 id="1-1-模型"><a href="#1-1-模型" class="headerlink" title="1.1 模型"></a>1.1 模型</h3><p><a href="https://imgchr.com/i/BQBHfO" target="_blank" rel="noopener"><img src="/loading.gif" data-original="https://s1.ax1x.com/2020/10/27/BQBHfO.png" alt=""></a></p><p>这个一个简单的3层神经网络，第一层为输入层（Input Layers），最后一层为输出层（Output Layers），中间层称为隐藏层（Hidden Layers）</p><h3 id="1-2-前向传播"><a href="#1-2-前向传播" class="headerlink" title="1.2 前向传播"></a>1.2 前向传播</h3><h4 id="1-2-1-激活函数"><a href="#1-2-1-激活函数" class="headerlink" title="1.2.1 激活函数"></a>1.2.1 激活函数</h4><p>（1）Sigmoid函数</p><p>一个常见的激活函数，其数学表达式为<a href="https://www.codecogs.com/eqnedit.php?latex=Sig(z)=\frac{1}{1&plus;e^{-z}}" target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?Sig(z)=\frac{1}{1&plus;e^{-z}}" title="Sig(z)=\frac{1}{1+e^{-z}}" /></a>。</p><p>Python实现代码为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>/(<span class="number">1</span>+np.exp(-x))</span><br></pre></td></tr></table></figure><p>（2）ReLU函数</p><p>计算速度更快，是目前的主流激活函数。数学表达式为：<a href="https://www.codecogs.com/eqnedit.php?latex=ReLU(x)=\left\{\begin{matrix}&space;x&space;&&space;if&space;x>0\\&space;0&space;&&space;if&space;x\leq&space;0&space;\end{matrix}\right." target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?ReLU(x)=\left\{\begin{matrix}&space;x&space;&&space;if&space;x>0\\&space;0&space;&&space;if&space;x\leq&space;0&space;\end{matrix}\right." title="ReLU(x)=\left\{\begin{matrix} x & if x>0\\ 0 & if x\leq 0 \end{matrix}\right." /></a></p><p>Python实现代码为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">relu</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> np.maximum(<span class="number">0</span>,x)</span><br></pre></td></tr></table></figure><h4 id="1-2-2-前向传播过程"><a href="#1-2-2-前向传播过程" class="headerlink" title="1.2.2 前向传播过程"></a>1.2.2 前向传播过程</h4><p>除输入层外，每一层神经元都有前一层的神经元作为本层神经元的输入，本层神经元的输出又可以作为下一层神经元的输入，依次向前传播最终得到一个输出值，这个由输入值经输入层经过一系列处理最终到达输出层得到输出值的过程称为前向传播。</p><p><a href="https://imgchr.com/i/B0npqA" target="_blank" rel="noopener"><img src="/loading.gif" data-original="https://s1.ax1x.com/2020/11/01/B0npqA.md.png" alt=""></a></p><p>其中x1, x2, x3是输入单元，即原始的输入数据，a1, a2, a3是中间单元，负责将输入的数据处理然后传递到下一层，最后是输出单元，负责计算<a href="https://www.codecogs.com/eqnedit.php?latex=h_{\Theta&space;}(x)" target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?h_{\Theta&space;}(x)" title="h_{\Theta }(x)" /></a>。计算的过程中为每一层都添加了一个偏置（bias unit）。</p><p>上图中<a href="https://www.codecogs.com/eqnedit.php?latex=\Theta&space;_{1}" target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?\Theta&space;_{1}" title="\Theta _{1}" /></a>，<a href="https://www.codecogs.com/eqnedit.php?latex=\Theta&space;_{2}" target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?\Theta&space;_{2}" title="\Theta _{2}" /></a>分别代表输入层到隐藏层的权重和隐藏层到输出层的权重，对于上图的网络模型激活单元和输出分别表达为：</p><p><a href="https://www.codecogs.com/eqnedit.php?latex=a_{1}^{(2)}=g(\Theta&space;_{10}^{(1)}x_{0}&plus;\Theta&space;_{11}^{(1)}x_{1}&plus;\Theta&space;_{12}^{(1)}x_{2}&plus;\Theta&space;_{13}^{(1)}x_{3})" target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?a_{1}^{(2)}=g(\Theta&space;_{10}^{(1)}x_{0}&plus;\Theta&space;_{11}^{(1)}x_{1}&plus;\Theta&space;_{12}^{(1)}x_{2}&plus;\Theta&space;_{13}^{(1)}x_{3})" title="a_{1}^{(2)}=g(\Theta _{10}^{(1)}x_{0}+\Theta _{11}^{(1)}x_{1}+\Theta _{12}^{(1)}x_{2}+\Theta _{13}^{(1)}x_{3})" /></a></p><p><a href="https://www.codecogs.com/eqnedit.php?latex=a_{2}^{(2)}=g(\Theta&space;_{20}^{(1)}x_{0}&plus;\Theta&space;_{21}^{(1)}x_{1}&plus;\Theta&space;_{22}^{(1)}x_{2}&plus;\Theta&space;_{23}^{(1)}x_{3})" target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?a_{2}^{(2)}=g(\Theta&space;_{20}^{(1)}x_{0}&plus;\Theta&space;_{21}^{(1)}x_{1}&plus;\Theta&space;_{22}^{(1)}x_{2}&plus;\Theta&space;_{23}^{(1)}x_{3})" title="a_{2}^{(2)}=g(\Theta _{20}^{(1)}x_{0}+\Theta _{21}^{(1)}x_{1}+\Theta _{22}^{(1)}x_{2}+\Theta _{23}^{(1)}x_{3})" /></a></p><p><a href="https://www.codecogs.com/eqnedit.php?latex=a_{3}^{(2)}=g(\Theta&space;_{30}^{(1)}x_{0}&plus;\Theta&space;_{31}^{(1)}x_{1}&plus;\Theta&space;_{32}^{(1)}x_{2}&plus;\Theta&space;_{33}^{(1)}x_{3})" target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?a_{3}^{(2)}=g(\Theta&space;_{30}^{(1)}x_{0}&plus;\Theta&space;_{31}^{(1)}x_{1}&plus;\Theta&space;_{32}^{(1)}x_{2}&plus;\Theta&space;_{33}^{(1)}x_{3})" title="a_{3}^{(2)}=g(\Theta _{30}^{(1)}x_{0}+\Theta _{31}^{(1)}x_{1}+\Theta _{32}^{(1)}x_{2}+\Theta _{33}^{(1)}x_{3})" /></a></p><p><a href="https://www.codecogs.com/eqnedit.php?latex=h_{\Theta&space;}(x)=g(\Theta&space;_{10}^{(2)}a_{0}^{(2)}&plus;\Theta&space;_{11}^{(2)}a_{1}^{(2)}&plus;\Theta&space;_{12}^{(2)}a_{2}^{(2)}&plus;\Theta&space;_{13}^{(2)}a_{3}^{(2)})" target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?h_{\Theta&space;}(x)=g(\Theta&space;_{10}^{(2)}a_{0}^{(2)}&plus;\Theta&space;_{11}^{(2)}a_{1}^{(2)}&plus;\Theta&space;_{12}^{(2)}a_{2}^{(2)}&plus;\Theta&space;_{13}^{(2)}a_{3}^{(2)})" title="h_{\Theta }(x)=g(\Theta _{10}^{(2)}a_{0}^{(2)}+\Theta _{11}^{(2)}a_{1}^{(2)}+\Theta _{12}^{(2)}a_{2}^{(2)}+\Theta _{13}^{(2)}a_{3}^{(2)})" /></a></p><p>如此，从左到右的算法称为前向传播算法，实际应用中为了计算方便通常是以矩阵方式计算的。</p><p>Python实现示例（示例不能直接运行）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self,X)</span>:</span></span><br><span class="line">    <span class="comment"># 前向传播算法forward_propagation，实现预测</span></span><br><span class="line">    self.a1 = X.T</span><br><span class="line">    self.z2 = np.dot(self.W1,self.a1)+self.b1</span><br><span class="line">    self.a2 = relu(self.z2)</span><br><span class="line">    self.z3 = np.dot(self.W2,self.a2)+self.b2</span><br><span class="line">    self.a3 = relu(self.z3)</span><br><span class="line">    out = self.a3</span><br><span class="line">    p = np.argmax(out, axis=<span class="number">0</span>)  <span class="comment"># 输出层的最大索引下标即为标签值，标签值0-9</span></span><br><span class="line">    <span class="keyword">return</span> p</span><br></pre></td></tr></table></figure><h3 id="1-3-代价函数"><a href="#1-3-代价函数" class="headerlink" title="1.3 代价函数"></a>1.3 代价函数</h3><p><a href="https://imgchr.com/i/B0M4F1" target="_blank" rel="noopener"><img src="/loading.gif" data-original="https://s1.ax1x.com/2020/11/01/B0M4F1.md.png" alt=""></a></p><p>通过代价函数观察预测的结果与真实情况的误差有多大。</p><h3 id="1-4-反向传播算法"><a href="#1-4-反向传播算法" class="headerlink" title="1.4 反向传播算法"></a>1.4 反向传播算法</h3><p>一般的训练算法可以分为两个阶段：</p><p>（1）求解代价函数关于权值（参数）的导数。（BP）</p><p>（2）用得到的导数进一步计算权值的调整量。（梯度下降等优化算法）</p><p>反向传播（BP）算法主要应用第一阶段,非常高效的计算这些导数。</p><h4 id="1-4-1-推导过程"><a href="#1-4-1-推导过程" class="headerlink" title="1.4.1 推导过程"></a>1.4.1 推导过程</h4><p>假设有一个四层的神经网络，其相关参数为： Sl=4, L=4（其中L表示网络层数，Sl表示l层有多少个神经元），用<a href="https://www.codecogs.com/eqnedit.php?latex=\sigma" target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?\sigma" title="\sigma" /></a>表示误差，结合前面介绍的前向传播过程，则：</p><p><a href="https://www.codecogs.com/eqnedit.php?latex=\sigma&space;^{(4)}=a^{(4)}-y" target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?\sigma&space;^{(4)}=a^{(4)}-y" title="\sigma ^{(4)}=a^{(4)}-y" /></a></p><p>前一层误差为：<a href="https://www.codecogs.com/eqnedit.php?latex=\sigma&space;^{(3)}=(\Theta&space;^{(3)})^{T}\sigma&space;^{(4)}*g^{'}(z^{(2)})" target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?\sigma&space;^{(3)}=(\Theta&space;^{(3)})^{T}\sigma&space;^{(4)}*g^{'}(z^{(2)})" title="\sigma ^{(3)}=(\Theta ^{(3)})^{T}\sigma ^{(4)}*g^{'}(z^{(3)})" /></a></p><p>其中<a href="https://www.codecogs.com/eqnedit.php?latex=g^{'}(z^{(2)})" target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?g^{'}(z^{(2)})" title="g^{'}(z^{(2)})" /></a>是Sig函数的导数。</p><p>接着第二层的误差为：<a href="https://www.codecogs.com/eqnedit.php?latex=\sigma&space;^{(2)}=(\Theta&space;^{(2)})^{T}\sigma&space;^{(3)}*g^{'}(z^{(2)})" target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?\sigma&space;^{(2)}=(\Theta&space;^{(2)})^{T}\sigma&space;^{(3)}*g^{'}(z^{(2)})" title="\sigma ^{(2)}=(\Theta ^{(2)})^{T}\sigma ^{(3)}*g^{'}(z^{(2)})" /></a></p><p>第一层是输入变量，不存在误差，此时不考虑正则项，则有：<a href="https://www.codecogs.com/eqnedit.php?latex=\frac{\partial&space;}{\partial&space;\Theta&space;_{ij}^{(l)}}J(\Theta&space;)=a_{ij}^{(l)}\sigma&space;_{i}^{l&plus;1}" target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?\frac{\partial&space;}{\partial&space;\Theta&space;_{ij}^{(l)}}J(\Theta&space;)=a_{ij}^{(l)}\sigma&space;_{i}^{l&plus;1}" title="\frac{\partial }{\partial \Theta _{ij}^{(l)}}J(\Theta )=a_{ij}^{(l)}\sigma _{i}^{l+1}" /></a></p><p>要求的导数 = 权值输出端单元的误差项 * 权值输入端单元的激活值。</p><p>Python实现示例（示例不能直接运行）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#反向传播：</span></span><br><span class="line"><span class="comment">#1、m表示样本个数</span></span><br><span class="line"><span class="comment">#2、梯度下降，更新W和b</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backward</span><span class="params">(self, dAL)</span>:</span></span><br><span class="line">    m=<span class="number">60000</span></span><br><span class="line">    dZ3=np.multiply(dAL,relu_derivative(self.z3))</span><br><span class="line">    dW2=np.dot(dZ3, self.a2.T)/m</span><br><span class="line">    db2=np.mean(dZ3,axis=<span class="number">1</span>)</span><br><span class="line">    dAL_1 = np.dot(self.W2.T, dZ3)</span><br><span class="line">    dZ2 = np.multiply(dAL_1, relu_derivative(self.z2))</span><br><span class="line">    dW1 = np.dot(dZ2, self.a1.T) / m</span><br><span class="line">    db1 = np.mean(dZ2, axis=<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 更新权值</span></span><br><span class="line">    self.W2-=self.lr*dW2</span><br><span class="line">    self.b2-=self.lr*db2</span><br><span class="line">    self.W1 -= self.lr * dW1</span><br><span class="line">    self.b1 -= self.lr * db1</span><br></pre></td></tr></table></figure><h2 id="二、数据集解析"><a href="#二、数据集解析" class="headerlink" title="二、数据集解析"></a>二、数据集解析</h2><p>数据集来源：<a href="http://yann.lecun.com/exdb/mnist，选用MNIST手写字数据集训练神经网络，数据集使用Python模块Struct解析二进制文件。手写字特征为28*28=784个像素点，输出为手写字值。解析过程不做详细介绍，其数据解析的一种Python实现为：" target="_blank" rel="noopener">http://yann.lecun.com/exdb/mnist，选用MNIST手写字数据集训练神经网络，数据集使用Python模块Struct解析二进制文件。手写字特征为28*28=784个像素点，输出为手写字值。解析过程不做详细介绍，其数据解析的一种Python实现为：</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line">file1=<span class="string">"./MNIST_data/train-images.idx3-ubyte"</span></span><br><span class="line">file2=<span class="string">"./MNIST_data/train-labels.idx1-ubyte"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_images_ana</span><span class="params">(filepath)</span>:</span></span><br><span class="line">    <span class="string">"""解析图片数据集 .idx3-ubyte格式"""</span></span><br><span class="line">    <span class="comment"># 以二进制方式读取文件</span></span><br><span class="line">    <span class="keyword">with</span> open(filepath,<span class="string">'rb'</span>) <span class="keyword">as</span> fbj:</span><br><span class="line">        bin_data=fbj.read()</span><br><span class="line">    offset=<span class="number">0</span></span><br><span class="line">    magic_num,image_num,rows_num,column_num=struct.unpack_from(<span class="string">'&gt;iiii'</span>,bin_data,offset)</span><br><span class="line">    offset+=struct.calcsize(<span class="string">'&gt;iiii'</span>)</span><br><span class="line">    imgsize=image_num*rows_num*column_num</span><br><span class="line">    fmt_image=<span class="string">'&gt;'</span>+str(imgsize)+<span class="string">'B'</span>      <span class="comment"># 训练集数据有60000*28*28</span></span><br><span class="line">    images=struct.unpack_from(fmt_image,bin_data,offset)</span><br><span class="line">    img=np.reshape(images,(image_num,rows_num*column_num))     <span class="comment"># 构造一个60000*784的矩阵</span></span><br><span class="line">    <span class="keyword">return</span> img</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_labels_ana</span><span class="params">(filepath)</span>:</span></span><br><span class="line">    <span class="string">"""解析特征数据集 .idx1-ubyte格式"""</span></span><br><span class="line">    <span class="comment"># 以二进制格式处理文件</span></span><br><span class="line">    <span class="keyword">with</span> open(filepath,<span class="string">'rb'</span>) <span class="keyword">as</span> fbj:</span><br><span class="line">        bin_data=fbj.read()</span><br><span class="line">    offset=<span class="number">0</span></span><br><span class="line">    magic_num,items_num=struct.unpack_from(<span class="string">'&gt;ii'</span>,bin_data,offset)</span><br><span class="line">    offset+=struct.calcsize(<span class="string">'&gt;ii'</span>)</span><br><span class="line">    fmt_label=<span class="string">'&gt;'</span>+str(items_num)+<span class="string">'B'</span></span><br><span class="line">    labels=struct.unpack_from(fmt_label,bin_data,offset)</span><br><span class="line">    label=np.reshape(labels,[items_num])</span><br><span class="line">    <span class="keyword">return</span> label</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    imgs=train_images_ana(file1)</span><br><span class="line">    print(np.shape(imgs[<span class="number">1</span>]))</span><br><span class="line">    labels = train_labels_ana(file2)</span><br><span class="line">    print(labels)</span><br><span class="line">    print(np.shape(labels[<span class="number">1</span>]))</span><br><span class="line">    <span class="comment"># 查看前10个手写字灰度图</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        img=np.reshape(imgs[i],[<span class="number">28</span>,<span class="number">28</span>])</span><br><span class="line">        plt.imshow(img,cmap=<span class="string">'gray'</span>)</span><br><span class="line">        print(labels[i])</span><br><span class="line">        plt.show()</span><br></pre></td></tr></table></figure><h2 id="三、神经网络搭建"><a href="#三、神经网络搭建" class="headerlink" title="三、神经网络搭建"></a>三、神经网络搭建</h2><p>搭建一个三层神经网络，输入层、隐藏层、输出层节点分别为：784，100，10。</p><h2 id="四、附录"><a href="#四、附录" class="headerlink" title="四、附录"></a>四、附录</h2><p>network.py文件，构建神经网络类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> activation_func <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> loss <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Network</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,inputnodes,hidnodes,outputnodes,learning_rate)</span>:</span></span><br><span class="line">        self.innodes = inputnodes</span><br><span class="line">        self.hidnodes = hidnodes</span><br><span class="line">        self.outnodes = outputnodes</span><br><span class="line">        self.lr = learning_rate</span><br><span class="line">        <span class="comment">#各层权重 偏置</span></span><br><span class="line">        self.W1 = np.random.randn(self.hidnodes, self.innodes) * <span class="number">0.01</span></span><br><span class="line">        self.W2 = np.random.randn(self.outnodes, self.hidnodes) * <span class="number">0.01</span></span><br><span class="line">        self.b1 = np.random.randn(self.hidnodes, <span class="number">1</span>) * <span class="number">0.01</span></span><br><span class="line">        self.b2 = np.random.randn(self.outnodes, <span class="number">1</span>) * <span class="number">0.01</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self,X)</span>:</span></span><br><span class="line">        <span class="comment"># 前向传播算法forward_propagation，实现预测</span></span><br><span class="line">        self.a1 = X.T</span><br><span class="line">        self.z2 = np.dot(self.W1,self.a1)+self.b1</span><br><span class="line">        self.a2 = relu(self.z2)</span><br><span class="line">        self.z3 = np.dot(self.W2,self.a2)+self.b2</span><br><span class="line">        self.a3 = relu(self.z3)</span><br><span class="line">        out = self.a3</span><br><span class="line">        p = np.argmax(out, axis=<span class="number">0</span>)  <span class="comment"># 输出层的最大索引下标即为标签值，标签值0-9</span></span><br><span class="line">        <span class="keyword">return</span> p</span><br><span class="line"></span><br><span class="line">    <span class="comment">#反向传播：</span></span><br><span class="line">    <span class="comment">#1、m表示样本个数</span></span><br><span class="line">    <span class="comment">#2、梯度下降，更新W和b</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backward</span><span class="params">(self, dAL)</span>:</span></span><br><span class="line">        m=<span class="number">60000</span></span><br><span class="line">        dZ3=np.multiply(dAL,relu_derivative(self.z3))</span><br><span class="line">        dW2=np.dot(dZ3, self.a2.T)/m</span><br><span class="line">        db2=np.mean(dZ3,axis=<span class="number">1</span>)</span><br><span class="line">        dAL_1 = np.dot(self.W2.T, dZ3)</span><br><span class="line">        dZ2 = np.multiply(dAL_1, relu_derivative(self.z2))</span><br><span class="line">        dW1 = np.dot(dZ2, self.a1.T) / m</span><br><span class="line">        db1 = np.mean(dZ2, axis=<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 梯度下降</span></span><br><span class="line">        self.W2-=self.lr*dW2</span><br><span class="line">        self.b2-=self.lr*db2</span><br><span class="line">        self.W1 -= self.lr * dW1</span><br><span class="line">        self.b1 -= self.lr * db1</span><br></pre></td></tr></table></figure><p>loss.py文件，损失函数计算代价。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment">#交叉熵损失函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cross_entropy</span><span class="params">(y, y_predict)</span>:</span></span><br><span class="line">    y_predict = np.clip(y_predict,<span class="number">1e-10</span>,<span class="number">1</span><span class="number">-1e-10</span>) <span class="comment">#防止0*log(0)出现。导致计算结果变为NaN</span></span><br><span class="line">    <span class="keyword">return</span> -(y * np.log(y_predict) + (<span class="number">1</span> - y) * np.log(<span class="number">1</span> - y_predict))</span><br><span class="line"></span><br><span class="line"><span class="comment">#交叉熵损失函数的导函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cross_entropy_der</span><span class="params">(y,y_predict)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> -y/y_predict+(<span class="number">1</span>-y)/(<span class="number">1</span>-y_predict)</span><br></pre></td></tr></table></figure><p>activation.py文件，激活函数及其导数实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    激活函数</span></span><br><span class="line"><span class="string">    选择非线性的激活函数处理非线性假设</span></span><br><span class="line"><span class="string">    常用激活函数relu、sigmoid</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>/(<span class="number">1</span>+np.exp(-x))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">relu</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> np.maximum(<span class="number">0</span>,x)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sig_derivative</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="comment">#sig函数求导</span></span><br><span class="line">    fx=sigmoid(x)</span><br><span class="line">    <span class="keyword">return</span> fx*(<span class="number">1</span>-fx)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">relu_derivative</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (x&gt;=<span class="number">0</span>).astype(np.float64)</span><br></pre></td></tr></table></figure><p>load_data.py文件，加载数据集。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line">file1=<span class="string">"./MNIST_data/train-images.idx3-ubyte"</span></span><br><span class="line">file2=<span class="string">"./MNIST_data/train-labels.idx1-ubyte"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_images_ana</span><span class="params">(filepath)</span>:</span></span><br><span class="line">    <span class="string">"""解析图片数据集 .idx3-ubyte格式"""</span></span><br><span class="line">    <span class="comment"># 以二进制方式读取文件</span></span><br><span class="line">    <span class="keyword">with</span> open(filepath,<span class="string">'rb'</span>) <span class="keyword">as</span> fbj:</span><br><span class="line">        bin_data=fbj.read()</span><br><span class="line"></span><br><span class="line">    offset=<span class="number">0</span></span><br><span class="line">    magic_num,image_num,rows_num,column_num=struct.unpack_from(<span class="string">'&gt;iiii'</span>,bin_data,offset)</span><br><span class="line">    offset+=struct.calcsize(<span class="string">'&gt;iiii'</span>)</span><br><span class="line">    imgsize=image_num*rows_num*column_num</span><br><span class="line">    fmt_image=<span class="string">'&gt;'</span>+str(imgsize)+<span class="string">'B'</span>      <span class="comment"># 训练集数据有60000*28*28</span></span><br><span class="line">    images=struct.unpack_from(fmt_image,bin_data,offset)</span><br><span class="line">    img=np.reshape(images,(image_num,rows_num*column_num))     <span class="comment"># 构造一个60000*784的矩阵</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> img</span><br><span class="line"></span><br><span class="line"><span class="comment">#print(magic_num,image_num,rows_num,column_num)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_labels_ana</span><span class="params">(filepath)</span>:</span></span><br><span class="line">    <span class="string">"""解析特征数据集 .idx1-ubyte格式"""</span></span><br><span class="line">    <span class="comment"># 以二进制格式处理文件</span></span><br><span class="line">    <span class="keyword">with</span> open(filepath,<span class="string">'rb'</span>) <span class="keyword">as</span> fbj:</span><br><span class="line">        bin_data=fbj.read()</span><br><span class="line"></span><br><span class="line">    offset=<span class="number">0</span></span><br><span class="line">    magic_num,items_num=struct.unpack_from(<span class="string">'&gt;ii'</span>,bin_data,offset)</span><br><span class="line">    offset+=struct.calcsize(<span class="string">'&gt;ii'</span>)</span><br><span class="line">    fmt_label=<span class="string">'&gt;'</span>+str(items_num)+<span class="string">'B'</span></span><br><span class="line">    labels=struct.unpack_from(fmt_label,bin_data,offset)</span><br><span class="line">    label=np.reshape(labels,[items_num])</span><br><span class="line">    <span class="keyword">return</span> label</span><br></pre></td></tr></table></figure><p>train.py文件，训练模型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> network <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> load_data <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">input_nodes = <span class="number">784</span></span><br><span class="line">hidden_nodes = <span class="number">100</span></span><br><span class="line">output_nodes = <span class="number">10</span></span><br><span class="line">learning_rate = <span class="number">0.1</span></span><br><span class="line">n = Network(input_nodes, hidden_nodes, output_nodes, learning_rate)</span><br><span class="line"></span><br><span class="line">X=train_images_ana(file1)</span><br><span class="line">Y=train_labels_ana(file2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练神经网络</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    cnt = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">60000</span>):</span><br><span class="line">        Y_predict = n.predict(np.mat(X[i]))</span><br><span class="line">        <span class="keyword">if</span> (Y[i]==Y_predict):</span><br><span class="line">            cnt+=<span class="number">1</span></span><br><span class="line">        dA = cross_entropy_der(np.mat(Y[i]),Y_predict)</span><br><span class="line">        n.backward(dA)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'epoch %d:accurac=%f'</span>%(epoch,cnt/<span class="number">60000</span>))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Machine-Learning </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 神经网络 </tag>
            
            <tag> MNIST </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MNIST手写字符集的数据解析</title>
      <link href="/2020/10/18/Data-analysis-of-MNIST-handwritten-character-set/"/>
      <url>/2020/10/18/Data-analysis-of-MNIST-handwritten-character-set/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p>最近在做MNIST手写字识别，官方MNIST数据集为 .idx3-ubyte 格式，程序无法直接读取，涉及MNIST数据集的解析。</p><p>MNIST数据集：<a href="http://yann.lecun.com/exdb/mnist/" target="_blank" rel="noopener">http://yann.lecun.com/exdb/mnist/</a></p><a id="more"></a><h3 id="2-数据集说明"><a href="#2-数据集说明" class="headerlink" title="2.数据集说明"></a>2.数据集说明</h3><p>官网数据集说明：</p><blockquote><p>train-images-idx3-ubyte.gz:  training set images (9912422 bytes)<br>train-labels-idx1-ubyte.gz:  training set labels (28881 bytes)<br>t10k-images-idx3-ubyte.gz:   test set images (1648877 bytes)<br>t10k-labels-idx1-ubyte.gz:   test set labels (4542 bytes)</p></blockquote><p>一个四个文件，训练图片集、训练特征集、测试图片集、测试特征集。</p><p>官网对图片集和特征集的说明如下：</p><p><strong>TRAINING SET LABEL FILE (train-labels-idx1-ubyte):</strong></p><div class="table-container"><table><thead><tr><th>[offset]</th><th>[type]</th><th style="text-align:left">[value]</th><th>[description]</th></tr></thead><tbody><tr><td>0000</td><td>32 bit integer</td><td style="text-align:left">0x00000801(2049)</td><td>magic number (MSB first)</td></tr><tr><td>0004</td><td>32 bit integer</td><td style="text-align:left">60000</td><td>number of items</td></tr><tr><td>0008</td><td>unsigned byte</td><td style="text-align:left">??</td><td>label</td></tr><tr><td>0009</td><td>unsigned byte</td><td style="text-align:left">??</td><td>label</td></tr><tr><td>……</td><td></td><td style="text-align:left"></td></tr></tbody></table></div><p>The labels values are 0 to 9.</p><p><strong>TRAINING SET IMAGE FILE (train-images-idx3-ubyte):</strong></p><div class="table-container"><table><thead><tr><th>[offset]</th><th>[type]</th><th>[value]</th><th>[description]</th></tr></thead><tbody><tr><td>0000</td><td>32 bit integer</td><td>0x00000803(2051)</td><td>magic number</td></tr><tr><td>0004</td><td>32 bit integer</td><td>60000</td><td>number of images</td></tr><tr><td>0008</td><td>32 bit integer</td><td>28</td><td>number of rows</td></tr><tr><td>0012</td><td>32 bit integer</td><td>28</td><td>number of columns</td></tr><tr><td>0016</td><td>unsigned byte</td><td>??</td><td>pixel</td></tr><tr><td>0017</td><td>unsigned byte</td><td>??</td><td>pixel</td></tr><tr><td>……</td><td></td><td></td></tr></tbody></table></div><p>Pixels are organized row-wise. Pixel values are 0 to 255. 0 means background (white), 255 means foreground (black).</p><h3 id="3-二进制文件解析"><a href="#3-二进制文件解析" class="headerlink" title="3.二进制文件解析"></a>3.二进制文件解析</h3><p>Python中解析二进制文件需要用到Struct模块，Struct的基本函数说明参考：<a href="https://wnxy.xyz/2020/10/17/Daily-usage-of-Struct-module-in-Python/" target="_blank" rel="noopener">https://wnxy.xyz/2020/10/17/Daily-usage-of-Struct-module-in-Python/</a></p><p>相关代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line">file1=<span class="string">"./MNIST_data/train-images.idx3-ubyte"</span></span><br><span class="line">file2=<span class="string">"./MNIST_data/train-labels.idx1-ubyte"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_images_ana</span><span class="params">(filepath)</span>:</span></span><br><span class="line">    <span class="string">"""解析图片数据集 .idx3-ubyte格式"""</span></span><br><span class="line">    <span class="comment"># 以二进制方式读取文件</span></span><br><span class="line">    <span class="keyword">with</span> open(filepath,<span class="string">'rb'</span>) <span class="keyword">as</span> fbj:</span><br><span class="line">        bin_data=fbj.read()</span><br><span class="line">    offset=<span class="number">0</span></span><br><span class="line">    magic_num,image_num,rows_num,column_num=struct.unpack_from(<span class="string">'&gt;iiii'</span>,bin_data,offset)</span><br><span class="line">    offset+=struct.calcsize(<span class="string">'&gt;iiii'</span>)</span><br><span class="line">    imgsize=image_num*rows_num*column_num</span><br><span class="line">    fmt_image=<span class="string">'&gt;'</span>+str(imgsize)+<span class="string">'B'</span>      <span class="comment"># 训练集数据有60000*28*28</span></span><br><span class="line">    images=struct.unpack_from(fmt_image,bin_data,offset)</span><br><span class="line">    img=np.reshape(images,(image_num,rows_num*column_num))     <span class="comment"># 构造一个60000*784的矩阵</span></span><br><span class="line">    <span class="keyword">return</span> img</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_labels_ana</span><span class="params">(filepath)</span>:</span></span><br><span class="line">    <span class="string">"""解析特征数据集 .idx1-ubyte格式"""</span></span><br><span class="line">    <span class="comment"># 以二进制格式处理文件</span></span><br><span class="line">    <span class="keyword">with</span> open(filepath,<span class="string">'rb'</span>) <span class="keyword">as</span> fbj:</span><br><span class="line">        bin_data=fbj.read()</span><br><span class="line">    offset=<span class="number">0</span></span><br><span class="line">    magic_num,items_num=struct.unpack_from(<span class="string">'&gt;ii'</span>,bin_data,offset)</span><br><span class="line">    offset+=struct.calcsize(<span class="string">'&gt;ii'</span>)</span><br><span class="line">    fmt_label=<span class="string">'&gt;'</span>+str(items_num)+<span class="string">'B'</span></span><br><span class="line">    labels=struct.unpack_from(fmt_label,bin_data,offset)</span><br><span class="line">    label=np.reshape(labels,[items_num])</span><br><span class="line">    <span class="keyword">return</span> label</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    imgs=train_images_ana(file1)</span><br><span class="line">    <span class="comment"># 查看前10个手写字灰度图</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        img=np.reshape(imgs[i],[<span class="number">28</span>,<span class="number">28</span>])</span><br><span class="line">        plt.imshow(img,cmap=<span class="string">'gray'</span>)</span><br><span class="line">        plt.show()</span><br><span class="line">    labels=train_labels_ana(file2)</span><br><span class="line">    <span class="comment">#print(labels)</span></span><br></pre></td></tr></table></figure><p>相关文章：</p><ul><li><a href="https://wnxy.xyz/2020/10/17/Daily-usage-of-Struct-module-in-Python/" target="_blank" rel="noopener">Python中Struct模块的日常用法</a></li></ul><p>参考文章：</p><ul><li><a href="https://blog.csdn.net/qq_32166627/article/details/62218072" target="_blank" rel="noopener">mnist数据集解析</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Machine-Learning </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 数据解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python中Struct模块的日常用法</title>
      <link href="/2020/10/17/Daily-usage-of-Struct-module-in-Python/"/>
      <url>/2020/10/17/Daily-usage-of-Struct-module-in-Python/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>最近在训练mnist字符集时用到二进制数据的处理，面向Google编程后稍稍搞懂了一点，故做一点笔记，以作备忘。</strong></p><p>Python 中用来处理二进制数据时采用 Struct 模块。</p><p>Struct模块中最常用的函数为:</p><a id="more"></a><ul><li>pack()</li><li>unpack()</li><li>pack_into()</li><li>unpack_from()</li><li>calcsize()</li></ul><p>pack(fmt, v1, v2, …)  ： 按照给定的格式 fmt（format），把数据封装成字符串。</p><p>unpack(fmt, string) ： 按照给定的格式(fmt)解析字节流 string，解析结果为元组。</p><p>struct.pack_into(fmt, buffer, offset, v1, v2, …) ： 把values：<em>v1, v2, …</em>打包按格式<em>fmt</em>转换后写入指定的内存 <em>buffer</em> 中，并且可以指定<em>buffer</em>中的<em>offset</em>即偏移量，从哪里开始写。</p><p>struct.unpack_from(fmt, buffer, offset=0) ： 从内存中的指定 <em>buffer</em> 区读取出来，然后按照 <em>fmt</em> 格式解析。可以指定<em>offset</em>，从 <em>buffer</em> 的哪个位置开始读取。</p><p>calcsize(fmt) ： 计算给定的格式(fmt)占用多少字节的内存 。</p><p>Struct中支持的格式如下表：</p><div class="table-container"><table><thead><tr><th>Format</th><th>C Type</th><th>Python</th><th>字节数</th></tr></thead><tbody><tr><td>x</td><td>pad byte</td><td>no value</td><td>1</td></tr><tr><td>c</td><td>char</td><td>string of length 1</td><td>1</td></tr><tr><td>b</td><td>signed char</td><td>integer</td><td>1</td></tr><tr><td>B</td><td>unsigned char</td><td>integer</td><td>1</td></tr><tr><td>?</td><td>_Bool</td><td>bool</td><td>1</td></tr><tr><td>h</td><td>short</td><td>integer</td><td>4</td></tr><tr><td>H</td><td>unsigned short</td><td>integer</td><td>4</td></tr><tr><td>i</td><td>int</td><td>integer</td><td>4</td></tr><tr><td>I</td><td>unsigned int</td><td>integer of long</td><td>4</td></tr><tr><td>l</td><td>long</td><td>integer</td><td>4</td></tr><tr><td>L</td><td>unsigned long</td><td>long</td><td>4</td></tr><tr><td>q</td><td>long long</td><td>long</td><td>8</td></tr><tr><td>Q</td><td>unsigned long long</td><td>long</td><td>8</td></tr><tr><td>f</td><td>float</td><td>float</td><td>4</td></tr><tr><td>d</td><td>double</td><td>float</td><td>8</td></tr><tr><td>s</td><td>char[]</td><td>string</td><td>1</td></tr><tr><td>p</td><td>char[]</td><td>string</td><td>1</td></tr><tr><td>P</td><td>void *</td><td>long</td></tr></tbody></table></div><p><strong>q和Q只在机器支持64位操作时有意思</strong></p><p><strong>每个格式前可以有一个数字，表示个数</strong></p><p><strong>s格式表示一个长度的字符串，4s表示长度为4的字符串，但是p表示的是pascal字符串</strong></p><p><strong>P用来转换一个指针，其长度和机器字长相关</strong></p><p><strong>最后一个可以用来表示指针类型的，占4个字节</strong></p><p>参考文章：<a href="https://www.cnblogs.com/gala/archive/2011/09/22/2184801.html" target="_blank" rel="noopener">https://www.cnblogs.com/gala/archive/2011/09/22/2184801.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Struct模块 </tag>
            
            <tag> 二进制处理 </tag>
            
            <tag> Binary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习——逻辑回归算法（Logistic Regression）思想及算法实现</title>
      <link href="/2020/10/11/Machine-learning-logistic-regression-algorithm/"/>
      <url>/2020/10/11/Machine-learning-logistic-regression-algorithm/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-分类原理"><a href="#1-分类原理" class="headerlink" title="1.分类原理"></a>1.分类原理</h1><h2 id="1-1-逻辑回归"><a href="#1-1-逻辑回归" class="headerlink" title="1.1 逻辑回归"></a>1.1 逻辑回归</h2><p>逻辑回归算法是一个分类算法，其性质是它的输出值永远在0到1之间，是目前最流行、最广泛使用的一直学习算法。</p><h2 id="1-2-Sigmoid函数"><a href="#1-2-Sigmoid函数" class="headerlink" title="1.2 Sigmoid函数"></a>1.2 Sigmoid函数</h2><p>根据线性回归模型我们只能预测连续的值，然而对于分类问题，我们需要输出0或1，此时引入逻辑回归模型，模型核心为Sigmoid函数，公式为：$g(z)=\frac{1}{1+e^{-z}}$</p><p>其中：$z=-\Theta^{T} X$</p><a id="more"></a><p>该函数图像为：</p><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/sigmoid.png" alt=""></p><p>$h_{\Theta}(x)$的作用是对于给定的输入变量，根据选择的参数计算出输出变量=1的可能性。</p><h2 id="1-3-代价函数"><a href="#1-3-代价函数" class="headerlink" title="1.3 代价函数"></a>1.3 代价函数</h2><p>在逻辑回归中可以判定当$h_{\Theta}(x)$大于等于0.5时，预测y=1。</p><p>当$h_{\Theta}(x)$小于0.5时，预测y=0。</p><p>逻辑回归中使用最大似然法来拟合参数：<a href="https://www.codecogs.com/eqnedit.php?latex=z=\Theta&space;_{0}&plus;\Theta&space;_{1}x_{1}&plus;\Theta&space;_{2}x_{2}&plus;...&plus;\Theta&space;_{n}x_{n}" target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?z=\Theta&space;_{0}&plus;\Theta&space;_{1}x_{1}&plus;\Theta&space;_{2}x_{2}&plus;...&plus;\Theta&space;_{n}x_{n}" title="z=\Theta _{0}+\Theta _{1}x_{1}+\Theta _{2}x_{2}+...+\Theta _{n}x_{n}" /></a></p><p>训练样本的特征向量为：<a href="https://www.codecogs.com/eqnedit.php?latex=x\epsilon&space;\begin{bmatrix}x_{0}&space;\\&space;x_{1}&space;\\&space;...&space;\\x_{n}&space;\end{bmatrix}" target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?x\epsilon&space;\begin{bmatrix}x_{0}&space;\\&space;x_{1}&space;\\&space;...&space;\\x_{n}&space;\end{bmatrix}" title="x\epsilon \begin{bmatrix}x_{0} \\ x_{1} \\ ... \\x_{n} \end{bmatrix}" /></a></p><p>其中：<a href="https://www.codecogs.com/eqnedit.php?latex=x_{0}=1,y\epsilon&space;\left&space;\{&space;0&space;,1\right&space;\}" target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?x_{0}=1,y\epsilon&space;\left&space;\{&space;0&space;,1\right&space;\}" title="x_{0}=1,y\epsilon \left \{ 0 ,1\right \}" /></a></p><p>构建代价函数为：<a href="https://www.codecogs.com/eqnedit.php?latex=J\left&space;(&space;\Theta&space;\right&space;)=-\frac{1}{m}\sum_{i=1}^{m}\left&space;[&space;y^{\left&space;(&space;i&space;\right&space;)}log\left&space;(&space;h_{\Theta&space;}\left&space;(&space;x^{\left&space;(&space;i&space;\right&space;)}&space;\right&space;)&space;\right&space;)&space;&plus;\left&space;(&space;1-y^{\left&space;(&space;i&space;\right&space;)}&space;\right&space;)log\left&space;(&space;1-h_{\Theta&space;}&space;\left&space;(&space;x^{\left&space;(&space;i&space;\right&space;)}&space;\right&space;)\right&space;)\right&space;]" target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?J\left&space;(&space;\Theta&space;\right&space;)=-\frac{1}{m}\sum_{i=1}^{m}\left&space;[&space;y^{\left&space;(&space;i&space;\right&space;)}log\left&space;(&space;h_{\Theta&space;}\left&space;(&space;x^{\left&space;(&space;i&space;\right&space;)}&space;\right&space;)&space;\right&space;)&space;&plus;\left&space;(&space;1-y^{\left&space;(&space;i&space;\right&space;)}&space;\right&space;)log\left&space;(&space;1-h_{\Theta&space;}&space;\left&space;(&space;x^{\left&space;(&space;i&space;\right&space;)}&space;\right&space;)\right&space;)\right&space;]" title="J\left ( \Theta \right )=-\frac{1}{m}\sum_{i=1}^{m}\left [ y^{\left ( i \right )}log\left ( h_{\Theta }\left ( x^{\left ( i \right )} \right ) \right ) +\left ( 1-y^{\left ( i \right )} \right )log\left ( 1-h_{\Theta } \left ( x^{\left ( i \right )} \right )\right )\right ]" /></a></p><p>使用梯度下降算法求使得代价函数最小的参数：</p><p><img src="/loading.gif" data-original="https://s1.ax1x.com/2020/10/12/0WELAx.png" alt=""></p><h1 id="2-算法实现"><a href="#2-算法实现" class="headerlink" title="2.算法实现"></a>2.算法实现</h1><h2 id="2-1-Sigmoid函数python实现"><a href="#2-1-Sigmoid函数python实现" class="headerlink" title="2.1 Sigmoid函数python实现"></a>2.1 Sigmoid函数python实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义sigmoid函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(z)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>/(<span class="number">1</span>+np.exp(-z))</span><br></pre></td></tr></table></figure><h2 id="2-2-梯度下降算法python实现"><a href="#2-2-梯度下降算法python实现" class="headerlink" title="2.2 梯度下降算法python实现"></a>2.2 梯度下降算法python实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gradAscent</span><span class="params">(dataMatIn, classLabels)</span>:</span></span><br><span class="line">    dataMatrix = mat(dataMatIn)  <span class="comment"># 转换为矩阵</span></span><br><span class="line">    labelMat = mat(classLabels).transpose()  <span class="comment"># 转换为矩阵</span></span><br><span class="line"></span><br><span class="line">    m, n = shape(dataMatrix)</span><br><span class="line">    alpha = <span class="number">0.001</span>   <span class="comment"># 学习率</span></span><br><span class="line">    maxCycles = <span class="number">505</span>   <span class="comment"># 迭代次数</span></span><br><span class="line">    weights = ones((n, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(maxCycles):  <span class="comment"># 迭代拟合参数</span></span><br><span class="line">        h = sigmoid(dataMatrix * weights)  <span class="comment"># 求h</span></span><br><span class="line">        error = (h - labelMat)    <span class="comment"># 求误差量</span></span><br><span class="line">        weights=weights-alpha*dataMatrix.transpose()*error/len(dataMatrix)</span><br><span class="line">    <span class="keyword">return</span> weights</span><br></pre></td></tr></table></figure><h1 id="3-数据集说明"><a href="#3-数据集说明" class="headerlink" title="3.数据集说明"></a>3.数据集说明</h1><p>参考数据集网址: <a href="http://archive.ics.uci.edu/ml/" target="_blank" rel="noopener">http://archive.ics.uci.edu/ml/</a></p><p>本次机器学习逻辑回归算法实现分类使用的是经典数据集 Iris Data（鸢尾花数据集），数据集包含3个类（Iris Setosa、Iris Versicolour、Iris Virginica），每个类有50个实例，其中每个类都涉及一种鸢尾花品种。预测的属性为鸢尾花植物的类别。</p><p>此次算法实现中删掉了其中一个鸢尾花种类，算法引入的数据集只做鸢尾花种类的二分类，并且分别将鸢尾花种类数据集按 8：2 的比例分为训练数据集和测试数据集。</p><p>鸢尾花数据集的属性信息：</p><ul><li>萼片长度（厘米）</li><li>萼片宽度（厘米）</li><li>花瓣长度（厘米）</li><li>花瓣宽度（厘米）</li></ul><p>逻辑回归分类算法的模型训练过程使用鸢尾花的全部四个特征，将鸢尾花样本可视化及分类可视化过程选取了鸢尾花的前两个属性（萼片长度、萼片宽度）。</p><h1 id="4-程序说明"><a href="#4-程序说明" class="headerlink" title="4.程序说明"></a>4.程序说明</h1><h2 id="4-1-载入数据集"><a href="#4-1-载入数据集" class="headerlink" title="4.1 载入数据集"></a>4.1 载入数据集</h2><p>将源数据集载入算法，并初始处理样本，将鸢尾花种类分为正向类和负向类。函数返回鸢尾花的特征向量和对应的鸢尾花种类向量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""载入数据集"""</span></span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">path=<span class="string">"iris_train.data"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loadDataSet</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""读取数据"""</span></span><br><span class="line">    x_data=[]</span><br><span class="line">    y_data=[]</span><br><span class="line">    <span class="keyword">with</span> open(path) <span class="keyword">as</span> f_obj:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f_obj.readlines():</span><br><span class="line">            lineArr=line.strip().split(<span class="string">','</span>)</span><br><span class="line">            lineArr.insert(<span class="number">0</span>,<span class="number">1.0</span>)</span><br><span class="line">            <span class="keyword">if</span> (lineArr[<span class="number">-1</span>]==<span class="string">'Iris-setosa'</span>):</span><br><span class="line">                y_data.append(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">elif</span>(lineArr[<span class="number">-1</span>]==<span class="string">'Iris-versicolor'</span>):</span><br><span class="line">                y_data.append(<span class="number">1</span>)</span><br><span class="line">            x_data.append(list(map(float, lineArr[:<span class="number">-1</span>])))</span><br><span class="line">        <span class="keyword">return</span> x_data,y_data</span><br></pre></td></tr></table></figure><h2 id="4-2-分类可视化"><a href="#4-2-分类可视化" class="headerlink" title="4.2 分类可视化"></a>4.2 分类可视化</h2><h3 id="4-2-1-鸢尾花数据集二分类"><a href="#4-2-1-鸢尾花数据集二分类" class="headerlink" title="4.2.1 鸢尾花数据集二分类"></a>4.2.1 鸢尾花数据集二分类</h3><p>为了直观理解分类结果，便于可视化，利用matplotlib库的pyplot函数，按照鸢尾花数据特征中的萼片长度、萼片宽度属性绘制训练数据集的散点图，并绘制判定边界。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plotBestFit</span><span class="params">(weights)</span>:</span></span><br><span class="line">    dataMat, labelMat = loadDataSet()</span><br><span class="line">    dataArr = array(dataMat)</span><br><span class="line">    n = shape(dataArr)[<span class="number">0</span>]</span><br><span class="line">    xcord1,xcord2 = [],[]</span><br><span class="line">    ycord1,ycord2 = [],[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">if</span> int(labelMat[i]) == <span class="number">1</span>:</span><br><span class="line">            xcord1.append(dataArr[i, <span class="number">1</span>])</span><br><span class="line">            ycord1.append(dataArr[i, <span class="number">2</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            xcord2.append(dataArr[i, <span class="number">1</span>])</span><br><span class="line">            ycord2.append(dataArr[i, <span class="number">2</span>])</span><br><span class="line">    fig = plt.figure()</span><br><span class="line">    ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line">    ax.scatter(xcord1, ycord1, s=<span class="number">30</span>, c=<span class="string">'red'</span>, marker=<span class="string">'s'</span>)</span><br><span class="line">    ax.scatter(xcord2, ycord2, s=<span class="number">30</span>, c=<span class="string">'green'</span>)</span><br><span class="line">    x = arange(<span class="number">3.0</span>, <span class="number">8.0</span>, <span class="number">0.1</span>)</span><br><span class="line">    y = (-(float)(weights[<span class="number">0</span>][<span class="number">0</span>]) - (float)(weights[<span class="number">1</span>][<span class="number">0</span>]) * x) / (float)(weights[<span class="number">2</span>][<span class="number">0</span>])</span><br><span class="line">    ax.plot(x, y)</span><br><span class="line">    plt.title(<span class="string">'Iris data set classification'</span>,fontsize=<span class="number">24</span>)</span><br><span class="line">    plt.xlabel(<span class="string">'Sepal length'</span>)</span><br><span class="line">    plt.ylabel(<span class="string">'Sepal width'</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><h3 id="4-2-分类结果"><a href="#4-2-分类结果" class="headerlink" title="4.2 分类结果"></a>4.2 分类结果</h3><p><img src="/loading.gif" data-original="https://s1.ax1x.com/2020/10/12/0RzjyV.png" alt=""></p><h2 id="4-3-鸢尾花测试集预测"><a href="#4-3-鸢尾花测试集预测" class="headerlink" title="4.3 鸢尾花测试集预测"></a>4.3 鸢尾花测试集预测</h2><h3 id="4-3-1-预测函数"><a href="#4-3-1-预测函数" class="headerlink" title="4.3.1 预测函数"></a>4.3.1 预测函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predictClass</span><span class="params">()</span>:</span></span><br><span class="line">    x,y=[],[]</span><br><span class="line">    dataMat = loadDataSet()</span><br><span class="line">    print(len(mat(dataMat)))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(mat(dataMat))):</span><br><span class="line">        <span class="comment"># 梯度下降算法拟合的最优参数</span></span><br><span class="line">        weights= [<span class="number">0.75401377</span>,<span class="number">-0.2401068</span>,<span class="number">0.15175685</span>,<span class="number">0.64057407</span>,<span class="number">0.93906922</span>]</span><br><span class="line">        z=mat(weights[:<span class="number">-2</span>])*mat(dataMat[i][:<span class="number">-2</span>]).transpose()</span><br><span class="line">        x.append(z)</span><br><span class="line">        h=sigmoid(mat(weights[:<span class="number">-2</span>])*mat(dataMat[i][:<span class="number">-2</span>]).transpose())</span><br><span class="line">        y.append(h)</span><br><span class="line">    <span class="keyword">return</span> x,y</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scatterClass</span><span class="params">()</span>:</span></span><br><span class="line">    x,y=predictClass()</span><br><span class="line">    plt.scatter(x, y, c=<span class="string">'red'</span>,s=<span class="number">40</span>)</span><br><span class="line">    <span class="comment"># 设置坐标轴的取值范围</span></span><br><span class="line">    plt.axis([<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><h3 id="4-3-2-预测结果"><a href="#4-3-2-预测结果" class="headerlink" title="4.3.2 预测结果"></a>4.3.2 预测结果</h3><p>测试可视化过程只选取了梯度下降法得到的前三个最优权值，以此计算预测结果（sigmoid函数值）。</p><p><a href="https://imgchr.com/i/0HUIr6" target="_blank" rel="noopener"><img src="/loading.gif" data-original="https://s1.ax1x.com/2020/10/16/0HUIr6.png" alt=""></a></p><p>鸢尾花测试数据集为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">5.1,3.5,1.4,0.2,Iris-setosa</span><br><span class="line">4.9,3.0,1.4,0.2,Iris-setosa</span><br><span class="line">4.7,3.2,1.3,0.2,Iris-setosa</span><br><span class="line">4.6,3.1,1.5,0.2,Iris-setosa</span><br><span class="line">5.0,3.6,1.4,0.2,Iris-setosa</span><br><span class="line">5.4,3.9,1.7,0.4,Iris-setosa</span><br><span class="line">4.6,3.4,1.4,0.3,Iris-setosa</span><br><span class="line">5.0,3.4,1.5,0.2,Iris-setosa</span><br><span class="line">4.4,2.9,1.4,0.2,Iris-setosa</span><br><span class="line">4.9,3.1,1.5,0.1,Iris-setosa</span><br><span class="line">7.0,3.2,4.7,1.4,Iris-versicolor</span><br><span class="line">6.4,3.2,4.5,1.5,Iris-versicolor</span><br><span class="line">6.9,3.1,4.9,1.5,Iris-versicolor</span><br><span class="line">5.5,2.3,4.0,1.3,Iris-versicolor</span><br><span class="line">6.5,2.8,4.6,1.5,Iris-versicolor</span><br><span class="line">5.7,2.8,4.5,1.3,Iris-versicolor</span><br><span class="line">6.3,3.3,4.7,1.6,Iris-versicolor</span><br><span class="line">4.9,2.4,3.3,1.0,Iris-versicolor</span><br><span class="line">6.6,2.9,4.6,1.3,Iris-versicolor</span><br><span class="line">5.2,2.7,3.9,1.4,Iris-versicolor</span><br></pre></td></tr></table></figure><p>由模型测试图可看出测试结果可辨。</p><h1 id="5-附录"><a href="#5-附录" class="headerlink" title="5.附录"></a>5.附录</h1><p>load_data.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""载入数据集"""</span></span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line">path=<span class="string">"iris_train.data"</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loadDataSet</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""读取数据"""</span></span><br><span class="line">    x_data=[]</span><br><span class="line">    y_data=[]</span><br><span class="line">    <span class="keyword">with</span> open(path) <span class="keyword">as</span> f_obj:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f_obj.readlines():</span><br><span class="line">            lineArr=line.strip().split(<span class="string">','</span>)</span><br><span class="line">            lineArr.insert(<span class="number">0</span>,<span class="number">1.0</span>)</span><br><span class="line">            <span class="keyword">if</span> (lineArr[<span class="number">-1</span>]==<span class="string">'Iris-setosa'</span>):</span><br><span class="line">                y_data.append(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">elif</span>(lineArr[<span class="number">-1</span>]==<span class="string">'Iris-versicolor'</span>):</span><br><span class="line">                y_data.append(<span class="number">1</span>)</span><br><span class="line">            x_data.append(list(map(float, lineArr[:<span class="number">-1</span>])))</span><br><span class="line">        <span class="keyword">return</span> x_data,y_data</span><br></pre></td></tr></table></figure><p>sigmoid.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment">#定义sigmoid函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(z)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>/(<span class="number">1</span>+np.exp(-z))</span><br></pre></td></tr></table></figure><p>gradascent.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sigmoid <span class="keyword">import</span> sigmoid</span><br><span class="line"><span class="keyword">from</span> load_data <span class="keyword">import</span> loadDataSet</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gradAscent</span><span class="params">(dataMatIn, classLabels)</span>:</span></span><br><span class="line">    dataMatrix = mat(dataMatIn)  <span class="comment"># 转换为矩阵</span></span><br><span class="line">    labelMat = mat(classLabels).transpose()  <span class="comment"># 转换为矩阵</span></span><br><span class="line"></span><br><span class="line">    m, n = shape(dataMatrix)</span><br><span class="line">    alpha = <span class="number">0.001</span>   <span class="comment"># 学习率</span></span><br><span class="line">    maxCycles = <span class="number">505</span>   <span class="comment"># 迭代次数</span></span><br><span class="line">    weights = ones((n, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(maxCycles):  <span class="comment"># 迭代拟合参数</span></span><br><span class="line">        h = sigmoid(dataMatrix * weights)  <span class="comment"># 求h</span></span><br><span class="line">        error = (h - labelMat)    <span class="comment"># 求误差量</span></span><br><span class="line">        weights=weights-alpha*dataMatrix.transpose()*error/len(dataMatrix)</span><br><span class="line">    <span class="keyword">return</span> weights</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GetResult</span><span class="params">()</span>:</span></span><br><span class="line">    dataMat, labelMat = loadDataSet()</span><br><span class="line">    weights = gradAscent(dataMat, labelMat)</span><br><span class="line">    print(weights)</span><br><span class="line">    plotBestFit(weights)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plotBestFit</span><span class="params">(weights)</span>:</span></span><br><span class="line">    dataMat, labelMat = loadDataSet()</span><br><span class="line">    dataArr = array(dataMat)</span><br><span class="line">    n = shape(dataArr)[<span class="number">0</span>]</span><br><span class="line">    xcord1,xcord2 = [],[]</span><br><span class="line">    ycord1,ycord2 = [],[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">if</span> int(labelMat[i]) == <span class="number">1</span>:</span><br><span class="line">            xcord1.append(dataArr[i, <span class="number">1</span>])</span><br><span class="line">            ycord1.append(dataArr[i, <span class="number">2</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            xcord2.append(dataArr[i, <span class="number">1</span>])</span><br><span class="line">            ycord2.append(dataArr[i, <span class="number">2</span>])</span><br><span class="line">    fig = plt.figure()</span><br><span class="line">    ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line">    ax.scatter(xcord1, ycord1, s=<span class="number">30</span>, c=<span class="string">'red'</span>, marker=<span class="string">'s'</span>)</span><br><span class="line">    ax.scatter(xcord2, ycord2, s=<span class="number">30</span>, c=<span class="string">'green'</span>)</span><br><span class="line">    x = arange(<span class="number">3.0</span>, <span class="number">8.0</span>, <span class="number">0.1</span>)</span><br><span class="line">    y = (-(float)(weights[<span class="number">0</span>][<span class="number">0</span>]) - (float)(weights[<span class="number">1</span>][<span class="number">0</span>]) * x) / (float)(weights[<span class="number">2</span>][<span class="number">0</span>])</span><br><span class="line">    ax.plot(x, y)</span><br><span class="line">    plt.title(<span class="string">'Iris data set classification'</span>,fontsize=<span class="number">24</span>)</span><br><span class="line">    plt.xlabel(<span class="string">'Sepal length'</span>)</span><br><span class="line">    plt.ylabel(<span class="string">'Sepal width'</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    GetResult()</span><br></pre></td></tr></table></figure><p>predice_classfication.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sigmoid <span class="keyword">import</span> sigmoid</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">path=<span class="string">"iris_test.data"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loadDataSet</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""读取数据"""</span></span><br><span class="line">    x_data=[]</span><br><span class="line">    <span class="keyword">with</span> open(path) <span class="keyword">as</span> f_obj:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f_obj.readlines():</span><br><span class="line">            lineArr=line.strip().split(<span class="string">','</span>)</span><br><span class="line">            lineArr.insert(<span class="number">0</span>,<span class="number">1.0</span>)</span><br><span class="line">            x_data.append(list(map(float, lineArr[:<span class="number">-1</span>])))</span><br><span class="line">        <span class="keyword">return</span> x_data</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predictClass</span><span class="params">()</span>:</span></span><br><span class="line">    x,y=[],[]</span><br><span class="line">    dataMat = loadDataSet()</span><br><span class="line">    print(len(mat(dataMat)))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(mat(dataMat))):</span><br><span class="line">        weights= [<span class="number">0.75401377</span>,<span class="number">-0.2401068</span>,<span class="number">0.15175685</span>,<span class="number">0.64057407</span>,<span class="number">0.93906922</span>]</span><br><span class="line">        print(<span class="string">'z'</span>,mat(weights[:<span class="number">-2</span>])*mat(dataMat[i][:<span class="number">-2</span>]).transpose())</span><br><span class="line">        z=mat(weights[:<span class="number">-2</span>])*mat(dataMat[i][:<span class="number">-2</span>]).transpose()</span><br><span class="line">        x.append(z)</span><br><span class="line">        h=sigmoid(mat(weights[:<span class="number">-2</span>])*mat(dataMat[i][:<span class="number">-2</span>]).transpose())</span><br><span class="line">        y.append(h)</span><br><span class="line">        print(<span class="string">'h'</span>,h)</span><br><span class="line">    <span class="keyword">return</span> x,y</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scatterClass</span><span class="params">()</span>:</span></span><br><span class="line">    x,y=predictClass()</span><br><span class="line">    plt.scatter(x, y, c=<span class="string">'red'</span>,s=<span class="number">40</span>)</span><br><span class="line">    <span class="comment"># 设置坐标轴的取值范围</span></span><br><span class="line">    plt.axis([<span class="number">-0.75</span>, <span class="number">0.75</span>, <span class="number">0.2</span>, <span class="number">0.8</span>])</span><br><span class="line">    plt.title(<span class="string">'Iris data set prediction'</span>,fontsize=<span class="number">24</span>)</span><br><span class="line">    plt.xlabel(<span class="string">'Z'</span>)</span><br><span class="line">    plt.ylabel(<span class="string">'Sigmoid'</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    predictClass()</span><br><span class="line">    scatterClass()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Machine-Learning </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python数据可视化——函数图像绘制</title>
      <link href="/2020/10/09/Python-data-visualization/"/>
      <url>/2020/10/09/Python-data-visualization/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>利用python的matplotlib库进行数据可视化，绘制定义函数的图像。</p><p>以机器学习逻辑回归的sigmoid函数为例：</p><p><a href="https://www.codecogs.com/eqnedit.php?latex=g\left&space;(&space;z&space;\right&space;)=\frac{1}{1&plus;e^{-z}}" target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?g\left&space;(&space;z&space;\right&space;)=\frac{1}{1&plus;e^{-z}}" title="g\left ( z \right )=\frac{1}{1+e^{-z}}" /></a></p><p>python代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义sigmoid函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(z)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>/(<span class="number">1</span>+np.exp(-z))</span><br></pre></td></tr></table></figure><a id="more"></a><p>函数图像为：</p><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/sigmoid.png" alt=""></p><p>以下对python matplotlib库绘制函数图像做简单描述：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义sigmoid函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(z)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>/(<span class="number">1</span>+np.exp(-z))</span><br><span class="line"></span><br><span class="line"><span class="comment">#在-10到10之间生成1000个x值</span></span><br><span class="line">x=np.linspace(<span class="number">-10</span>,<span class="number">10</span>,<span class="number">1000</span>)</span><br><span class="line">y=sigmoid(x)</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取当前的坐标轴, gca = get current axis</span></span><br><span class="line">ax=plt.gca()</span><br><span class="line"><span class="comment">#设置右边框和上边框</span></span><br><span class="line">ax.spines[<span class="string">'right'</span>].set_color(<span class="string">'none'</span>)</span><br><span class="line">ax.spines[<span class="string">'top'</span>].set_color(<span class="string">'none'</span>)</span><br><span class="line"><span class="comment">#设置x坐标轴为下边框</span></span><br><span class="line">ax.xaxis.set_ticks_position(<span class="string">'bottom'</span>)</span><br><span class="line"><span class="comment">#设置y坐标轴为左边框</span></span><br><span class="line">ax.yaxis.set_ticks_position(<span class="string">'left'</span>)</span><br><span class="line"><span class="comment">#设置x轴, y周在(0, 0)的位置</span></span><br><span class="line">ax.spines[<span class="string">'bottom'</span>].set_position((<span class="string">'data'</span>, <span class="number">0</span>))</span><br><span class="line">ax.spines[<span class="string">'left'</span>].set_position((<span class="string">'data'</span>, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">plt.plot(x,y)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Machine-Learning </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> Matplotlib </tag>
            
            <tag> 函数图像 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo melody博客不蒜子统计无法显示问题解决</title>
      <link href="/2020/09/19/Hexo-melody-blog-beautification1/"/>
      <url>/2020/09/19/Hexo-melody-blog-beautification1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>参考文章：<a href="https://www.jianshu.com/p/0befb34dce16" target="_blank" rel="noopener">https://www.jianshu.com/p/0befb34dce16</a></p><p>存在问题：已发布的hexo melody主题博客不蒜子统计不能显示</p><p>解决：修改\themes\melody\layout\includes\count路径下busuanzi.pug文件</p><a id="more"></a><p>原文件为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">.busuanzi</span><br><span class="line">  script(async src&#x3D;&quot;&#x2F;&#x2F;busuanzi.ibruce.info&#x2F;busuanzi&#x2F;2.3&#x2F;busuanzi.pure.mini.js&quot;)</span><br><span class="line">  if(!is_post())</span><br><span class="line">    if(theme.busuanzi.site_uv)</span><br><span class="line">      span#busuanzi_container_site_uv!&#x3D; theme.busuanzi.site_uv_header         &lt;----改</span><br><span class="line">        span#busuanzi_value_site_uv</span><br><span class="line">        span!&#x3D;theme.busuanzi.site_uv_footer</span><br><span class="line">    if(theme.busuanzi.site_pv)</span><br><span class="line">      if(theme.busuanzi.site_pv)</span><br><span class="line">        span.footer-separator |</span><br><span class="line">      span#busuanzi_container_site_pv!&#x3D; theme.busuanzi.site_pv_header         &lt;----改</span><br><span class="line">        span#busuanzi_value_site_pv</span><br><span class="line">        span!&#x3D;theme.busuanzi.site_pv_footer</span><br><span class="line">  else</span><br><span class="line">    if(theme.busuanzi.page_pv)</span><br><span class="line">      span#busuanzi_container_page_pv!&#x3D; theme.busuanzi.page_pv_header         &lt;----改</span><br><span class="line">        span#busuanzi_value_page_pv</span><br><span class="line">        span!&#x3D;theme.busuanzi.page_pv_footer</span><br><span class="line">    else</span><br><span class="line">      if(theme.busuanzi.site_uv)</span><br><span class="line">        span#busuanzi_container_site_uv!&#x3D; theme.busuanzi.site_uv_header       &lt;----改</span><br><span class="line">          span#busuanzi_value_site_uv</span><br><span class="line">          span!&#x3D;theme.busuanzi.site_uv_footer</span><br><span class="line">      if(theme.busuanzi.site_pv)</span><br><span class="line">        if(theme.busuanzi.site_pv)</span><br><span class="line">          span.footer-separator |</span><br><span class="line">        span#busuanzi_container_site_pv!&#x3D; theme.busuanzi.site_pv_header       &lt;----改</span><br><span class="line">          span#busuanzi_value_site_pv</span><br><span class="line">          span!&#x3D;theme.busuanzi.site_pv_footer</span><br></pre></td></tr></table></figure><p>修改后文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">.busuanzi</span><br><span class="line">  script(async src&#x3D;&quot;&#x2F;&#x2F;busuanzi.ibruce.info&#x2F;busuanzi&#x2F;2.3&#x2F;busuanzi.pure.mini.js&quot;)</span><br><span class="line">  if(!is_post())</span><br><span class="line">    if(theme.busuanzi.site_uv)</span><br><span class="line">      span!&#x3D; theme.busuanzi.site_uv_header</span><br><span class="line">        span#busuanzi_value_site_uv</span><br><span class="line">        span!&#x3D;theme.busuanzi.site_uv_footer</span><br><span class="line">    if(theme.busuanzi.site_pv)</span><br><span class="line">      if(theme.busuanzi.site_pv)</span><br><span class="line">        span.footer-separator |</span><br><span class="line">      span!&#x3D; theme.busuanzi.site_pv_header</span><br><span class="line">        span#busuanzi_value_site_pv</span><br><span class="line">        span!&#x3D;theme.busuanzi.site_pv_footer</span><br><span class="line">  else</span><br><span class="line">    if(theme.busuanzi.page_pv)</span><br><span class="line">      span!&#x3D; theme.busuanzi.page_pv_header</span><br><span class="line">        span#busuanzi_value_page_pv</span><br><span class="line">        span!&#x3D;theme.busuanzi.page_pv_footer</span><br><span class="line">    else</span><br><span class="line">      if(theme.busuanzi.site_uv)</span><br><span class="line">        span!&#x3D; theme.busuanzi.site_uv_header</span><br><span class="line">          span#busuanzi_value_site_uv</span><br><span class="line">          span!&#x3D;theme.busuanzi.site_uv_footer</span><br><span class="line">      if(theme.busuanzi.site_pv)</span><br><span class="line">        if(theme.busuanzi.site_pv)</span><br><span class="line">          span.footer-separator |</span><br><span class="line">        span!&#x3D; theme.busuanzi.site_pv_header</span><br><span class="line">          span#busuanzi_value_site_pv</span><br><span class="line">          span!&#x3D;theme.busuanzi.site_pv_footer</span><br></pre></td></tr></table></figure><p>修改后不蒜子显示正常。</p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> melody </tag>
            
            <tag> 博客美化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>星光不负赶路人...</title>
      <link href="/2020/08/11/Starlight-lives-up-to-the-traveler/"/>
      <url>/2020/08/11/Starlight-lives-up-to-the-traveler/</url>
      
        <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Welcome to my blog, enter password to read.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="041166ff4c12570141e825e24b8f1037ad570f6b0dbb39a24673ca7d1b8e2178">d0d703fa332139beb12ceb85f23df7fc2dd2ad6c1e2d88c79a07ca82a4c752383c4b274b70abf24c2627b91511ca38c6827a85fb24bb1d405ef366f63d449475cc7e7021b2f42aea7973805ef690a099be12a8caa2ffdf6dbc9f6212144592fad5a584f16d9cbcc534663cce7d13c5205693b5799467cdca4f31b1eb3da117c4464e9d65e8d2ea086423bfac557b55b88f807ccf0b25016324b2051db850900f99f12708a26a6549e44778d76c46ce31d1a6d64c5e9d8db63da0630457acc014c67941c9a3f8ca646afc155801e88b3509b175e7ac010b442778b88935322dc16758351f90281084ecfd1b06f21cb5a1c4e1255c460c67ea328840963b1ad7b1f852cafe5fdc6953ede3c0673d806bfa3992f6dd31de32c90c355e64e61f782a01dd4ec9754b3e58ce682d7ebafa8936892e07cc0e9ad798833c0cef755a13e67ad45bb2fe8786847e49cd7f05b40f337d3fa9e88d4a34a1b40f82dbaf94cca5a1e56745f5d7142fd61df013d5559425344050fa67e0d3b8063cd0fca30baaa9953891ba1fb89a1c6bca41865c52fe33c02abb579bf67cbb95937dd057cc086349c1477d3b9afdc4f684a1fb23e181bca72b825f582f1e38c37cc156e788bb623f2a7d451e18ac030fa0c04cbd2b28a472519ff52826d31d4a013a00910a82a6432aca1d25277880315953a0b34158427562c6804989f1a32271460b6660c99bba95445298cc42709d2a56c12bfdf4c0faaea1588fb134f69f65935a5e0c6b1fc3518140bb26c35b9eb599fe47ebc63a9404b21daa7f89931e259baf01b7e5256c5450a57c29ce4a7ea7e457108666e8cf001800e44b04608d62c1ac06b4b4d5c1edb1b3aff8e74249fff98c699f8f9e8c998368a557c38c07584c809205c8138a91b6f774bf15582315a60e43736f7576da3f45e598c92f5292cedc7bee97c12c1c12e5b1b1f8e479f50b995ae13780a9e92b521165ce912519184d5c2642ed329d2c45dac2b0d90279103026deaa18b6d09c5553948bd70f892d9dcd04342f6cde9c9afa36c0fd3c852ae8f4386f49f12d8d20b72e80ebb7298bb440e67334e00a3c6b5d2ae9e4086906e8266a4732e6d6e9b38293d4ff9fc4df6fe4d72333d7faf76b8fc9cf2bfd2df68297b3dc9faeb46d52225b8477b45cdd1c58379b78fa2dceef18862ad6437942384d0257d070dca81740ba87f33fad03b7493cbbc159158406cecad04d0668ce8e21557b43e7d49d17f6c3c3636a4fd52ae0809666845a961f7bec20db60fc8e53ca4c508af57b58c242cde427bbf815cc36ad851a7eaad5ab7487bdd941da4ecb969dc7ec1689efb832e0ba990e2e7da29a9289cf093c9492978980bcebbf56a1ae6e402886b4ab7c8e97098655c0c607ca68af147e73cd337891a589f616f71a45cfce865d4c4ffe7dd7d5fddcfdb65059ddbbb27ff431cdb0f42833aae158e126a3886d57161fc24194f3d10a9470a04f76092c33ef060d2a72051d475a61fff2677e85a2b393399e795f287716f9e97228bbb14406c2eb7d904d6c05e90d6f7db9db768c7e2f9e84070e1aad55a34d6ca41538855c0493ac397cff052ba74c9752fb05f0026ed29711c5f18e85853b37f4cc3045338258e62b16dec88503353faf2a023244516c299dd8a696d58554c25f1e9f8d1a021a5550c73d0ebfadf1d4c5f60adadc95fa219e3ef8169f517a8e2988e8d9480da31dcdbcb3b414e4b55b2091ffb2c3079977a535de96e77562664f5d9ae8ddea1282e12f4c3d357fadb3a971588e9221d153ee8a0427920e21c810964bfce016d91c15fc4329eff47521e3159f96acd9e872b480cca17829e991979a3f8ea613a4f6935ae72bc7de3b154af2ac9eac970891f6ee4406dbb7a812044bf8455f7744805459c25698ba1c27cc0534ca85e502f147e1c0a266a5de64a3a20504230868188d86a7077dd7f8db289e1b722f5fcc39b41fddec8366061d06511dfdf939b23b944001b1167dae5b795292c03f686a3dc9dcdfcffc71dc35d12106735c5ff2ee3c447d97d6e0c883b06fab2ce76ca1953c6b5439b69f4fc3d6744fbe4fbb9b65fa05c1c27546cab816a617562057bec889979b53a72c0ebcf5b4f330054eeb7b4dc5e87b4ce959413794844bf0ab020e517fe241bd53a3be51181c72c39436e328484c3b6923c98031d889273af786fb6fca29fb5e6a4fc4ea25c98f94c4412a3e4e173a7b05772d1facdf0804b9e4261e79c71e3cfe468bc3072061530d405f1f3c4f0931b7632337304731d0df617732d1c803a663ba80e9462823b0e6243d4439abe0bbde13fbe1d671b6662f58ec2b3776ac454cf2cbb6582f46c4ad6cef499f91a3696ce6a764c83aca0daa1851265bbf71b4005939bd587ecf3c10c2cc7f87630138b13696a437de48aa63b83b69a7ee070444a2c87616450ea2e3a7f49aae14fb4c88ddee2fee213e77d8c7b25cdfa9a24dbbdc0574a10e7cb3d26bb1d692bc5bec27811a1594f7588b85fed273afbf9a019e6ca7cd1f17434d1f0e7c37f6d17ed85b779c34083aadb6a14d9b83bc6a41d2548ba6195b10310eff31afa17e6c6b0cbefa0fbce570624296d118ac491310ad9bfb31c4fa273a9a1c0b3fbfd5127b7c0e79177441ecac05ee58465f68a88ed82b422b252c2c74242718d84ac88ec08addf6af7588eb6fd7855ab9813d76941ff98df72cb0018f301a0000b09ba8ef3540444b7a08f6a85ce1885e28c0c4c42be1b1f593a7c6b3a9d60443187af13dba92356586abaa077e936867bbffd5f99d9070e6a5e4eebe329d7796b210b139b6243f70e4758b670f7656146b09c353c23de41626fcf9e0dc04893928a26c4415dc92c89d14eeae985a77603f29e92a2f64c3a4511f37c6810a6165eb70a6644b31cadf1f3aab8c90906626a9b907f5f81b31e8885442f224b3e477369e8630e9c5c6736cc3bf069cb6d09a55ba15f5f8a410d162e9899a7ae305c4e2f89fc9627eeae4e51fea6b1c4052ecf554506fc403464f1393050bf09bdec91c30f82caa0ee124b21f1f647d37a372f89f2f1e3b448f75a5755d455cf52c9422fff68a114c64c252831ca49839117b63dd5f0a148703faffdd43ddfe0053a7b1170ae42be4563fa110ce8642cafebc712a4c3e6a370ee8ac4c0114ebfc70b13ffd63e35840d47ddf9d2eacf1dfc05c38c36374a7bf7b6d0f81251a00b4a6950d9a604934782a14c2f4e57db11d780174abc28a4f073d6cc42adb164b46771fd2d1532ef8348548b0741fdc7a30ad38aec863f4c4fdeed4f8b51677d67ccb67e0469d6fc400b9bdf41bd47332a66db77c70ccbed3f96c671fd7657ad084e14e69405d344378a5f81385f4626158bd0d5f2c63b0df9d20b97b72b0616f7bc039aadcaf1d1142d2a2bb1a64c76d7815a270f006760ac65d523316e805f9c4d9028cc7f882377ab9e4e1a77981ea6703ab4fd00a4519e3ad0405d0944ec5fc8385bd2dc52dc615f36f6190f18faf867109d6fc8fddcae1924ea463af50efd905cf1d1f2f394151ad904e46ee6f03f8c14a294e1848190797d8fd3daf70f41eee0ee224d96ab6dead4af929500cb9e808b63b543c38171c0c6fa5c3646f6c2343bcb28e35f329557efcef2095c0b25a1f8199fefbfbc16e26ba23c51f0481a2975b6749b02ce6245e2ee6d668c1ee2b9b2b0d66268fd002c9793a7fd5558afde5113321eb00cd7a6dfa98a8ba9dad4eb74e406eed6e13f0b56964437f3f0383193f0522118457420bd2c8bf3d3a1b31010adff8237f1999e9053688bf5796403ff331cd94387ad3e7897aa3eced58da39a05e162ed3b3af4eaeb4cec6dcbd4ce5847d303f30c27b3e2b57c4cc65aac8474e23846fd9b7e4514122a9ac19dca922467feeb3b50a074f8fc1542ec9a79d8da0e1a47ee3ade2ae473ea295688c81dbab7a9ab34e0467a710aca232a40e04d6872fa2d675438751cf1fe888d6b48a3fcf3477142ccfe4adacffcd415a21d832b836198114b318eb86878f58c6bd0a8728b72d611d5b64013b31a9b814b4ac59cebe55bcc8902f048b81ac06fe049e272253d574881a448fcda568364ba643fc33d89dae6583ceb7c149b3c946a3c2513e06da4c8e9d948d210494c611a1c68020fc52b51c53430e0e6e838066b5d8d9c40557c5df2a04a4e60ff17e14c0dc0e97a04d2217cf85821f3ad194a1ae907e7335ddf37d823b50fc8cdebc8303adb3a4c6033119458a1eb539a7cd897ee02557a99d999ad5d9e2249d19c6a3edb85583c8bb5f2d3dab59bc65436e2b1bee6e305ef662b1b94d91c16ace8b</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 随笔/杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 莞尔日记 </tag>
            
            <tag> 考研 </tag>
            
            <tag> rain杂货 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>github-readme-stats制作个性GitHub简介page</title>
      <link href="/2020/07/20/github-readme-stats-Make-a-personalized-GitHub-profile-page/"/>
      <url>/2020/07/20/github-readme-stats-Make-a-personalized-GitHub-profile-page/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>在GitHub创建一个跟用户名一样的项目，最终会在自己的GitHub首页生成一个个性介绍板块。</p><blockquote><p>You found a secret! <strong>nxyrain/nxyrain</strong>is a ✨<em>special</em> ✨ repository that you can use to add a <code>README.md</code> to your GitHub profile. Make sure it’s public and initialize it with a <strong>README</strong> to get started.</p></blockquote><a id="more"></a><h3 id="一、创建项目"><a href="#一、创建项目" class="headerlink" title="一、创建项目"></a>一、创建项目</h3><p><a href="https://imgchr.com/i/UfzoAx" target="_blank" rel="noopener"><img src="/loading.gif" data-original="https://s1.ax1x.com/2020/07/20/UfzoAx.md.png" alt="创建项目"></a></p><p><strong>注意：</strong></p><p><strong>1、项目名和用户名要一致。</strong></p><p><strong>2、项目要公开，勾选Public。</strong></p><p><strong>3、项目需要初始化，勾选创建README。</strong></p><p>个人首页最上面就出现了个性介绍板块。</p><p><a href="https://imgchr.com/i/UhC2I1" target="_blank" rel="noopener"><img src="/loading.gif" data-original="https://s1.ax1x.com/2020/07/20/UhC2I1.md.png" alt="Hi there"></a></p><h3 id="二、编辑个性介绍板块"><a href="#二、编辑个性介绍板块" class="headerlink" title="二、编辑个性介绍板块"></a>二、编辑个性介绍板块</h3><p><a href="https://imgchr.com/i/UhFGrD" target="_blank" rel="noopener"><img src="/loading.gif" data-original="https://s1.ax1x.com/2020/07/20/UhFGrD.md.png" alt=""></a></p><p>添加内容</p><p><a href="https://imgchr.com/i/UhknOS" target="_blank" rel="noopener"><img src="/loading.gif" data-original="https://s1.ax1x.com/2020/07/20/UhknOS.md.png" alt=""></a></p><p>README支持Markdown语法，编辑完成点击Preview Changes预览编辑效果，编辑完成提交修改即可看见个性介绍页效果。</p><p>最后，安利一个GitHub Readme Stats项目，用来在你的 README 中 获取动态生成的GitHub统计信息！<a href="https://github.com/anuraghazra/github-readme-stats" target="_blank" rel="noopener">项目地址</a></p><p>实现效果：</p><p><img src="/loading.gif" data-original="https://s1.ax1x.com/2020/07/20/UhEmVg.png" alt=""></p><p><img src="/loading.gif" data-original="https://s1.ax1x.com/2020/07/20/UhEu5j.png" alt=""></p><p><img src="/loading.gif" data-original="https://s1.ax1x.com/2020/07/20/UhEnaQ.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> GitHub </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> GitHub </tag>
            
            <tag> 开源 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毕业季——大学路1号的时光</title>
      <link href="/2020/06/22/Graduation-season-Time-at-No.1-University-Road/"/>
      <url>/2020/06/22/Graduation-season-Time-at-No.1-University-Road/</url>
      
        <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Welcome to my blog, enter password to read.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="a9009c374d4b7cfb1d66a661a08dea589685c97ea8d62e599fb0b1c5ef40fe7c">d0d703fa332139beb12ceb85f23df7fc2dd2ad6c1e2d88c79a07ca82a4c752383c4b274b70abf24c2627b91511ca38c6827a85fb24bb1d405ef366f63d449475cc7e7021b2f42aea7973805ef690a099be12a8caa2ffdf6dbc9f6212144592fad5a584f16d9cbcc534663cce7d13c5205693b5799467cdca4f31b1eb3da117c4464e9d65e8d2ea086423bfac557b55b88f807ccf0b25016324b2051db850900f99f12708a26a6549e44778d76c46ce31d1a6d64c5e9d8db63da0630457acc014c67941c9a3f8ca646afc155801e88b3509b175e7ac010b442778b88935322dc16758351f90281084ecfd1b06f21cb5a1c4e1255c460c67ea328840963b1ad7b1f852cafe5fdc6953ede3c0673d806bfa009d3f5d6a00029084c1de6625e741a784f379c02f0721a131959f1754ef211784435f41555f56afffad6533146505632b14f921d8750f0e4c7c1c00230d7bf628979ea09ed966d3eb55372d38ff3bf805c1c77805ec55aba2a2aeb328eda1fe8b8169f03e8b9a67f46a326a164afca24fc5e4f68331ae95c4ace625a9715501c1f198e83f5a061c903b49d1b720ebd326b3fe72c0a073b053ba765a89d24dc176f1197e14d1acc1edbae8a2adceaf26af7f71d43eed341e7fabc01247053c938587d7882cc4f4d2312f08d6c1d3856ae6b39dd68e8a3b12db06d3f57467ef61ad68acd01050cfe046ad60a33908dc4904aff04670232a78751cf9607065641672daa569e559928628f784eb84fba585ba639dcee4ff4d2f17fb4aef454bfc4606bc37babe88146bb8d166260ab698a30c7370fa34c4cd9245872ca0276c2a1ecb235a19365668cfdc764907a1fc9337abd11e735c6ae36493d751da296cebaf47bd83dcd6d9d3e1698088b7bfafb1dde530cbdaec0ef7e395981db0ac70f38d9b93c0ea9235909716ebae4618fb20641f81a1709157837ce2062fbc60968004573d7e254edb23d7ad1540d8269d7ca1abef74fc6c257b73d3a031c15ec2ccbd66cb55a8eb7d8beb2dc712cb5e2a6f01420ce6b899e465e8a1336acce4304fda944a9e55f59d4a50786c3350dea77cf6fb6962eecea5d0b17e314ca50100e0da1b217d0d9fbe163fc1bb2c90697b4fdb0ec645efcf45d0f534d779a712f8d6503ac27c44783ef95a247944997e91efb1f74272e55d4ebab9e67333a64843f1081cd1dde55291d48d2632dfeb02aa30bd0ad4b9995d27496b12a7934a2907f635d8e847bb0f828cdfdfae317267d8f3d7d2efd4ed9c99c064d49778ede73d5aa93335110746f4e2acca0c0287e6fe9492060dcf7dccc1cec632cf3318ea4c410a198d24a71893d0ab57c105b268f2f5dd1cfc63bd52fdd54ae1ecd0c333e6f7554d5bc3bd9d6cefd4316954e9d142c398ff4b087609b2d154a5821df49cc15ad61b43660529fc4b2ebc2d4360d31636bf82b375820a4dcec56fcbca7f2daccf7581f37607856a5b6cefd54402a9d279b9e7a26e5298ede8df2d4c5c40ddcc9825b3d98ee7384d243bfb7e78796cb090635f38e406ce270998a698c8d43e21a9a6a9407a7a9f2e3d0c6de171b49876fdf1c848ae2d2f427c098a47e1fbbdac89f0cfdee868dc6c02f7b8462753fa245184245faee85f857c201b24b8704ec07328644f0377982ab9f01db118ec24d01a33e8977b417077daa07a8ae0ecee51500cb2b590cfccefee8b4c77e1f314aaabf5597290ae0d8d384e38c107502f8d5aad</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 随笔/杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 莞尔日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>要毕业了</title>
      <link href="/2020/05/30/School-celebration/"/>
      <url>/2020/05/30/School-celebration/</url>
      
        <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Welcome to my blog, enter password to read.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="04022c98e28eb804d78d6977517d525189fd6f278d9eba6271e33bc3795648a6">d0d703fa332139beb12ceb85f23df7fc2dd2ad6c1e2d88c79a07ca82a4c752383c4b274b70abf24c2627b91511ca38c6827a85fb24bb1d405ef366f63d449475cc7e7021b2f42aea7973805ef690a099be12a8caa2ffdf6dbc9f6212144592fad5a584f16d9cbcc534663cce7d13c5205693b5799467cdca4f31b1eb3da117c4464e9d65e8d2ea086423bfac557b55b88f807ccf0b25016324b2051db850900f99f12708a26a6549e44778d76c46ce31d1a6d64c5e9d8db63da0630457acc014c67941c9a3f8ca646afc155801e88b3509b175e7ac010b442778b88935322dc16758351f90281084ecfd1b06f21cb5a1c4e1255c460c67ea328840963b1ad7b1f852cafe5fdc6953ede3c0673d806bfab465055b76af0e55bfe15eea492ea750f9a0a07e1f42b385e4284b5c65df12f42604da7fab383df45f251f283e52995def43ebd728f6f41974639c9fd13d56ff246f847dbe18edb14c3416549ecd240c36fc7171724f671ff0c674be23902d3afff100a1a5cbd1e50a86512065b5bb8f74259b7ddd119983283ef678bb214d79937fb73c4ec90a09ac2e344eb4349b176b010dbd2ccd3b9361c981c69e072a00b46092b1b7cc4137d0ba09bf4810a9d678d3c124114184ad2f97060ce8f2073d</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 随笔/杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 莞尔日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++二维数组参数传递</title>
      <link href="/2020/05/01/C-or-C++_two-dimensional-array-parameter-transfer/"/>
      <url>/2020/05/01/C-or-C++_two-dimensional-array-parameter-transfer/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="C-C-语言中二维数组参数传递常用三种方法："><a href="#C-C-语言中二维数组参数传递常用三种方法：" class="headerlink" title="C/C++语言中二维数组参数传递常用三种方法："></a>C/C++语言中二维数组参数传递常用三种方法：</h3><ul><li><p>方法一：形参为二维数组并给出第二维的大小</p><p>如：<code>void sum(int a[][3])</code></p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a[][<span class="number">3</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line">s += a[<span class="number">0</span>][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">2</span>][<span class="number">3</span>] = &#123; &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125; &#125;;</span><br><span class="line">sum(b);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方法二：形参为指向数组的指针并给出数组的长度</p><p>如：<code>void sum(int (*a)[3])</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum1</span><span class="params">(<span class="keyword">int</span>(*a)[<span class="number">3</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line">s += a[<span class="number">0</span>][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方法三：形参为指针的指针且实参必须为指针，而不能是数组名</p><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> **a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line">s += a[<span class="number">0</span>][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *a[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">2</span>][<span class="number">3</span>] = &#123; &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125; &#125;;</span><br><span class="line">a[<span class="number">0</span>] = b[<span class="number">0</span>];</span><br><span class="line">a[<span class="number">1</span>] = b[<span class="number">1</span>];</span><br><span class="line">sum(a);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 二维数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>车辆轨迹追踪系统开发文档</title>
      <link href="/2020/04/29/Development-document-of-vehicle-trajectory-tracking-system/"/>
      <url>/2020/04/29/Development-document-of-vehicle-trajectory-tracking-system/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>车辆大规模GPS数据采集预处理系统</p><p>终端管理API接口：</p><div class="table-container"><table><thead><tr><th>模块</th><th>接口名称</th><th>功能说明</th></tr></thead><tbody><tr><td>entity</td><td>add</td><td>创建entity</td></tr><tr><td></td><td>update</td><td>更新entity</td></tr><tr><td></td><td>delete</td><td>删除entity</td></tr><tr><td></td><td>list</td><td>检索符合过滤条件的entity，返回entity属性信息和最新位置，可用于列出entity，也可用于批量查询多个entity的位置。</td></tr></tbody></table></div><p>API接口总览：<a href="http://lbsyun.baidu.com/index.php?title=yingyan/api/v3/entity" target="_blank" rel="noopener">http://lbsyun.baidu.com/index.php?title=yingyan/api/v3/entity</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>栈的应用——括号匹配</title>
      <link href="/2020/03/27/Stack-application-bracket-matching/"/>
      <url>/2020/03/27/Stack-application-bracket-matching/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>题目描述：编写程序，判定给定表达式中的括号是否匹配，表达式中的合法括号位 “(”，“)”，“[”，“]”，“{”，“}”，括号可按任意次序嵌套使用。</p><p>输入说明：有多个表达式，输入数据第一行是表达式的数目，每个表达式占一行。</p><p>输出说明：对每个表达式，若其括号匹配则输出“Yes”，否则输出“No”。</p><a id="more"></a><p>C++实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> ch[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;s;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">while</span> (n--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; ch;</span><br><span class="line">flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; ch[i] != <span class="string">'\0'</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ch[i] == <span class="string">'('</span> || ch[i] == <span class="string">'['</span> || ch[i] == <span class="string">'&#123;'</span>)</span><br><span class="line">&#123;</span><br><span class="line">s.push(ch[i]);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!s.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ch[i] == <span class="string">')'</span>&amp;&amp;s.top() == <span class="string">'('</span>)</span><br><span class="line">&#123;</span><br><span class="line">s.pop();</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ch[i] == <span class="string">']'</span>&amp;&amp;s.top() == <span class="string">'['</span>)</span><br><span class="line">&#123;</span><br><span class="line">s.pop();</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ch[i] == <span class="string">'&#125;'</span>&amp;&amp;s.top() == <span class="string">'&#123;'</span>)</span><br><span class="line">&#123;</span><br><span class="line">s.pop();</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ch[i] == <span class="string">')'</span>&amp;&amp;s.top() != <span class="string">'('</span>)</span><br><span class="line">&#123;</span><br><span class="line">flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ch[i] == <span class="string">']'</span>&amp;&amp;s.top() != <span class="string">'['</span>)</span><br><span class="line">&#123;</span><br><span class="line">flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ch[i] == <span class="string">'&#125;'</span>&amp;&amp;s.top() != <span class="string">'&#123;'</span>)</span><br><span class="line">&#123;</span><br><span class="line">flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (ch[i] == <span class="string">')'</span> || ch[i] == <span class="string">']'</span> || ch[i] == <span class="string">'&#125;'</span>)</span><br><span class="line">&#123;</span><br><span class="line">flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Yes"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"No"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>/<em>——测试用例——</em>/<br>/<em><br>[(d+f)</em>{}]<br>[(2+3)]<br>()}<br>[4(6]7)9<br>*/</p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
            <tag> C/C++ </tag>
            
            <tag> 括号匹配 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈和队列的定义与使用</title>
      <link href="/2020/03/26/Definition-and-use-of-stacks-and-queues/"/>
      <url>/2020/03/26/Definition-and-use-of-stacks-and-queues/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>栈（Stack）：只允许在一端进行插入或删除操作的线性表。</p><p>队列（Queue）：只允许在表的一端进行插入，而在表的另一端进行删除的线性表。</p><p>栈的基本操作：</p><p><code>s.empty()               若栈为空返回true，否则返回false</code><br><code>s.size()                   返回栈中元素的个数</code><br><code>s.pop()                   弹出栈顶元素但不返回其值</code><br><code>s.top()                    若栈s非空，返回栈顶的元素</code><br><code>s.push()                 在栈顶压入新元素</code></p><a id="more"></a><p>队列的基本操作：</p><p><code>q.empty()               若队列为空返回true，否则返回false</code><br><code>q.size()                   返回队列中元素的个数</code><br><code>q.pop()                    弹出队列首元素但不返回其值</code><br><code>q.front()                   返回队首元素的值，但不删除该元素</code><br><code>q.push()                  在队尾压入新元素</code><br><code>q.back()                  返回队列尾元素的值，但不删除该元素</code></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>引入头文件：</p><p><code>#include&lt;stack&gt;</code></p><p><code>#include&lt;queue&gt;</code></p><p>定义栈：<code>stack&lt;int&gt; s;</code></p><p>定义队列：<code>queue&lt;int&gt; q;</code></p><p>举例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;s;<span class="comment">//定义一个栈  </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">s.push(i);</span><br><span class="line"><span class="keyword">while</span> (!s.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s.top() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">s.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"栈内的元素的个数为："</span> &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/tham_/article/details/44733101" target="_blank" rel="noopener">更多参考</a></p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
            <tag> C/C++ </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树构建与遍历——前序和中序或中序和后序确定二叉树</title>
      <link href="/2020/03/25/Bitree-construction-and-traversal/"/>
      <url>/2020/03/25/Bitree-construction-and-traversal/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="二叉树测试用例："><a href="#二叉树测试用例：" class="headerlink" title="二叉树测试用例："></a>二叉树测试用例：</h3><p><img src="/loading.gif" data-original="https://s1.ax1x.com/2020/04/04/GdqXuD.png" alt="二叉树"></p><p>preOrder: ABDGCEFH<br>inOrder: DGBAECHF<br>postOrder: GDBEHFCA</p><ol><li>已知二叉树前序遍历序列和中序遍历序列可以确定一颗二叉树。</li><li>已知二叉树中序遍历序列和后序遍历序列可以确定一颗二叉树。</li><li><u>已知二叉树前序遍历序列和后序遍历序列不能确定一颗二叉树。</u></li></ol><h3 id="已知二叉树前序和中序遍历序列，构造二叉树，C-实现："><a href="#已知二叉树前序和中序遍历序列，构造二叉树，C-实现：" class="headerlink" title="已知二叉树前序和中序遍历序列，构造二叉树，C++实现："></a>已知二叉树前序和中序遍历序列，构造二叉树，C++实现：</h3><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树结点定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> value;</span><br><span class="line">node *lchild;</span><br><span class="line">node *rchild;</span><br><span class="line">node(<span class="keyword">char</span> ch) &#123;</span><br><span class="line">value = ch;</span><br><span class="line">lchild = <span class="literal">NULL</span>;</span><br><span class="line">rchild = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归 二叉树前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(node *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; root-&gt;value;</span><br><span class="line">preOrder(root-&gt;lchild);</span><br><span class="line">preOrder(root-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归 二叉树中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(node *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root)</span><br><span class="line">&#123;</span><br><span class="line">inOrder(root-&gt;lchild);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; root-&gt;value;</span><br><span class="line">inOrder(root-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归 二叉树后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(node *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root)</span><br><span class="line">&#123;</span><br><span class="line">postOrder(root-&gt;lchild);</span><br><span class="line">postOrder(root-&gt;rchild);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; root-&gt;value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">node *<span class="title">buildBitree</span><span class="params">(<span class="built_in">string</span> pre, <span class="built_in">string</span> in)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = pre.length();</span><br><span class="line"><span class="keyword">if</span> (len &lt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">node *root = <span class="keyword">new</span> node(pre[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">int</span> n = in.<span class="built_in">find</span>(pre[<span class="number">0</span>]);</span><br><span class="line">root-&gt;lchild = buildBitree(pre.substr(<span class="number">1</span>, n), in.substr(<span class="number">0</span>, n));</span><br><span class="line">root-&gt;rchild = buildBitree(pre.substr(n + <span class="number">1</span>, len - n - <span class="number">1</span>), in.substr(n + <span class="number">1</span>, len - n - <span class="number">1</span>));</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> pre[<span class="number">100</span>], in[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; pre &gt;&gt; in)</span><br><span class="line">&#123;</span><br><span class="line">node *root = buildBitree(pre, in);</span><br><span class="line">postOrder(root);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//inOrder(root);</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//preOrder(root);</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="已知二叉树中序和后序遍历序列，构造二叉树，C-实现："><a href="#已知二叉树中序和后序遍历序列，构造二叉树，C-实现：" class="headerlink" title="已知二叉树中序和后序遍历序列，构造二叉树，C++实现："></a>已知二叉树中序和后序遍历序列，构造二叉树，C++实现：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">node *<span class="title">buildBitree</span><span class="params">(<span class="built_in">string</span> post, <span class="built_in">string</span> in)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = post.length();</span><br><span class="line"><span class="keyword">if</span> (len &lt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">node *root = <span class="keyword">new</span> node(post[len - <span class="number">1</span>]);</span><br><span class="line"><span class="keyword">int</span> n = in.<span class="built_in">find</span>(post[len - <span class="number">1</span>]);</span><br><span class="line">root-&gt;lchild = buildBitree(post.substr(<span class="number">0</span>, n), in.substr(<span class="number">0</span>, n));</span><br><span class="line">root-&gt;rchild = buildBitree(post.substr(n, len - n - <span class="number">1</span>), in.substr(n + <span class="number">1</span>, len - n - <span class="number">1</span>));</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Notes:</strong> </p><p>&emsp;&emsp;str.length()、str.size()均用来求取字符串的长度。</p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学校航拍</title>
      <link href="/2020/03/21/Cumt-aerial/"/>
      <url>/2020/03/21/Cumt-aerial/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>声明：视频资源来自网络，因为喜欢，所以上传到博客，如有侵权，请联系删除！</strong></p><script src='//player.polyv.net/script/polyvplayer.min.js'></script><div id='plv_8bb758cd63a75137b984b867c33dce10_8'></div><script>var player = polyvObject('#plv_8bb758cd63a75137b984b867c33dce10_8').videoPlayer({    'width':'900',  'height':'506',    'vid' : '8bb758cd63a75137b984b867c33dce10_8' , 'forceH5':true });</script>]]></content>
      
      
      <categories>
          
          <category> 随笔/杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 影音视频 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>金城兰州</title>
      <link href="/2020/03/20/Jincheng-lanzhou/"/>
      <url>/2020/03/20/Jincheng-lanzhou/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>声明：视频资源来自网络，因为喜欢，所以上传到博客，如有侵权，请联系删除！</strong></p><script src='//player.polyv.net/script/polyvplayer.min.js'></script><div id='plv_8bb758cd63e385239d8290fedb7e5dd7_8'></div><script>var player = polyvObject('#plv_8bb758cd63e385239d8290fedb7e5dd7_8').videoPlayer({    'width':'900',  'height':'506',    'vid' : '8bb758cd63e385239d8290fedb7e5dd7_8' , 'forceH5':true });</script>]]></content>
      
      
      <categories>
          
          <category> 随笔/杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 影音视频 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++十进制与二进制的互相转换</title>
      <link href="/2020/02/10/C++_decimal-and-binary-conversion/"/>
      <url>/2020/02/10/C++_decimal-and-binary-conversion/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>手动实现进制转换</p><p>十进制转换为二进制：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">decTobin</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> h,w=<span class="number">1</span>,sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (n)</span><br><span class="line">&#123;</span><br><span class="line">h = n % <span class="number">2</span>;</span><br><span class="line">sum += h * w;</span><br><span class="line">w *= <span class="number">10</span>;</span><br><span class="line">n = n / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>二进制转换为十进制：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binTodec</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> h,w=<span class="number">1</span>,sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (n)</span><br><span class="line">&#123;</span><br><span class="line">h = n % <span class="number">10</span>;</span><br><span class="line">sum += h * w;</span><br><span class="line">w *= <span class="number">2</span>;</span><br><span class="line">n = n / <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 进制转换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++动态数组使用</title>
      <link href="/2020/01/10/C-or-C++_dynamic-array/"/>
      <url>/2020/01/10/C-or-C++_dynamic-array/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>近来刷题，遇到好几道题目需要动态数组解决，现在整理一下。C/C++中动态开辟一维、二维数组很常见，也很实用。</p><p><strong>2021/3/18 更</strong></p><h2 id="C中动态数组的使用"><a href="#C中动态数组的使用" class="headerlink" title="C中动态数组的使用"></a>C中动态数组的使用</h2><p>C语言使用<code>calloc()</code>函数/<code>malloc()</code>函数分配内存空间，均可用来动态申请一维数组/二维数组。</p><p>头文件：<code>#include&lt;stdlib.h&gt;</code></p><p>calloc()函数用来动态的分配内存空间<strong>并初始化为0</strong>，其原型为：</p><a id="more"></a><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">calloc</span><span class="params">(<span class="keyword">size_t</span> num, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span>;</span><br></pre></td></tr></table></figure><p><code>calloc()</code> 在内存中动态地分配 <code>num</code> 个长度为 <code>size</code> 的连续空间，并将每一个字节都初始化为 0。所以它的结果是分配了 <code>num*size</code> 个字节长度的内存空间，并且每个字节的值都是0。</p><p>【返回值】分配成功返回指向该内存的地址，失败则返回 NULL。</p><p>注意：函数的返回值类型是 <code>void *</code>，<code>void</code> 并不是说没有返回值或者返回空指针，而是返回的指针类型未知。所以在使用 <code>calloc()</code> 时通常需要进行强制类型转换，将 <code>void</code> 指针转换成我们希望的类型，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *ptr = (<span class="keyword">char</span> *)<span class="built_in">calloc</span>(<span class="number">10</span>, <span class="number">10</span>);  <span class="comment">// 分配100个字节的内存空间</span></span><br></pre></td></tr></table></figure><p>malloc()函数动态分配内存空间，不做初始化，其原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>【返回值】分配成功返回指向该内存的地址，失败则返回 NULL。</p><h3 id="使用示例："><a href="#使用示例：" class="headerlink" title="使用示例："></a>使用示例：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*申请一个动态数组 存储图像矩阵*/</span></span><br><span class="line">    <span class="keyword">char</span> **bufarray;</span><br><span class="line">    bufarray = (<span class="keyword">char</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>*) * infoHeader-&gt;biHeight); <span class="comment">// 分配所有行的首地址</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; infoHeader-&gt;biHeight; i++) &#123; <span class="comment">// 按行分配每一列</span></span><br><span class="line">        bufarray[i] = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * infoHeader-&gt;biWidth);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放开辟的二维数组空间</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; infoHeader-&gt;biWidth; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(*(bufarray + i));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*申请一个动态数组 存储去除白边后的GM码图片矩阵*/</span></span><br><span class="line">    <span class="keyword">char</span>** imgarray;</span><br><span class="line">    imgarray = (<span class="keyword">char</span>**)<span class="built_in">calloc</span>(macroblock_num * macroblock_len, <span class="keyword">sizeof</span>(<span class="keyword">char</span>*)); <span class="comment">// 分配所有行的首地址</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; macroblock_num * macroblock_len; i++) &#123; <span class="comment">// 按行分配每一列</span></span><br><span class="line">        imgarray[i] = (<span class="keyword">char</span>*)<span class="built_in">calloc</span>(macroblock_num * macroblock_len, <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放开辟的二维数组空间</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; macroblock_num * macroblock_len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(*(imgarray + i));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 申请一个动态一维数组</span></span><br><span class="line"><span class="keyword">char</span>* data_stream;</span><br><span class="line">data_stream = (<span class="keyword">char</span>*)<span class="built_in">calloc</span>(data_correct_num * <span class="number">7</span>, <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放开辟的一维数组空间</span></span><br><span class="line">    <span class="built_in">free</span>(data_stream);</span><br></pre></td></tr></table></figure><h2 id="C-中动态数组的使用"><a href="#C-中动态数组的使用" class="headerlink" title="C++中动态数组的使用"></a>C++中动态数组的使用</h2><ol><li><h3 id="动态开辟一维数组"><a href="#动态开辟一维数组" class="headerlink" title="动态开辟一维数组"></a>动态开辟一维数组</h3><p>动态开辟一维数组简单，代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DynamicCreate1Array</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;len;</span><br><span class="line">    <span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;p[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[] p;         <span class="comment">//动态数组使用完一定要释放</span></span><br></pre></td></tr></table></figure><p><strong>2020/1/10更</strong></p></li><li><h3 id="动态开辟二维数组"><a href="#动态开辟二维数组" class="headerlink" title="动态开辟二维数组"></a>动态开辟二维数组</h3><ul><li><p>已知二维数组列数，未知行数。假设建立一个n行4列的动态数组（列已知）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DynamicCreate2Array</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">int</span>(*p)[<span class="number">4</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">4</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; p[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[] p;         <span class="comment">//动态数组使用完一定要释放</span></span><br></pre></td></tr></table></figure></li><li><p>二维数组行数、列数均未知</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DynamicCreate2Array</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> row, column;</span><br><span class="line"><span class="keyword">char</span> **p = <span class="keyword">new</span> <span class="keyword">char</span>*[row];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = <span class="keyword">new</span> <span class="keyword">char</span>[column];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; column; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; p[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//动态数组释放</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] p[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[]p;</span><br></pre></td></tr></table></figure><p>例：机器人走迷宫</p><p>迷宫由N W S E组成，踩到N向上走一格，踩到W向左走一格，踩到S向下走一格，踩到E向右走一格。</p><p>输入迷宫行数、列数、机器人开始的初试列数（不大于10，列数从1开始数），判断能否走出迷宫。能走出输出步数，不能走出输出”NO”，多组输入，遇 0 0 0 结束输入。</p><p>例：</p><p>输入：</p><p>4 5 6</p><p>NNNNSN</p><p>NNNSWN</p><p>NNSWNN</p><p>NSWNNN</p><p>3 6 2</p><p>NSNNNN</p><p>NSWNNN</p><p>NENNNN</p><p>0 0 0</p><p>输出：</p><p>7</p><p>No</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*----机器人走迷宫----*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> row, column, <span class="built_in">begin</span>, <span class="built_in">step</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; row &gt;&gt; column &gt;&gt; <span class="built_in">begin</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (row == <span class="number">0</span> &amp;&amp; column == <span class="number">0</span> &amp;&amp; <span class="built_in">begin</span> == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">step</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> **p = <span class="keyword">new</span> <span class="keyword">char</span>*[row];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">&#123;</span><br><span class="line">p[i] = <span class="keyword">new</span> <span class="keyword">char</span>[column];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; column; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; p[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="built_in">begin</span> - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; row &amp;&amp; i &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (j &lt; column &amp;&amp; j &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (p[i][j] == <span class="string">'N'</span>)</span><br><span class="line">&#123;</span><br><span class="line">p[i][j] = <span class="string">'0'</span>;</span><br><span class="line"><span class="built_in">step</span>++;</span><br><span class="line">i--;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p[i][j] == <span class="string">'S'</span>)</span><br><span class="line">&#123;</span><br><span class="line">p[i][j] = <span class="string">'0'</span>;</span><br><span class="line"><span class="built_in">step</span>++;</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">break</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p[i][j] == <span class="string">'W'</span>)</span><br><span class="line">&#123;</span><br><span class="line">p[i][j] = <span class="string">'0'</span>;</span><br><span class="line">j--;</span><br><span class="line"><span class="built_in">step</span>++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p[i][j] == <span class="string">'E'</span>)</span><br><span class="line">&#123;</span><br><span class="line">p[i][j] = <span class="string">'0'</span>;</span><br><span class="line">j++;</span><br><span class="line"><span class="built_in">step</span>++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">step</span> = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">step</span> == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">step</span> != <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">step</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"No"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span>[] p[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[]p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">```</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 动态数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 100天</title>
      <link href="/2019/11/02/Python-100-days/"/>
      <url>/2019/11/02/Python-100-days/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="【程序1】"><a href="#【程序1】" class="headerlink" title="【程序1】"></a>【程序1】</h3><p>题目：有1、2、3、4个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python函数存储在模块中的函数调用</title>
      <link href="/2019/10/04/Python-function-call-and-module/"/>
      <url>/2019/10/04/Python-function-call-and-module/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>python中常见将函数存储在被称为模块的独立文件中，再将模块导入到主程序中，import语句实现当前运行的程序文件中导入模块中的代码。</p><p>要让函数是可导入的，得先创建模块。模块是扩展名为.py的文件，包含要导入到程序中的代码。</p><a id="more"></a><h2 id="1-导入整个模块"><a href="#1-导入整个模块" class="headerlink" title="1.导入整个模块"></a>1.导入整个模块</h2><p>语法规则：</p><p>module_name.function_name()</p><h2 id="2-导入特定的函数"><a href="#2-导入特定的函数" class="headerlink" title="2.导入特定的函数"></a>2.导入特定的函数</h2><p>语法规则：</p><p>from module_name import function_name</p><p>通过用逗号分隔函数名，可根据需要从模块中导入任意数量的函数：</p><p>from module_name import function_0, function_1, function_2</p><h2 id="3-使用as给函数指定别名"><a href="#3-使用as给函数指定别名" class="headerlink" title="3.使用as给函数指定别名"></a>3.使用as给函数指定别名</h2><p>语法规则：</p><p>from module_name import function_name as fn</p><h2 id="4-使用as给模块指定别名"><a href="#4-使用as给模块指定别名" class="headerlink" title="4.使用as给模块指定别名"></a>4.使用as给模块指定别名</h2><p>语法规则：</p><p>import module_name as mn</p><h2 id="5-导入模块中的所有函数"><a href="#5-导入模块中的所有函数" class="headerlink" title="5.导入模块中的所有函数"></a>5.导入模块中的所有函数</h2><p>语法规则：</p><p>from module_name import * </p><p>（不建议使用此方法）</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 函数调用 </tag>
            
            <tag> 模块 </tag>
            
            <tag> import </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux socket通信编程</title>
      <link href="/2019/07/01/Linux-socket-communication-programming/"/>
      <url>/2019/07/01/Linux-socket-communication-programming/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>示例：用C语言，基于linux提供的socket函数，编写一个实现“从客户端输入十个字符串，在服务器端完成字符数和单词数统计，并按首位字母排序”的远程计算的网络服务程序。 </p><a id="more"></a><h3 id="1、UDP编程说明"><a href="#1、UDP编程说明" class="headerlink" title="1、UDP编程说明"></a>1、UDP编程说明</h3><p>UDP协议的服务器端流程：</p><p>(1)建立套接字文件描述符，使用函数socket()，生成套接字文件描述符。</p><p>(2)设置服务器地址和侦听端口，初始化要绑定的网络地址结构。</p><p>(3)绑定侦听端口，使用bind()函数，将套接字文件描述符和一个地址类型变量进行绑定。</p><p>(4)接收客户端的数据，使用recvfrom()函数接收客户端的网络数据。</p><p>(5)向客户端发送数据，使用sendto()函数向服务器主机发送数据。</p><p>(6)关闭套接字，使用close()函数释放资源。UDP协议的客户端流程</p><p>UDP协议的客户端流程：</p><p>(1)建立套接字文件描述符，socket()；</p><p>(2)设置服务器地址和端口，struct sockaddr；</p><p>(3)向服务器发送数据，sendto()；</p><p>(4)接收服务器的数据，recvfrom()；</p><p>(5)关闭套接字，close()。</p><p><img src="/loading.gif" data-original="https://i.loli.net/2019/12/31/kU7i4GObXKWndrw.png" alt="UDP编程流程"></p><h3 id="2、相关函数"><a href="#2、相关函数" class="headerlink" title="2、相关函数"></a>2、相关函数</h3><p>(1)  int socket(AF_INET, SOCK_DGRAM, 0);</p><p>创建udp socket，返回套接字描述符，UDP协议建立套接字的方式同TCP方式一样，使用socket()函数，只不过协议的类型使用SOCK_DGRAM，而不是SOCK_STREAM。</p><p>(2) int sendto(int sockfd, const void <em>data, int data_len, unsigned int flags, struct sockaddr </em>remaddr,sock_lenremaddr_len)</p><p>功能：基于UDP发送数据报，返回实际发送的数据长度，出错时返回－1</p><p>参数说明：</p><p>sockfd:套接字描述符</p><p>data:指向要发送数据的指针</p><p>data_len:数据长度</p><p>flags:通常为0</p><p>remaddr:远端地址：IP地址和端口号</p><p>remaddr_len:地址长度</p><p>(3) int recvfrom(int sockfd, void <em>buf,int buf_len,unsigned int flags,struct sockaddr </em>from,sock_len *fromlen);</p><p>功能：从UDP接收数据，返回实际接收的字节数，失败时返回－1</p><p>参数说明：</p><p>Sockfd:套接字描述符</p><p>buf:指向内存块的指针</p><p>buf_len:内存块大小，以字节为单位</p><p>flags:一般为0</p><p>from:远端的地址，IP地址和端口号</p><p>fromlen:远端地址长度</p><h3 id="3、程序编写"><a href="#3、程序编写" class="headerlink" title="3、程序编写"></a>3、程序编写</h3><p>(1) 用C语言编写客户端程序，创建一个socket通信，从客户端输入十个字符串。</p><p>(2) 编译客户端程序生成可执行文件</p><p>输入命令：gcc client1.c -o client1</p><p>​              ./client1</p><p><img src="/loading.gif" data-original="https://i.loli.net/2019/12/31/nDbKUhktrEle2AM.png" alt="编译客户端程序"></p><p>(3) 用C语言编写服务器端程序，绑定客户端通信，接收从客户端输入的十个字符串，显示在屏幕上，并统计输入的字符串中总的单词数和字符数，并按首位字母的ASCII码值从高到低进行排列，输出显示到屏幕。</p><p>(4) 编译服务器端程序生成可执行文件</p><p>输入命令：gcc server1.c -o server1</p><p>​              ./server1</p><p><img src="/loading.gif" data-original="https://i.loli.net/2019/12/31/P57M3ksLFhqHdyK.png" alt="编译服务器端程序"></p><h3 id="4、程序运行效果"><a href="#4、程序运行效果" class="headerlink" title="4、程序运行效果"></a>4、程序运行效果</h3><p>(1) 客户端输入十个字符串。</p><p>注：输入10个字符串时每行代表1个字符串，10字符串10行，由于字符串的输入是由 fgets() 函数实现的，所以获取字符串的时候会将空格符和换行符也进行保存，这点在后面进行总字符数的统计时也体现了出来，获取的字符串由结构体sendbuf[10]进行存储。</p><p><img src="/loading.gif" data-original="https://i.loli.net/2019/12/31/HqKkpUYsr7o6OVA.png" alt="客户端运行效果"></p><p>(2) 服务器端接收数据，显示在屏幕上，并统计输入的字符串中总的单词数和字符数，并按首位字母的ASCII码值从高到低进行排列，输出显示到屏幕。</p><p>注：统计总单词数相当于统计总空格数，空格数+1即为总单词数，字符数的统计结果包括了每个字符串的空格和换行符，每个字符串都有一个换行符，如图9，可以看到得到的总字符数85中包含了所有的空格符和换行符。利用冒泡排序，直接比较输入的10个字符串的首字母，实现字符串按首字母ASCII码值从大到小排列。</p><p><img src="/loading.gif" data-original="https://i.loli.net/2019/12/31/ezErBTlbW7FoQSx.png" alt="服务器端运行效果"></p><h3 id="5、字符串排序说明"><a href="#5、字符串排序说明" class="headerlink" title="5、字符串排序说明"></a>5、字符串排序说明</h3><p>(1) 实现将10个字符串按首字母的ASCII码值从高到低进行排列并依次输出显示在屏幕上。</p><p>功能实现：输入的10个字符串设置结构体sendbuf[10]保存，再服务器端设置结构体recvbuf[10]接收数据，利用冒泡排序，先将每个字符串的首字母取出来，将其值赋给服务端接收缓冲区结构体的recvbuf[i].init成员（专门用于存储字符串的首字母），再直接比较recvbuf[i].init成员值的ASCII码值大小，实现从高到底排列并输出到屏幕上。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; <span class="number">10</span>; n++)</span><br><span class="line">​    &#123;</span><br><span class="line">​        <span class="keyword">int</span> k = n;</span><br><span class="line">​        <span class="keyword">for</span> (<span class="keyword">int</span> m = n + <span class="number">1</span>; m &lt; <span class="number">10</span>; m++)</span><br><span class="line">​        &#123;</span><br><span class="line">​            <span class="keyword">if</span> (recvbuf[k].init &lt; recvbuf[m].init)</span><br><span class="line">​                k = m;</span><br><span class="line">​        &#125;</span><br><span class="line">​        <span class="keyword">if</span> (k != n)</span><br><span class="line">​        &#123;</span><br><span class="line">​            temp = recvbuf[n];</span><br><span class="line">​            recvbuf[n] = recvbuf[k];</span><br><span class="line">​            recvbuf[k] = temp;</span><br><span class="line">​        &#125;</span><br><span class="line">​    &#125;</span><br><span class="line">​    <span class="built_in">printf</span>(<span class="string">"字符串按首字母ASCII码值从大到小排列为：\n"</span>);</span><br><span class="line">​    <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; <span class="number">10</span>; n++)</span><br><span class="line">​    &#123;</span><br><span class="line">​        <span class="built_in">printf</span>(<span class="string">"%s"</span>, recvbuf[n].string_client);</span><br><span class="line">​    &#125;</span><br></pre></td></tr></table></figure><h3 id="6、完整客户端、服务器端程序代码"><a href="#6、完整客户端、服务器端程序代码" class="headerlink" title="6、完整客户端、服务器端程序代码"></a>6、完整客户端、服务器端程序代码</h3><p>客户端程序源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">define</span> MYPORT 8886</span></span><br><span class="line"><span class="keyword">char</span>* SERVERIP = <span class="string">"127.0.0.1"</span>;</span><br><span class="line">\<span class="meta">#<span class="meta-keyword">define</span> ERR_EXIT(m) \</span></span><br><span class="line">​    <span class="keyword">do</span> \</span><br><span class="line">&#123; \</span><br><span class="line">​    perror(m); \</span><br><span class="line">​    <span class="built_in">exit</span>(EXIT_FAILURE); \</span><br><span class="line">​    &#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">echo_cli</span><span class="params">(<span class="keyword">int</span> sock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">​    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">​    <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">​    servaddr.sin_family = AF_INET;</span><br><span class="line">​    servaddr.sin_port = htons(MYPORT);</span><br><span class="line">​    servaddr.sin_addr.s_addr = inet_addr(SERVERIP);</span><br><span class="line">​    <span class="keyword">int</span> ret;</span><br><span class="line">​    <span class="class"><span class="keyword">struct</span> <span class="title">client</span></span></span><br><span class="line"><span class="class">​    &#123;</span></span><br><span class="line">​        <span class="keyword">char</span> string_client[<span class="number">100</span>];</span><br><span class="line">​    &#125;sendbuf[<span class="number">10</span>];</span><br><span class="line">​    <span class="class"><span class="keyword">struct</span> <span class="title">server</span></span></span><br><span class="line"><span class="class">​    &#123;</span></span><br><span class="line">​        <span class="keyword">char</span> string_client[<span class="number">100</span>];</span><br><span class="line">​    &#125;recvbuf[<span class="number">10</span>];</span><br><span class="line">​    <span class="comment">//struct client temp;</span></span><br><span class="line">​    <span class="comment">//struct server temp;</span></span><br><span class="line">​    <span class="keyword">int</span> i;</span><br><span class="line">​    <span class="built_in">printf</span>(<span class="string">"请输入10字符串：\n"</span>);</span><br><span class="line">​    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">​    &#123;</span><br><span class="line">​        fgets(sendbuf[i].string_client,<span class="number">100</span>,<span class="built_in">stdin</span>);</span><br><span class="line">​    &#125;</span><br><span class="line">​    <span class="built_in">printf</span>(<span class="string">"向服务器发送：\n"</span>);</span><br><span class="line">​    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">​    &#123;</span><br><span class="line">​        <span class="built_in">printf</span>(<span class="string">"%s"</span>, sendbuf[i].string_client);</span><br><span class="line">​        sendto(sock, sendbuf[i].string_client, <span class="built_in">strlen</span>(sendbuf[i].string_client), <span class="number">0</span>, (struct sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">​        <span class="built_in">memset</span>(sendbuf, <span class="number">0</span>, <span class="keyword">sizeof</span>(sendbuf[i].string_client));</span><br><span class="line">​    &#125;</span><br><span class="line">​    <span class="built_in">close</span>(sock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">​    <span class="keyword">int</span> sock;</span><br><span class="line">​    <span class="keyword">if</span> ((sock = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">​        ERR_EXIT(<span class="string">"socket"</span>);</span><br><span class="line">​    echo_cli(sock);</span><br><span class="line">​    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器端程序源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">define</span> MYPORT 8886</span></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">define</span> ERR_EXIT(m) \</span></span><br><span class="line">​    <span class="keyword">do</span> &#123; \</span><br><span class="line">​    perror(m); \</span><br><span class="line">​    <span class="built_in">exit</span>(EXIT_FAILURE); \</span><br><span class="line">​    &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">echo_ser</span><span class="params">(<span class="keyword">int</span> sock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">​    <span class="comment">//char recvbuf[1024] = &#123;0&#125;;</span></span><br><span class="line">​    <span class="class"><span class="keyword">struct</span> <span class="title">server</span></span></span><br><span class="line"><span class="class">​    &#123;</span></span><br><span class="line">​        <span class="keyword">char</span> string_client[<span class="number">100</span>];</span><br><span class="line">​        <span class="keyword">char</span> init;</span><br><span class="line">​    &#125;recvbuf[<span class="number">10</span>];</span><br><span class="line">​    <span class="class"><span class="keyword">struct</span> <span class="title">server</span> <span class="title">temp</span>;</span></span><br><span class="line">​    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">peeraddr</span>;</span></span><br><span class="line">​    <span class="keyword">socklen_t</span> peerlen;</span><br><span class="line">​    <span class="keyword">int</span> n;</span><br><span class="line">​    <span class="keyword">int</span> i, nword=<span class="number">0</span>, nchar=<span class="number">0</span>;</span><br><span class="line">​    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">​    &#123;       </span><br><span class="line">​        peerlen = <span class="keyword">sizeof</span>(peeraddr);</span><br><span class="line">​        <span class="built_in">memset</span>(recvbuf[i].string_client, <span class="number">0</span>, <span class="keyword">sizeof</span>(recvbuf[i].string_client));</span><br><span class="line">​        n = recvfrom(sock, recvbuf[i].string_client, <span class="keyword">sizeof</span>(recvbuf[i].string_client), <span class="number">0</span>,</span><br><span class="line">​                     (struct sockaddr *)&amp;peeraddr, &amp;peerlen);</span><br><span class="line">​        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">​        &#123;            </span><br><span class="line">​            <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">​                <span class="keyword">continue</span>;          </span><br><span class="line">​            ERR_EXIT(<span class="string">"recvfrom error"</span>);</span><br><span class="line">​        &#125;</span><br><span class="line">​        <span class="keyword">else</span> <span class="keyword">if</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">​        &#123;</span><br><span class="line">​            <span class="built_in">printf</span>(<span class="string">"接收到的数据：%s"</span>,recvbuf[i].string_client);</span><br><span class="line">​            <span class="comment">//printf("%s",recvbuf[i].string_client);</span></span><br><span class="line">​            <span class="comment">//sendto(sock, recvbuf, n, 0,</span></span><br><span class="line">​            <span class="comment">//       (struct sockaddr *)&amp;peeraddr, peerlen);</span></span><br><span class="line">​            <span class="comment">//printf("回送的数据：%s\n",recvbuf[i].string_client);</span></span><br><span class="line">​        &#125;</span><br><span class="line">​    &#125;</span><br><span class="line">​    <span class="keyword">int</span> numWhiteSpace = <span class="number">0</span>;</span><br><span class="line">​    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">​    <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; <span class="number">10</span>; n++)</span><br><span class="line">​    &#123;</span><br><span class="line">​        <span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line">​        <span class="built_in">strcpy</span>(str, recvbuf[n].string_client);</span><br><span class="line">​        <span class="comment">//printf("字符串：%s\n", str);</span></span><br><span class="line">​        recvbuf[n].init = str[<span class="number">0</span>];</span><br><span class="line">​        <span class="keyword">while</span> (<span class="string">'\0'</span> != str[j])</span><br><span class="line">​        &#123;</span><br><span class="line">​            <span class="keyword">if</span> (<span class="string">' '</span> == str[j])&#123;</span><br><span class="line">​                ++numWhiteSpace;   <span class="comment">//空格数</span></span><br><span class="line">​            &#125;</span><br><span class="line">​            ++j; <span class="comment">//字符数</span></span><br><span class="line">​        &#125;</span><br><span class="line">​        nchar = j + nchar;</span><br><span class="line">​        nword = numWhiteSpace + <span class="number">1</span>+nword;</span><br><span class="line">​        j = <span class="number">0</span>;</span><br><span class="line">​        numWhiteSpace = <span class="number">0</span>;</span><br><span class="line">​    &#125;</span><br><span class="line">​    <span class="built_in">printf</span>(<span class="string">"输入字符串的总单词数：%d\n"</span>, nword);</span><br><span class="line">​    <span class="built_in">printf</span>(<span class="string">"输入字符串的总字符数（包括空格、换行符）：%d\n"</span>, nchar); </span><br><span class="line">​    <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; <span class="number">10</span>; n++)</span><br><span class="line">​    &#123;</span><br><span class="line">​        <span class="keyword">int</span> k = n;</span><br><span class="line">​        <span class="keyword">for</span> (<span class="keyword">int</span> m = n + <span class="number">1</span>; m &lt; <span class="number">10</span>; m++)</span><br><span class="line">​        &#123;</span><br><span class="line">​            <span class="keyword">if</span> (recvbuf[k].init &lt; recvbuf[m].init)</span><br><span class="line">​                k = m;</span><br><span class="line">​        &#125;</span><br><span class="line">​        <span class="keyword">if</span> (k != n)</span><br><span class="line">​        &#123;</span><br><span class="line">​            temp = recvbuf[n];</span><br><span class="line">​            recvbuf[n] = recvbuf[k];</span><br><span class="line">​            recvbuf[k] = temp;</span><br><span class="line">​        &#125;</span><br><span class="line">​    &#125;</span><br><span class="line">​    <span class="built_in">printf</span>(<span class="string">"字符串按首字母ASCII码值从大到小排列为：\n"</span>);</span><br><span class="line">​    <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; <span class="number">10</span>; n++)</span><br><span class="line">​    &#123;</span><br><span class="line">​        <span class="built_in">printf</span>(<span class="string">"%s"</span>, recvbuf[n].string_client);</span><br><span class="line">​    &#125;</span><br><span class="line">​    <span class="built_in">close</span>(sock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">​    <span class="keyword">int</span> sock;</span><br><span class="line">​    <span class="keyword">if</span> ((sock = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">​        ERR_EXIT(<span class="string">"socket error"</span>);</span><br><span class="line">​    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">​    <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">​    servaddr.sin_family = AF_INET;</span><br><span class="line">​    servaddr.sin_port = htons(MYPORT);</span><br><span class="line">​    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);  </span><br><span class="line">​    <span class="built_in">printf</span>(<span class="string">"监听%d端口\n"</span>,MYPORT);</span><br><span class="line">​    <span class="keyword">if</span> (bind(sock, (struct sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr)) &lt; <span class="number">0</span>)</span><br><span class="line">​        ERR_EXIT(<span class="string">"bind error"</span>);   </span><br><span class="line">​    echo_ser(sock);  </span><br><span class="line">​    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> socket通信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务器基础知识与配置</title>
      <link href="/2019/06/10/Server-basics-and-configuration/"/>
      <url>/2019/06/10/Server-basics-and-configuration/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>1、什么是守护进程？守护进程的类型和作用有哪些？</p><p>Linux 服务器在启动时需要启动很多系统服务，它们向本地和网络用户提供了Linux的系统功能接口，直接面向应用程序和用户。提供这些服务的程序是由运行在后台的守护进程来执行的。守护进程是生存期长的一种进程。它们独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件。他们常常在系统引导装入时启动，在系统关闭时终止。linux系统有很多守护进程，大多数服务器都是用守护进程实现的。同时，守护进程完成许多系统任务，比如，作业规划进程crond、打印进程lqd等。</p><a id="more"></a><p>根据守护进程的启动和管理方式，可以分为独立启动守护进程和超级守护进程两类：</p><p>独立启动（stand_alone):该类进程启动后就常驻内存，所以会一直占用系统资源。其最大的优点就是它会一直启动，当外界有要求时相应速度较快，像httpd等进程。</p><p>超级守护进程：系统启动时由一个统一的守护进程xinet来负责管理一些进程，当相应请求到来时需要通过xinet的转接才可以唤醒被xinet管理的进 程。这种进程的优点时最初只有xinet这一守护进程占有系统资源，其他的内部服务并不一直占有系统资源，只有数据包到来时才会被xinet管理员来唤醒。并且我们还可以通过xinet来对它所管理的进程设置一些访问权限，相当于多了一层管理机制。</p><p>2.linux的init进程是怎样的进程？细说init和linux上的各服务进程之间的关系？</p><p>init是Linux系统操作中不可缺少的程序之一。所谓的init进程，它是一个由内核启动的用户级进程。内核自行启动（已经被载入内存，开始运行，并已初始化所有的设备驱动程序和数据结构等）之后，就通过启动一个用户级程序init的方式，完成引导进程。</p><p>所以,init始终是第一个进程（其进程编号始终为1）。内核会在过去曾使用过init的几个地方查找它，它的正确位置（对Linux系统来说）是/sbin/init。如果内核找不到init，它就会试着运行/bin/sh，如果运行失败，系统的启动也会失败。</p><p>init进程由0进程创建，完成系统的初始化，是系统中所有其他用户进程的祖先进程。</p><p>3.Apache服务器的配置文件httpd.conf中有很多内容，请解释如下配置项：</p><p>（1）MaxKeepAliveRequests 200 </p><p>允许每次连接的最大请求数目，此为200。</p><p>（2）UserDir public_html</p><p>设定用户放置网页的目录。</p><p>（3）DefaultType text/plain </p><p>设置服务器对于不认识的文件类型的预设格式。</p><p>（4）AddLanguare en.en</p><p>设置可传送语言的文件给浏览器。</p><p>（5）DocumentRoot“/usr/local/httpd/htdocs”</p><p>该目录为Apache放置网页的地方。</p><p>（6）AddType application/x-httpd-php.php.php.php4</p><p>服务器选择使用php4。</p><p>（7）port 1080 </p><p>将apache服务器的端口号设定为1080。</p><p>（8）UserDir userdoc</p><p>设定用户网页目录为userdoc。</p><p>（9）DocumentRoot “/home/htdocs”</p><p>设定apache服务器的网页根目录:/home/htdocs。</p><p>（10）Options Indexes FollowSymLinks   AllowOverride None </p><p>Order deny,allow     deny from all     allow from 192.168.1.5</p><p>在此apache服务器上设定一个目录/home/htdocs/inside，且此目录只允许IP地址为192.168.1.5的主机访问。</p><p>（11）Server Type Standlone</p><p>定义apache服务器以独立进程的方式运行。</p><p>4.什么是Apache的虚拟主机？其作用是什么？Apache虚拟主机实现方法有哪些？</p><p>Apache是开源的web服务软件之一，也是现在开源系统比如centos上安装web服务常见软件；虚拟主机是提供网站服务的集成环境，比如：linux Apache+php+mysq、LAMP。就是常说的建站开通的虚拟空间，所以Apache服务器只是虚拟空间的一种架构。在一个Apache服务器上可以配置多个虚拟主机，实现一个服务器提供多站点服务，其实就是访问同一个服务器上的不同目录。</p><p>Apache虚拟主机的配置方式主要有三种，即基于IP、基于port、以及基于域名。</p><p>5.简述使用ftp进行文件传输时的两种登录方式？它们的区别是什么？常用的ftp文件传输命令有哪些？</p><p>ftp有两种登录方式：匿名登录和授权登录。使用匿名登录时，用户名为：anonymous，密码为：任何合法email地址；使用授权登录时，用户名为用户在远程系统中的用户帐号，密码为用户在远程系统中的用户密码。</p><p>区别：使用匿名登录只能访问ftp目录下的资源，默认配置下只能下载；而授权登录访问的权限大于匿名登录，且上载、下载均可。</p><p>ftp文件传输有两种文件传输模式：ASCII模式和二进制数据模式。ASCII模式用来传输文本文件，其他文件的传输使用binary模式。</p><p>常用的ftp文件传输命令为：bin、asc、put、get、mput、mget、prompt、bye。</p>]]></content>
      
      
      <categories>
          
          <category> Linux 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 编程实例</title>
      <link href="/2019/06/03/Linux-programming-examples/"/>
      <url>/2019/06/03/Linux-programming-examples/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>示例：用C语言编写一个从键盘输入10名学生的姓名、性别、学号和家庭住址，然后按照学号排序，并将排序后的结果在屏幕上按对齐的方式打印输出的程序。</p><a id="more"></a><p>C语言排序程序源码 (学号按从高到低排序)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//输入10名学生的姓名，性别，学号，家庭住址；</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line">​    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">char</span> sex[<span class="number">4</span>];  </span><br><span class="line"></span><br><span class="line">​    <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">char</span> address[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">&#125;info[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">​    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">temp</span>;</span></span><br><span class="line"></span><br><span class="line">​    <span class="keyword">int</span> i,j, k;</span><br><span class="line"></span><br><span class="line">​    <span class="built_in">printf</span>(<span class="string">"请输入10个学生的信息:姓名、性别、学号、家庭住址\n"</span>);</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​       <span class="comment">//printf("请输入第%d位学生的信息:姓名、性别、学号、家庭住址\n", i + 1);</span></span><br><span class="line"></span><br><span class="line">​       <span class="built_in">scanf</span>(<span class="string">"%s%s%d%s"</span>, info[i].name, &amp;info[i].sex, &amp;info[i].id, &amp;info[i].address);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​       k = i;</span><br><span class="line"></span><br><span class="line">​       <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line"></span><br><span class="line">​       &#123;</span><br><span class="line"></span><br><span class="line">​              <span class="keyword">if</span> (info[k].id &lt; info[j].id)</span><br><span class="line"></span><br><span class="line">​                     k = j;</span><br><span class="line"></span><br><span class="line">​       &#125;</span><br><span class="line"></span><br><span class="line">​       <span class="keyword">if</span> (k != i)</span><br><span class="line"></span><br><span class="line">​       &#123;</span><br><span class="line"></span><br><span class="line">​              temp = info[i];</span><br><span class="line"></span><br><span class="line">​              info[i] = info[k];</span><br><span class="line"></span><br><span class="line">​              info[k] = temp;</span><br><span class="line"></span><br><span class="line">​       &#125;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    <span class="built_in">printf</span>(<span class="string">"10个学生的信息按序号由高到低排序为\n"</span>);</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​       <span class="built_in">printf</span>(<span class="string">"%s\t%s\t%d\t%s\n"</span>, info[i].name, info[i].sex, info[i].id, info[i].address);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象语言的缺点和问题</title>
      <link href="/2019/01/01/Disadvantages-and-problems-of-object-oriented-languages/"/>
      <url>/2019/01/01/Disadvantages-and-problems-of-object-oriented-languages/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>面向对象编程是一种计算机编程架构。面向对象编程的一条基本原则是计算机程序是由单个能够起到子程序作用的单元或对象组合而成。面向对象编程达到了软件工程的三个主要目标：重用性、灵活性和扩展性。为了实现整体运算，每个对象都能够接收信息、处理数据和向其它对象发送信息。</p><a id="more"></a><p>刚开始学习C++ 时，我们首先了解到的就是面向对象语言的四个基本特征：抽象、继承、封装、多态、以及一大堆面向对象语言的优点包括代码重用，权限控制，易扩展，开发效率高之类的。毫无疑问面向对象编程的出现使人们的编程与实际的世界更加接近，所有的对象被赋予属性和方法，结果编程就更加富有人性化，但同时面向对象语言从诞生之日起就一直伴随着许多的缺陷。 </p><h3 id="1、运行速度慢"><a href="#1、运行速度慢" class="headerlink" title="1、运行速度慢"></a>1、运行速度慢</h3><p>就 C++ 而言，由于面向更高的逻辑抽象层，使得 C++ 在实现的时候，不得不做出性能上面的牺牲，有时候甚至是致命的 ( 所有对象的属性都经过内置多重指针的间接引用是其性能损失的主要原因之一)。<br>在计算机速度飞速发展的今天，你可能会说，一丁点的性能牺牲没什么大不了。是的，从面向对象的角度，使的编程的结构更加清晰完整，数据更加独立和易于管理，性能的牺牲可以带来这么多的好处，没有理由不做稳赚的生意吧？<br>不过，在某些对速度要求极高特殊场合，例如你做的是电信的交换系统，每秒钟有超过百万的人同时进行电话交换，如果，每一个数据交换过程都是一个对象，那么总的性能损失将是天文数字！！<br>或者这个例子不够贴身，再举个例子吧。假如你受聘于一个游戏设计公司，老板希望做出来的游戏可以更多的兼顾到更多的电脑使用者，游戏每秒钟的运行的帧可以 更多，子弹和爆炸物可以更多、更华丽。那么，你会发现使用 C++ 会使你的程序变得笨拙，无法满足你的需求。</p><h3 id="2、继承的代价庞大，增加了代码量"><a href="#2、继承的代价庞大，增加了代码量" class="headerlink" title="2、继承的代价庞大，增加了代码量"></a>2、继承的代价庞大，增加了代码量</h3><p>对于面向过程语言来说，编程时需要哪些变量和方法就只编写这些变量和方法，而对于面向对象语言来说，每次无论你要使用什么都要先写一个类，并且每一个类都要有独立的变量和方法，这样就会造成可能很简单的问题也要很多的类代码，为了解决这个缺点，继承便出现了，继承可以让类与类可以共享代码，获得代码的可重用性，一定程度上降低了代码量。但是，随着继承层次的增加，代码的复杂性会加速增长，随之而来的bug也会越来越难以发现。</p><h3 id="3、对象与对象之间相互依赖，耦合性太高"><a href="#3、对象与对象之间相互依赖，耦合性太高" class="headerlink" title="3、对象与对象之间相互依赖，耦合性太高"></a>3、对象与对象之间相互依赖，耦合性太高</h3><p>由于面向对象语言中一切都是对象，我们必须使用一个对象去创建另外一个对象，才能使用其内部方法，这样就造成了这些对象之间相互依赖，为了消除这些依赖，我们可以把创建对象的代码全部集中到一个对象之中，其他的对象都通过调用该对象的方法来动态的获取所需要的对象，这也就是我们所说的工厂模式。进一步地，我们可以不使用工厂，而是编写一个插件，该插件可以把我们所需要的对象在运行时动态地“塞”给我们，这就是依赖注入，也就是控制反转。这个插件就相当于Spring IOC。</p><h3 id="4、失去了灵活性"><a href="#4、失去了灵活性" class="headerlink" title="4、失去了灵活性"></a>4、失去了灵活性</h3><p>面向对象语言代码都很死板，继承也没有运行时动态，但是java的多态机制，其不同于面向过程语言的方法后期绑定，在运行时才能确定具体调用的是哪个方法一定程度上增加了其灵活性。面向对象语言一直提倡的组合大于继承的思想诞生了许许多多的设计模式，这些设计模式通过对组合和多态的奇妙运用大大的增加了面向对象语言的灵活性。</p><h3 id="5、需要一定的软件支持环境"><a href="#5、需要一定的软件支持环境" class="headerlink" title="5、需要一定的软件支持环境"></a>5、需要一定的软件支持环境</h3><p>面向对象方法学把分析、设计和实现很自然地联系在一起了。虽然面向对象设计原则上不依赖于特定的实现环境，但是实现结果和实现成本却在很大程度上取决于实现环境。因此，直接支持面向对象设计范式的面向对象程序语言、开发环境及类库，对于面向对象实现来说是非常重要的。<br>综上所述，其实在我们的学习过程中可以看到面向对象语言有许多优秀的地方，但也有一些缺陷，而我们一直都在努力地想尽各种办法去弥补这些缺陷，通过一些机制让面向对象语言越来越来趋于完善。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔/杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 程序设计语言原理 </tag>
            
            <tag> 面向对象 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>入坑</title>
      <link href="/2017/02/01/Begin-Hexo/"/>
      <url>/2017/02/01/Begin-Hexo/</url>
      
        <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Welcome to my blog, enter password to read.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="6f243a2e385d84d5ccc11900fcb31266158822ebce9a6a801ddb57f32c6608e4">d0d703fa332139beb12ceb85f23df7fc2dd2ad6c1e2d88c79a07ca82a4c752383c4b274b70abf24c2627b91511ca38c6827a85fb24bb1d405ef366f63d449475cc7e7021b2f42aea7973805ef690a099be12a8caa2ffdf6dbc9f6212144592fad5a584f16d9cbcc534663cce7d13c5205693b5799467cdca4f31b1eb3da117c4464e9d65e8d2ea086423bfac557b55b88f807ccf0b25016324b2051db850900f99f12708a26a6549e44778d76c46ce31d1a6d64c5e9d8db63da0630457acc014c67941c9a3f8ca646afc155801e88b3509b175e7ac010b442778b88935322dc16758351f90281084ecfd1b06f21cb5a1c4e1255c460c67ea328840963b1ad7b1f852cafe5fdc6953ede3c0673d806bfabe27886bcda6e231bc5cd1f5cb677b296f51da1bb1989bfaa6cf0b0660f35891bbd99b26a0896e78d57842dee264d016baceb99e3f13092237c93684670c6e88cfff33da6d7349a6cf40be699e8284ef10b4eb241453682469c77ad2f090a4e373b2180742907a573045ec4249741ead90025684de14d2c211fe00e6607198734334ea439dae591f201d9490b798cbfd6d3587ac9b9ad81396def3061e6a23e6c7f9ccdbb7275a2809aef139d0a9c9778d50c2180804a2063d7974f0290a762bdb2f9ab0a607f00dc611f48b6c45ad7a18fb4b0531aafa273afa651a226af26f05b880027af884671dec90c608d7654df07ed93288cb5ef405b58fd5836a91aeba11d07a72696ca368791b14474e45a25ee9c4d515f02b78b4bff644290ac0cffe4cf1ef6c1dd1e44107ebabe897fe81d6288a1a427bae0728eead5416c712ebadf1518b2d30149d7e0dc4b75fecb6994f618f69f0c2c45338af3e35f7cf2e3acbba3222363f11403d04e2fbd73ea3ed57170c8a5d1038d5d9c2b314a05e4b2793aa3cec2ed7e22ef6ea5bcef5b4121fc3b2383c08c835fa47d03ba9715ccbe2eb07d83a91eca74a3ef651e17c1f55e1</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> github </tag>
            
            <tag> npm </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2017/02/01/hello-world/"/>
      <url>/2017/02/01/hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> github </tag>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
