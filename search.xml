<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>matplotlib函数汇总</title>
      <link href="/2020/11/28/Matplotlib-function/"/>
      <url>/2020/11/28/Matplotlib-function/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="matplotlib函数汇总"><a href="#matplotlib函数汇总" class="headerlink" title="matplotlib函数汇总"></a>matplotlib函数汇总</h2><a id="more"></a><iframe border=2 frameborder=0 width=1000 height=900 marginheight=0 marginwidth=0 scrolling=no src="https://www.wulihub.com.cn/gc/WzOlXg/index.html"></iframe>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> matplotlib </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>朴素贝叶斯算法原理及实现</title>
      <link href="/2020/11/10/Naive-bayes/"/>
      <url>/2020/11/10/Naive-bayes/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="一、贝叶斯算法原理"><a href="#一、贝叶斯算法原理" class="headerlink" title="一、贝叶斯算法原理"></a>一、贝叶斯算法原理</h2><h3 id="1-条件概率公式"><a href="#1-条件概率公式" class="headerlink" title="1.条件概率公式"></a>1.条件概率公式</h3><p>根据文氏图，可以看到在事件B发生的情况下，事件A发生的概率为：</p><a id="more"></a><p><a href="https://www.codecogs.com/eqnedit.php?latex=P(A|B)=\frac{P(A\cap&space;B)}{P(B)}" target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?P(A|B)=\frac{P(A\cap&space;B)}{P(B)}" title="P(A|B)=\frac{P(A\cap B)}{P(B)}" /></a>，其中<a href="https://www.codecogs.com/eqnedit.php?latex=P(A\cap&space;B)" target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?P(A\cap&space;B)" title="P(A\cap B)" /></a>又可写为<a href="https://www.codecogs.com/eqnedit.php?latex=P(AB)" target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?P(AB)" title="P(AB)" /></a></p><p>因此：<a href="https://www.codecogs.com/eqnedit.php?latex=P(A\cap&space;B)=P(A|B){P(B)}" target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?P(A\cap&space;B)=P(A|B){P(B)}" title="P(A\cap B)=P(A|B){P(B)}" /></a></p><p>同理又有：<a href="https://www.codecogs.com/eqnedit.php?latex=P(A\cap&space;B)=P(B|A){P(A)}" target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?P(A\cap&space;B)=P(B|A){P(A)}" title="P(A\cap B)=P(B|A){P(A)}" /></a></p><p>所以：<a href="https://www.codecogs.com/eqnedit.php?latex=P(B|A){P(A)}=P(A|B){P(B)}" target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?P(B|A){P(A)}=P(A|B){P(B)}" title="P(B|A){P(A)}=P(A|B){P(B)}" /></a>，<a href="https://www.codecogs.com/eqnedit.php?latex=P(A\cap&space;B)" target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?P(A\cap&space;B)" title="P(A\cap B)" /></a>称为联合概率。</p><p><a href="https://www.codecogs.com/eqnedit.php?latex=P(A|B)=\frac{P(B|A)P(A)}{P(B)}" target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?P(A|B)=\frac{P(B|A)P(A)}{P(B)}" title="P(A|B)=\frac{P(B|A)P(A)}{P(B)}" /></a></p><p>即为条件概率公式。</p><p><a href="https://imgchr.com/i/BbzL3F" target="_blank" rel="noopener"><img src="/loading.gif" data-original="https://s1.ax1x.com/2020/11/10/BbzL3F.jpg" alt=""></a></p><h3 id="2-全概率公式"><a href="#2-全概率公式" class="headerlink" title="2.全概率公式"></a>2.全概率公式</h3><p>如果事件B1，B2，B3，…，Bn 构成一个完备事件组，即它们两两互不相容，其和为全集；并且P(Bi)大于0，则对任一事件A有：</p><p><a href="https://www.codecogs.com/eqnedit.php?latex=P(A)=P(A|B_{1})\*P(B_{1})&space;&plus;&space;P(A|B_{2})\*P(B_{2})&space;&plus;&space;...&space;&plus;&space;P(A|B_{n})\*P(B_{n})" target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?P(A)=P(A|B_{1})\*P(B_{1})&space;&plus;&space;P(A|B_{2})\*P(B_{2})&space;&plus;&space;...&space;&plus;&space;P(A|B_{n})\*P(B_{n})" title="P(A)=P(A|B_{1})\*P(B_{1}) + P(A|B_{2})\*P(B_{2}) + ... + P(A|B_{n})\*P(B_{n})" /></a></p><h3 id="3-贝叶斯定理"><a href="#3-贝叶斯定理" class="headerlink" title="3.贝叶斯定理"></a>3.贝叶斯定理</h3><p>贝叶斯定理是关于随机事件A和B的条件概率（或边缘概率）的一则定理。其中P(A|B)是在B发生的情况下A发生的可能性。</p><p><a href="https://www.codecogs.com/eqnedit.php?latex=P(A|B)=\frac{P(B|A)P(A)}{P(B)}" target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?P(A|B)=\frac{P(B|A)P(A)}{P(B)}" title="P(A|B)=\frac{P(B|A)P(A)}{P(B)}" /></a></p><p>举个例子：一个鸢尾花数据有四个特征，其特征分别为：sepal length、sepal width、petal length、petal width，三个类别，分别为：Iris Setosa、Iris Versicolour、Iris Virginica，现在有一组鸢尾花数据：5.5，2.6，4.4，1.2，判断此鸢尾花属于哪种。</p><p>由贝叶斯定理我们可以计算此条件下属于各个类别的概率，</p><p><a href="https://www.codecogs.com/eqnedit.php?latex=P(setosa|sepallen*sepalwid*petallen*petalwid)=\frac{P(sepallen*sepalwid*petallen*petalwid|setosa)}{P(sepallen*sepalwid*petallen*petalwid)}" target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?P(setosa|sepallen*sepalwid*petallen*petalwid)=\frac{P(sepallen*sepalwid*petallen*petalwid|setosa)}{P(sepallen*sepalwid*petallen*petalwid)}" title="P(setosa|sepallen*sepalwid*petallen*petalwid)=\frac{P(sepallen*sepalwid*petallen*petalwid|setosa)}{P(sepallen*sepalwid*petallen*petalwid)}" /></a></p><p>同理，依次可以计算属于类别 Versicolour、Virginica的概率。概率最大的类别即为最有可能的鸢尾花类别。</p><p>但是，可以看到<a href="https://www.codecogs.com/eqnedit.php?latex=P(sepallen*sepalwid*petallen*petalwid|setosa)" target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?P(sepallen*sepalwid*petallen*petalwid|setosa)" title="P(sepallen*sepalwid*petallen*petalwid|setosa)" /></a>并不好计算，此时，我们可以将鸢尾花数据的四个特征看作相互独立（即朴素贝叶斯的核心），所以有：</p><p><a href="https://www.codecogs.com/eqnedit.php?latex=P(sepallen*sepalwid*petallen*petalwid|setosa)" target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?P(sepallen*sepalwid*petallen*petalwid|setosa)" title="P(sepallen*sepalwid*petallen*petalwid|setosa)" /></a> = <a href="https://www.codecogs.com/eqnedit.php?latex=P(sepallen|setosa)*P(sepalwid|setosa)*P(petallen|setosa)*P(petalwid|setosa)" target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?P(sepallen|setosa)*P(sepalwid|setosa)*P(petallen|setosa)*P(petalwid|setosa)" title="P(sepallen|setosa)*P(sepalwid|setosa)*P(petallen|setosa)*P(petalwid|setosa)" /></a></p><p>此时我们只需要计算<a href="https://www.codecogs.com/eqnedit.php?latex=P(sepallen|setosa)" target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?P(sepallen|setosa)" title="P(sepallen|setosa)" /></a>等单个特征值概率即可。</p><h3 id="4-高斯分布"><a href="#4-高斯分布" class="headerlink" title="4.高斯分布"></a>4.高斯分布</h3><p>上述例子中，sepal length、sepal width、petal length、petal width等特征均为连续变量，<a href="https://www.codecogs.com/eqnedit.php?latex=P(sepallen|setosa)" target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?P(sepallen|setosa)" title="P(sepallen|setosa)" /></a>该如何计算？我们可以假设在<strong>setosa</strong>的条件下，<strong>sepallen</strong>服从高斯分布（正态分布）。根据正态分布的概率密度函数即可计算出<a href="https://www.codecogs.com/eqnedit.php?latex=P(sepallen|setosa)" target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?P(sepallen|setosa)" title="P(sepallen|setosa)" /></a>，公式如下：<a href="https://www.codecogs.com/eqnedit.php?latex=P(x)=\frac{1}{\sqrt{2\pi&space;\sigma&space;^{2}}}e^{-\frac{(x-\mu&space;)^{2}}{2\sigma&space;^{2}}}" target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?P(x)=\frac{1}{\sqrt{2\pi&space;\sigma&space;^{2}}}e^{-\frac{(x-\mu&space;)^{2}}{2\sigma&space;^{2}}}" title="P(x)=\frac{1}{\sqrt{2\pi \sigma ^{2}}}e^{-\frac{(x-\mu )^{2}}{2\sigma ^{2}}}" /></a></p><h2 id="二、朴素贝叶斯处理过程"><a href="#二、朴素贝叶斯处理过程" class="headerlink" title="二、朴素贝叶斯处理过程"></a>二、朴素贝叶斯处理过程</h2><ul><li><p>加载数据：原始数据集载入</p></li><li><p>分类数据：根据贝叶斯定理对数据进行分类</p></li><li><p>训练算法：计算不同的独立特征的条件概率</p></li><li><p>测试算法：计算正确率</p></li><li><p>使用算法：数据分类</p><p><a href="https://imgchr.com/i/BXcu5t" target="_blank" rel="noopener"><img src="/loading.gif" data-original="https://s1.ax1x.com/2020/11/11/BXcu5t.png" alt=""></a></p></li></ul><h2 id="三、朴素贝叶斯分类实现"><a href="#三、朴素贝叶斯分类实现" class="headerlink" title="三、朴素贝叶斯分类实现"></a>三、朴素贝叶斯分类实现</h2><h3 id="1-数据集说明"><a href="#1-数据集说明" class="headerlink" title="1.数据集说明"></a>1.数据集说明</h3><p>朴素贝叶斯分类实现鸢尾花数据分类，数据集来源：<a href="https://archive.ics.uci.edu/ml/datasets/iris。算法实现之前，按照8：2的比例将原始数据集分为训练数据集和测试数据集，原始数据集中每个类别抽取10个样本组成一个总共30个样本的测试数据集。" target="_blank" rel="noopener">https://archive.ics.uci.edu/ml/datasets/iris。算法实现之前，按照8：2的比例将原始数据集分为训练数据集和测试数据集，原始数据集中每个类别抽取10个样本组成一个总共30个样本的测试数据集。</a></p><p>数据集说明：</p><blockquote><p>Attribute Information:</p><ol><li>sepal length in cm</li><li>sepal width in cm</li><li>petal length in cm</li><li>petal width in cm</li><li>class:<br>— Iris Setosa<br>— Iris Versicolour<br>— Iris Virginica</li></ol></blockquote><h3 id="2-加载数据集"><a href="#2-加载数据集" class="headerlink" title="2.加载数据集"></a>2.加载数据集</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    iris数据集载入</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_data</span><span class="params">(file)</span>:</span></span><br><span class="line">    x_data=[]</span><br><span class="line">    y_data=[]</span><br><span class="line">    data=[]</span><br><span class="line">    <span class="keyword">with</span> open(file,<span class="string">'r'</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        lines=fp.readlines()</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">            line=line.strip().split(<span class="string">','</span>)</span><br><span class="line">            x_data.append(line[:<span class="number">-1</span>])</span><br><span class="line">            y_data.append((line[<span class="number">-1</span>]))</span><br><span class="line">            data.append(line)</span><br><span class="line">    <span class="keyword">return</span> x_data,y_data,data</span><br></pre></td></tr></table></figure><h3 id="3-计算训练集均值"><a href="#3-计算训练集均值" class="headerlink" title="3.计算训练集均值"></a>3.计算训练集均值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_mean</span><span class="params">(x,lable)</span>:</span></span><br><span class="line">    <span class="comment">#获取每个类别的均值</span></span><br><span class="line">    means=[]</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        sum=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">120</span>):</span><br><span class="line">            <span class="keyword">if</span> (lable==x[i,<span class="number">4</span>]):</span><br><span class="line">                sum+=float(x[i,j])</span><br><span class="line">        means.append(sum/<span class="number">40</span>)</span><br><span class="line">    <span class="keyword">return</span> means</span><br></pre></td></tr></table></figure><p>4.计算训练集方差</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_var</span><span class="params">(x,mean,label)</span>:</span></span><br><span class="line">    <span class="comment">#获取每个类别的方差</span></span><br><span class="line">    vars=[]</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        sum=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">120</span>):</span><br><span class="line">            <span class="keyword">if</span> (label==x[i,<span class="number">4</span>]):</span><br><span class="line">                sum+=(float(x[i,j])-mean[j])**<span class="number">2</span></span><br><span class="line">        vars.append(sum/<span class="number">40</span>)</span><br><span class="line">    <span class="keyword">return</span> vars</span><br></pre></td></tr></table></figure><h3 id="5-计算先验概率"><a href="#5-计算先验概率" class="headerlink" title="5.计算先验概率"></a>5.计算先验概率</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_prior</span><span class="params">(x,label)</span>:</span></span><br><span class="line">    <span class="comment">#获取每个类别的先验概率</span></span><br><span class="line">    cnt=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(x)):</span><br><span class="line">        <span class="keyword">if</span> (label==x[i,<span class="number">4</span>]):</span><br><span class="line">            cnt+=<span class="number">1</span></span><br><span class="line">    prior=cnt/len(x)</span><br><span class="line">    <span class="keyword">return</span> prior</span><br></pre></td></tr></table></figure><h3 id="6-计算后验概率"><a href="#6-计算后验概率" class="headerlink" title="6.计算后验概率"></a>6.计算后验概率</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_postpro</span><span class="params">(mean,var,xi)</span>:</span></span><br><span class="line">    <span class="comment">#获取每个类别的后验概率</span></span><br><span class="line">    p=(<span class="number">1</span>/np.sqrt(<span class="number">2</span>*math.pi*var))*np.exp(-((float(xi)-mean)**<span class="number">2</span>)/(<span class="number">2</span>*var))</span><br><span class="line">    <span class="keyword">return</span> p</span><br></pre></td></tr></table></figure><h3 id="7-计算似然度"><a href="#7-计算似然度" class="headerlink" title="7.计算似然度"></a>7.计算似然度</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_likelihood</span><span class="params">(mean,var,x)</span>:</span></span><br><span class="line">    <span class="comment">#根据后验概率计算似然度</span></span><br><span class="line">    p=<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        p=get_postpro(mean[i],var[i],x[i])</span><br><span class="line">        p*=p</span><br><span class="line">    <span class="keyword">return</span> p</span><br></pre></td></tr></table></figure><h3 id="8-训练模型"><a href="#8-训练模型" class="headerlink" title="8.训练模型"></a>8.训练模型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fit_model</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="comment">#训练模型</span></span><br><span class="line">    mean_set=get_mean(x,<span class="string">'Iris-setosa'</span>)</span><br><span class="line">    mean_ver=get_mean(x,<span class="string">'Iris-versicolor'</span>)</span><br><span class="line">    mean_vir=get_mean(x,<span class="string">'Iris-virginica'</span>)</span><br><span class="line">    var_set=get_var(x,mean_set,<span class="string">'Iris-setosa'</span>)</span><br><span class="line">    var_ver=get_var(x,mean_ver,<span class="string">'Iris-versicolor'</span>)</span><br><span class="line">    var_vir=get_var(x,mean_vir,<span class="string">'Iris-virginica'</span>)</span><br><span class="line">    <span class="keyword">return</span> mean_set,mean_ver,mean_vir,var_set,var_ver,var_vir</span><br></pre></td></tr></table></figure><h3 id="9-预测类别"><a href="#9-预测类别" class="headerlink" title="9.预测类别"></a>9.预测类别</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="comment">#预测类别</span></span><br><span class="line">    proba=[]</span><br><span class="line">    mean_set,mean_ver,mean_vir,var_set,var_ver,var_vir=fit_model(X_train)</span><br><span class="line">    p1=get_likelihood(mean_set,var_set,x[:<span class="number">-1</span>])</span><br><span class="line">    p2=get_likelihood(mean_ver,var_ver, x[:<span class="number">-1</span>])</span><br><span class="line">    p3=get_likelihood(mean_vir,var_vir, x[:<span class="number">-1</span>])</span><br><span class="line">    proba.append(p1)</span><br><span class="line">    proba.append(p2)</span><br><span class="line">    proba.append(p3)</span><br><span class="line">    sort=np.argmax(proba)</span><br><span class="line">    <span class="keyword">return</span> sort</span><br></pre></td></tr></table></figure><h3 id="10-效果评估"><a href="#10-效果评估" class="headerlink" title="10.效果评估"></a>10.效果评估</h3><p>对于运算结果，在此只截取了一部分，可以看到总准确率为100%，朴素贝叶斯得到的各个类别的相对概率值差别很大，结果显而易见。这个结果并不能说明朴素贝叶斯的分类效果特别好，只是这个鸢尾花测试数据集数据太理想，没有一点误差，数据集很干净。</p><p><a href="https://imgchr.com/i/BqqQAS" target="_blank" rel="noopener"><img src="/loading.gif" data-original="https://s1.ax1x.com/2020/11/10/BqqQAS.md.png" alt=""></a></p><p>通过散点图同时展示该测试数据集的四个不同维度：图中的(x, y)位置代表每个样本的花萼的长度和宽度（sepal length、sepal width），散点的大小代表每个样本的花瓣的长度（petal length），而散点的颜色代表一种特定的鸢尾花类型。</p><p><a href="https://imgchr.com/i/BX61B9" target="_blank" rel="noopener"><img src="/loading.gif" data-original="https://s1.ax1x.com/2020/11/11/BX61B9.png" alt=""></a></p><h2 id="四、附录"><a href="#四、附录" class="headerlink" title="四、附录"></a>四、附录</h2><p>load_data.py文件，实现数据载入。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    iris数据集载入</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_data</span><span class="params">(file)</span>:</span></span><br><span class="line">    x_data=[]</span><br><span class="line">    y_data=[]</span><br><span class="line">    data=[]</span><br><span class="line">    <span class="keyword">with</span> open(file,<span class="string">'r'</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        lines=fp.readlines()</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">            line=line.strip().split(<span class="string">','</span>)</span><br><span class="line">            x_data.append(line[:<span class="number">-1</span>])</span><br><span class="line">            y_data.append((line[<span class="number">-1</span>]))</span><br><span class="line">            data.append(line)</span><br><span class="line">    <span class="keyword">return</span> x_data,y_data,data</span><br></pre></td></tr></table></figure><p>naive_bayes.py文件，实现贝叶斯模型训练，测试数据集分类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">from</span> load_data <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_mean</span><span class="params">(x,lable)</span>:</span></span><br><span class="line">    <span class="comment">#获取每个类别的均值</span></span><br><span class="line">    means=[]</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        sum=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">120</span>):</span><br><span class="line">            <span class="keyword">if</span> (lable==x[i,<span class="number">4</span>]):</span><br><span class="line">                sum+=float(x[i,j])</span><br><span class="line">        means.append(sum/<span class="number">40</span>)</span><br><span class="line">    <span class="keyword">return</span> means</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_var</span><span class="params">(x,mean,label)</span>:</span></span><br><span class="line">    <span class="comment">#获取每个类别的方差</span></span><br><span class="line">    vars=[]</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        sum=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">120</span>):</span><br><span class="line">            <span class="keyword">if</span> (label==x[i,<span class="number">4</span>]):</span><br><span class="line">                sum+=(float(x[i,j])-mean[j])**<span class="number">2</span></span><br><span class="line">        vars.append(sum/<span class="number">40</span>)</span><br><span class="line">    <span class="keyword">return</span> vars</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_prior</span><span class="params">(x,label)</span>:</span></span><br><span class="line">    <span class="comment">#获取每个类别的先验概率</span></span><br><span class="line">    cnt=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(x)):</span><br><span class="line">        <span class="keyword">if</span> (label==x[i,<span class="number">4</span>]):</span><br><span class="line">            cnt+=<span class="number">1</span></span><br><span class="line">    prior=cnt/len(x)</span><br><span class="line">    <span class="keyword">return</span> prior</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_postpro</span><span class="params">(mean,var,xi)</span>:</span></span><br><span class="line">    <span class="comment">#获取每个类别的后验概率</span></span><br><span class="line">    p=(<span class="number">1</span>/np.sqrt(<span class="number">2</span>*math.pi*var))*np.exp(-((float(xi)-mean)**<span class="number">2</span>)/(<span class="number">2</span>*var))</span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_likelihood</span><span class="params">(mean,var,x)</span>:</span></span><br><span class="line">    <span class="comment">#根据后验概率计算似然度</span></span><br><span class="line">    p=<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        p=get_postpro(mean[i],var[i],x[i])</span><br><span class="line">        p*=p</span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fit_model</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="comment">#训练模型</span></span><br><span class="line">    mean_set=get_mean(x,<span class="string">'Iris-setosa'</span>)</span><br><span class="line">    mean_ver=get_mean(x,<span class="string">'Iris-versicolor'</span>)</span><br><span class="line">    mean_vir=get_mean(x,<span class="string">'Iris-virginica'</span>)</span><br><span class="line">    var_set=get_var(x,mean_set,<span class="string">'Iris-setosa'</span>)</span><br><span class="line">    var_ver=get_var(x,mean_ver,<span class="string">'Iris-versicolor'</span>)</span><br><span class="line">    var_vir=get_var(x,mean_vir,<span class="string">'Iris-virginica'</span>)</span><br><span class="line">    <span class="keyword">return</span> mean_set,mean_ver,mean_vir,var_set,var_ver,var_vir</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="comment">#预测类别</span></span><br><span class="line">    proba=[]</span><br><span class="line">    mean_set, mean_ver, mean_vir, var_set, var_ver, var_vir = fit_model(X_train)</span><br><span class="line">    p1=get_likelihood(mean_set,var_set,x[:<span class="number">-1</span>])</span><br><span class="line">    p2=get_likelihood(mean_ver, var_ver, x[:<span class="number">-1</span>])</span><br><span class="line">    p3=get_likelihood(mean_vir, var_vir, x[:<span class="number">-1</span>])</span><br><span class="line">    proba.append(p1)</span><br><span class="line">    proba.append(p2)</span><br><span class="line">    proba.append(p3)</span><br><span class="line">    print(<span class="string">'proba is '</span>,proba)</span><br><span class="line">    sort=np.argmax(proba)</span><br><span class="line">    <span class="keyword">return</span> sort</span><br><span class="line"></span><br><span class="line">file1=<span class="string">'C:\\Users\\wnxy\\PycharmProjects\\NaiveBayesian\\iris_data\\iris_train.data'</span></span><br><span class="line">file2=<span class="string">'C:\\Users\\wnxy\\PycharmProjects\\NaiveBayesian\\iris_data\\iris_test.data'</span></span><br><span class="line">x_train_data,y_train_data,x_train=load_data(file1)</span><br><span class="line">X_train_data=np.mat(x_train_data)</span><br><span class="line">Y_train_data=np.mat(y_train_data)</span><br><span class="line">X_train=np.mat(x_train)</span><br><span class="line">mean_set,mean_ver,mean_vir,var_set,var_ver,var_vir=fit_model(X_train)</span><br><span class="line">prior_set=get_prior(X_train,<span class="string">'Iris-setosa'</span>)</span><br><span class="line">prior_ver=get_prior(X_train,<span class="string">'Iris-versicolor'</span>)</span><br><span class="line">prior_vir=get_prior(X_train,<span class="string">'Iris-virginica'</span>)</span><br><span class="line">print(<span class="string">'prior_set'</span>,prior_set)</span><br><span class="line">cnt = <span class="number">0</span></span><br><span class="line"><span class="keyword">with</span> open(file2,<span class="string">'r'</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    x_test=[]</span><br><span class="line">    lines=fp.readlines()</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        line = line.strip().split(<span class="string">','</span>)</span><br><span class="line">        x_test.append(line)</span><br><span class="line">        sort=predict(x_test[<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">if</span> (x_test[<span class="number">-1</span>][<span class="number">4</span>]==<span class="string">'Iris-setosa'</span>):</span><br><span class="line">            y_test=<span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> (x_test[<span class="number">-1</span>][<span class="number">4</span>]==<span class="string">'Iris-versicolor'</span>):</span><br><span class="line">            y_test=<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            y_test=<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> (y_test==sort):</span><br><span class="line">            cnt+=<span class="number">1</span></span><br><span class="line">        print(<span class="string">'The prediction is classified as: '</span>,sort)</span><br><span class="line">        print(<span class="string">'The fact is classified as: '</span>, y_test)</span><br><span class="line">print(<span class="string">'Accuracy is: '</span>,cnt/len(lines))</span><br><span class="line">y_test=np.array(y_test)</span><br><span class="line">seplen = []</span><br><span class="line">sepwid = []</span><br><span class="line">petlen = []</span><br><span class="line">petwid = []</span><br><span class="line">colors=[<span class="string">'purple'</span>,<span class="string">'y'</span>,<span class="string">'b'</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">30</span>):</span><br><span class="line">    seplen.append(x_test[i][<span class="number">0</span>])</span><br><span class="line">    sepwid.append(x_test[i][<span class="number">1</span>])</span><br><span class="line">    petlen.append(x_test[i][<span class="number">2</span>])</span><br><span class="line">    petwid.append(x_test[i][<span class="number">3</span>])</span><br><span class="line">    index=y_test[i]</span><br><span class="line">    plt.scatter(float(seplen[i]), float(sepwid[i]), alpha=<span class="number">0.2</span>, s=<span class="number">100</span>*float(petlen[i]), c=colors[index], cmap=<span class="string">'viridis'</span>)</span><br><span class="line">plt.ylim(<span class="number">2.0</span>,<span class="number">4.0</span>)</span><br><span class="line">plt.title(<span class="string">'Iris Data Classification'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'sepal length in cm'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'sepal width in cm'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> = 学习笔记 - Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Machine-Learning </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 朴素贝叶斯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据可视化模块Matplotlib实操</title>
      <link href="/2020/11/02/Data-visualization-matplotlib/"/>
      <url>/2020/11/02/Data-visualization-matplotlib/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>通过 Matplotlib，开发者可以仅需要几行代码，便可以生成绘图，直方图，功率谱，条形图，错误图，散点图等。</p><h1 id="导读"><a href="#导读" class="headerlink" title="导读"></a><strong>导读</strong></h1><p>Matplotlib 是一个 Python 的 2D绘图库，它以各种硬拷贝格式和跨平台的交互式环境生成出版质量级别的图形。通过 Matplotlib，开发者可以仅需要几行代码，便可以生成绘图，直方图，功率谱，条形图，错误图，散点图等。</p><a id="more"></a><p>以下内容来自Github，为《PythonDataScienceHandbook[1]》(Python 数据科学手册[2])第四章Matplotlib介绍部分。全部内容都在以下环境演示通过：</p><ul><li>numpy:1.18.5</li><li>pandas:1.0.5</li><li>matplotlib:3.2.1</li></ul><blockquote><p>文章转自微信公众号：<strong>DataWhale</strong></p><p>如有侵权，联系删除！</p></blockquote><h1 id="1-简单的折线图"><a href="#1-简单的折线图" class="headerlink" title="1.简单的折线图"></a><strong>1.简单的折线图</strong></h1><p>对于图表来说，最简单的莫过于作出一个单一函数  的图像。本节中我们首先来介绍创建这种类型图表。本节和后续小节中，我们都会使用下面的代码将我们需要的包载入到 notebook 中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.style.use(<span class="string">'seaborn-whitegrid'</span>)</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><p>对于所有的 Matplotlib 图表来说，我们都需要从创建图形和维度开始。图形和维度可以使用下面代码进行最简形式的创建：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fig = plt.figure()</span><br><span class="line">ax = plt.axes()</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102223923.png" alt=""></p><p>在 Matplotlib 中，图形（类plt.Figure的一个实例）可以被认为是一个包括所有维度、图像、文本和标签对象的容器。维度（类plt.Axes的一个实例）就是你上面看到的图像，一个有边界的格子包括刻度和标签，最终还有我们画在上面的图表元素。在本书中，我们会使用变量名fig来指代图形对象，以及变量名ax来指代维度变量。</p><p>一旦我们创建了维度，我们可以使用ax.plot方法将数据绘制在图表上。下面是一个简单的正弦函数图形：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fig = plt.figure()</span><br><span class="line">ax = plt.axes()</span><br><span class="line"></span><br><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">10</span>, <span class="number">1000</span>)</span><br><span class="line">ax.plot(x, np.sin(x));</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102223854.png" alt=""></p><p>同样的，我们可以使用 pylab 接口（MATLAB 风格的接口）帮我们在后台自动创建这两个对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(x, np.sin(x));</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102223854.png" alt=""></p><p>如果我们需要在同一幅图形中绘制多根线条，只需要多次调用<code>plot</code>函数即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(x, np.sin(x))</span><br><span class="line">plt.plot(x, np.cos(x));</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102223933.png" alt=""></p><p>这就是在 Matplotlib 中绘制简单函数图像的所有接口了。下面我们深入了解一下控制坐标轴和线条外观的细节。</p><h2 id="调整折线图：线条颜色和风格"><a href="#调整折线图：线条颜色和风格" class="headerlink" title="调整折线图：线条颜色和风格"></a><strong>调整折线图：线条颜色和风格</strong></h2><p>你可能第一个想到需要进行调整的部分就是线条的颜色和风格。plt.plot()函数接受额外的参数可以用来指定它们。通过指定color关键字参数可以调整颜色，这个字符串类型参数基本上能用来代表任何你能想到的颜色。可以通过多种方式指定颜色参数：</p><p>所有 HTML 颜色名称可以在这里[3]找到。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(x, np.sin(x - <span class="number">0</span>), color=<span class="string">'blue'</span>)        <span class="comment"># 通过颜色名称指定</span></span><br><span class="line">plt.plot(x, np.sin(x - <span class="number">1</span>), color=<span class="string">'g'</span>)           <span class="comment"># 通过颜色简写名称指定(rgbcmyk)</span></span><br><span class="line">plt.plot(x, np.sin(x - <span class="number">2</span>), color=<span class="string">'0.75'</span>)        <span class="comment"># 介于0-1之间的灰阶值</span></span><br><span class="line">plt.plot(x, np.sin(x - <span class="number">3</span>), color=<span class="string">'#FFDD44'</span>)     <span class="comment"># 16进制的RRGGBB值</span></span><br><span class="line">plt.plot(x, np.sin(x - <span class="number">4</span>), color=(<span class="number">1.0</span>,<span class="number">0.2</span>,<span class="number">0.3</span>)) <span class="comment"># RGB元组的颜色值，每个值介于0-1</span></span><br><span class="line">plt.plot(x, np.sin(x - <span class="number">5</span>), color=<span class="string">'chartreuse'</span>); <span class="comment"># 能支持所有HTML颜色名称值</span></span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102223938.png" alt=""></p><p>如果没有指定颜色，Matplotlib 会在一组默认颜色值中循环使用来绘制每一条线条。</p><p>类似的，通过linestyle关键字参数可以指定线条的风格：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(x, x + <span class="number">0</span>, linestyle=<span class="string">'solid'</span>)</span><br><span class="line">plt.plot(x, x + <span class="number">1</span>, linestyle=<span class="string">'dashed'</span>)</span><br><span class="line">plt.plot(x, x + <span class="number">2</span>, linestyle=<span class="string">'dashdot'</span>)</span><br><span class="line">plt.plot(x, x + <span class="number">3</span>, linestyle=<span class="string">'dotted'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 还可以用形象的符号代表线条风格</span></span><br><span class="line">plt.plot(x, x + <span class="number">4</span>, linestyle=<span class="string">'-'</span>)  <span class="comment"># 实线</span></span><br><span class="line">plt.plot(x, x + <span class="number">5</span>, linestyle=<span class="string">'--'</span>) <span class="comment"># 虚线</span></span><br><span class="line">plt.plot(x, x + <span class="number">6</span>, linestyle=<span class="string">'-.'</span>) <span class="comment"># 长短点虚线</span></span><br><span class="line">plt.plot(x, x + <span class="number">7</span>, linestyle=<span class="string">':'</span>);  <span class="comment"># 点线</span></span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102223941.png" alt=""></p><p>如果你喜欢更简洁的代码，这些linestyle和color参数能够合并成一个非关键字参数，传递给plt.plot()函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(x, x + <span class="number">0</span>, <span class="string">'-g'</span>)  <span class="comment"># 绿色实线</span></span><br><span class="line">plt.plot(x, x + <span class="number">1</span>, <span class="string">'--c'</span>) <span class="comment"># 天青色虚线</span></span><br><span class="line">plt.plot(x, x + <span class="number">2</span>, <span class="string">'-.k'</span>) <span class="comment"># 黑色长短点虚线</span></span><br><span class="line">plt.plot(x, x + <span class="number">3</span>, <span class="string">':r'</span>);  <span class="comment"># 红色点线</span></span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102223945.png" alt=""></p><p>上面的单字母颜色码是 RGB 颜色系统以及 CMYK 颜色系统的缩写，被广泛应用在数字化图像的颜色系统中。</p><p>还有很多其他的关键字参数可以对折线图的外观进行精细调整；可以通过在 IPython 中使用帮助工具查看plt.plot()函数的文档来获得更多细节内容。</p><h2 id="调整折线图：坐标轴范围"><a href="#调整折线图：坐标轴范围" class="headerlink" title="调整折线图：坐标轴范围"></a><strong>调整折线图：坐标轴范围</strong></h2><p>Matplotlib 会自动选择非常合适的坐标轴范围来绘制你的图像，但是有些情况下你也需要自己进行相关调整。使用plt.xlim()和plt.ylim()函数可以调整坐标轴的范围：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(x, np.sin(x))</span><br><span class="line"></span><br><span class="line">plt.xlim(<span class="number">-1</span>, <span class="number">11</span>)</span><br><span class="line">plt.ylim(<span class="number">-1.5</span>, <span class="number">1.5</span>);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102223949.png" alt=""></p><p>如果某些情况下你希望将坐标轴反向，你可以通过上面的函数实现，将参数顺序颠倒即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(x, np.sin(x))</span><br><span class="line"></span><br><span class="line">plt.xlim(<span class="number">10</span>, <span class="number">0</span>)</span><br><span class="line">plt.ylim(<span class="number">1.2</span>, <span class="number">-1.2</span>);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102223953.png" alt=""></p><p>相关的函数还有plt.axis()（注意：这不是plt.axes()函数，函数名称是 i 而不是 e）。这个函数可以在一个函数调用中就完成 x 轴和 y 轴范围的设置，传递一个[xmin, xmax, ymin, ymax]的列表参数即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(x, np.sin(x))</span><br><span class="line">plt.axis([<span class="number">-1</span>, <span class="number">11</span>, <span class="number">-1.5</span>, <span class="number">1.5</span>]);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102223955.png" alt=""></p><p>当然plt.axis()函数不仅能设置范围，还能像下面代码一样将坐标轴压缩到刚好足够绘制折线图像的大小：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(x, np.sin(x))</span><br><span class="line">plt.axis(<span class="string">'tight'</span>);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102223958.png" alt=""></p><p>还可以通过设置’equal’参数设置x轴与y轴使用相同的长度单位：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(x, np.sin(x))</span><br><span class="line">plt.axis(<span class="string">'equal'</span>);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224002.jpg" alt=""></p><p>更多关于设置 axis 属性的内容请查阅plt.axis函数的文档字符串。</p><h2 id="折线图标签"><a href="#折线图标签" class="headerlink" title="折线图标签"></a><strong>折线图标签</strong></h2><p>本节最后介绍一下在折线图上绘制标签：标题、坐标轴标签和简单的图例。</p><p>标题和坐标轴标签是最简单的这类标签，Matplotlib 提供了函数用来方便的设置它们：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(x, np.sin(x))</span><br><span class="line">plt.title(<span class="string">"A Sine Curve"</span>)</span><br><span class="line">plt.xlabel(<span class="string">"x"</span>)</span><br><span class="line">plt.ylabel(<span class="string">"sin(x)"</span>);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224134.png" alt=""></p><p>这些标签的位置、大小和风格可以通过上面函数的可选参数进行设置。参阅 Matplotlib 在线文档和这些函数的文档字符串可以获得更多的信息。</p><p>当一幅图中绘制了多条折线时，如果能够绘制一个线条对应的图例能让图表更加清晰。Matplotlib 也内建了函数来快速创建图例。估计你也猜到了，通过plt.legend()函数可以实现这个需求。虽然有很多种正确的方法来指定图例，作者认为最简单的方法是通过在绘制每条线条时指定对应的label关键字参数来使用这个函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(x, np.sin(x), <span class="string">'-g'</span>, label=<span class="string">'sin(x)'</span>)</span><br><span class="line">plt.plot(x, np.cos(x), <span class="string">':b'</span>, label=<span class="string">'cos(x)'</span>)</span><br><span class="line">plt.axis(<span class="string">'equal'</span>)</span><br><span class="line"></span><br><span class="line">plt.legend();</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224138.png" alt=""></p><p>上图可见，plt.legend()函数绘制的图例线条与图中的折线无论风格和颜色都保持一致。查阅plt.legend文档字符串可以获得更多相关信息；我们在[自定义图表图例]一节中也会讨论更高级的图例应用。</p><h2 id="额外内容：Matplotlib-的坑"><a href="#额外内容：Matplotlib-的坑" class="headerlink" title="额外内容：Matplotlib 的坑"></a><strong>额外内容：Matplotlib 的坑</strong></h2><p>虽然大多数的plt函数都可以直接转换为ax的方法进行调用（例如plt.plot() → ax.plot()，plt.legend() → ax.legend()等），但是并不是所有的命令都能应用这种情况。特别是用于设置极值、标签和标题的函数都有一定的改变。下表列出了将 MATLAB 风格的函数转换为面向对象的方法的区别：</p><ul><li>plt.xlabel() → ax.set_xlabel()</li><li>plt.ylabel() → ax.set_ylabel()</li><li>plt.xlim() → ax.set_xlim()</li><li>plt.ylim() → ax.set_ylim()</li><li>plt.title() → ax.set_title()</li></ul><p>在面向对象接口中，与其逐个调用上面的方法来设置属性，更常见的使用ax.set()方法来一次性设置所有的属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ax = plt.axes()</span><br><span class="line">ax.plot(x, np.sin(x))</span><br><span class="line">ax.set(xlim=(<span class="number">0</span>, <span class="number">10</span>), ylim=(<span class="number">-2</span>, <span class="number">2</span>),</span><br><span class="line">       xlabel=<span class="string">'x'</span>, ylabel=<span class="string">'sin(x)'</span>,</span><br><span class="line">       title=<span class="string">'A Simple Plot'</span>);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224143.png" alt=""></p><h1 id="2-简单散点图"><a href="#2-简单散点图" class="headerlink" title="2.简单散点图"></a><strong>2.简单散点图</strong></h1><p>另一种常用的图表类型是简单散点图，它是折线图的近亲。不像折线图，图中的点连接起来组成连线，散点图中的点都是独立分布的点状、圆圈或其他形状。本节开始我们也是首先将需要用到的图表工具和函数导入到 notebook 中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.style.use(<span class="string">'seaborn-whitegrid'</span>)</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><h2 id="使用-plt-plot-绘制散点图"><a href="#使用-plt-plot-绘制散点图" class="headerlink" title="使用 plt.plot 绘制散点图"></a><strong>使用 plt.plot 绘制散点图</strong></h2><p>在上一节中，我们介绍了plt.plot/ax.plot方法绘制折线图。这两个方法也可以同样用来绘制散点图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">10</span>, <span class="number">30</span>)</span><br><span class="line">y = np.sin(x)</span><br><span class="line"></span><br><span class="line">plt.plot(x, y, <span class="string">'o'</span>, color=<span class="string">'black'</span>);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224148.png" alt=""></p><p>传递给函数的第三个参数是使用一个字符代表的图表绘制点的类型。就像你可以使用’-‘或’—‘来控制线条的风格那样，点的类型风格也可以使用短字符串代码来表示。所有可用的符号可以通过plt.plot文档或 Matplotlib 在线文档进行查阅。大多数的代码都是非常直观的，我们使用下面的例子可以展示那些最通用的符号：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rng = np.random.RandomState(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> marker <span class="keyword">in</span> [<span class="string">'o'</span>, <span class="string">'.'</span>, <span class="string">','</span>, <span class="string">'x'</span>, <span class="string">'+'</span>, <span class="string">'v'</span>, <span class="string">'^'</span>, <span class="string">'&lt;'</span>, <span class="string">'&gt;'</span>, <span class="string">'s'</span>, <span class="string">'d'</span>]:</span><br><span class="line">    plt.plot(rng.rand(<span class="number">5</span>), rng.rand(<span class="number">5</span>), marker,</span><br><span class="line">             label=<span class="string">"marker='&#123;0&#125;'"</span>.format(marker))</span><br><span class="line">plt.legend(numpoints=<span class="number">1</span>)</span><br><span class="line">plt.xlim(<span class="number">0</span>, <span class="number">1.8</span>);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224151.png" alt=""></p><p>而且这些符号代码可以和线条、颜色代码一起使用，这会在折线图的基础上绘制出散点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(x, y, <span class="string">'-ok'</span>);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224155.png" alt=""></p><p>plt.plot还有很多额外的关键字参数用来指定广泛的线条和点的属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(x, y, <span class="string">'-p'</span>, color=<span class="string">'gray'</span>,</span><br><span class="line">         markersize=<span class="number">15</span>, linewidth=<span class="number">4</span>,</span><br><span class="line">         markerfacecolor=<span class="string">'white'</span>,</span><br><span class="line">         markeredgecolor=<span class="string">'gray'</span>,</span><br><span class="line">         markeredgewidth=<span class="number">2</span>)</span><br><span class="line">plt.ylim(<span class="number">-1.2</span>, <span class="number">1.2</span>);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224159.png" alt=""></p><p>plt.plot函数的这种灵活性提供了很多的可视化选择。查阅plt.plot帮助文档获得完整的选项说明。</p><h2 id="使用plt-scatter绘制散点图"><a href="#使用plt-scatter绘制散点图" class="headerlink" title="使用plt.scatter绘制散点图"></a><strong>使用plt.scatter绘制散点图</strong></h2><p>第二种更强大的绘制散点图的方法是使用plt.scatter函数，它的使用方法和plt.plot类似：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.scatter(x, y, marker=<span class="string">'o'</span>);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224202.png" alt=""></p><p>plt.scatter和plt.plot的主要区别在于，plt.scatter可以针对每个点设置不同属性（大小、填充颜色、边缘颜色等），还可以通过数据集合对这些属性进行设置。</p><p>让我们通过一个随机值数据集绘制不同颜色和大小的散点图来说明。为了更好的查看重叠的结果，我们还使用了alpha关键字参数对点的透明度进行了调整：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rng = np.random.RandomState(<span class="number">0</span>)</span><br><span class="line">x = rng.randn(<span class="number">100</span>)</span><br><span class="line">y = rng.randn(<span class="number">100</span>)</span><br><span class="line">colors = rng.rand(<span class="number">100</span>)</span><br><span class="line">sizes = <span class="number">1000</span> * rng.rand(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">plt.scatter(x, y, c=colors, s=sizes, alpha=<span class="number">0.3</span>,</span><br><span class="line">            cmap=<span class="string">'viridis'</span>)</span><br><span class="line">plt.colorbar();  <span class="comment"># 显示颜色对比条</span></span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224207.png" alt=""></p><p>注意图表右边有一个颜色对比条（这里通过colormap()函数输出），图表中的点大小的单位是像素。使用这种方法，散点的颜色和大小都能用来展示数据信息，在希望展示多个维度数据集合的情况下很直观。</p><p>例如，当我们使用 Scikit-learn 中的鸢尾花数据集，里面的每个样本都是三种鸢尾花中的其中一种，并带有仔细测量的花瓣和花萼的尺寸数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line">iris = load_iris()</span><br><span class="line">features = iris.data.T</span><br><span class="line"></span><br><span class="line">plt.scatter(features[<span class="number">0</span>], features[<span class="number">1</span>], alpha=<span class="number">0.2</span>,</span><br><span class="line">            s=<span class="number">100</span>*features[<span class="number">3</span>], c=iris.target, cmap=<span class="string">'viridis'</span>)</span><br><span class="line">plt.xlabel(iris.feature_names[<span class="number">0</span>])</span><br><span class="line">plt.ylabel(iris.feature_names[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224211.png" alt=""></p><p>我们可以从上图中看出，可以通过散点图同时展示该数据集的四个不同维度：图中的(x, y)位置代表每个样本的花萼的长度和宽度，散点的大小代表每个样本的花瓣的宽度，而散点的颜色代表一种特定的鸢尾花类型。如上图的多种颜色和多种属性的散点图对于我们分析和展示数据集时都非常有帮助。</p><h2 id="plot-和-scatter-对比：性能提醒"><a href="#plot-和-scatter-对比：性能提醒" class="headerlink" title="plot 和 scatter 对比：性能提醒"></a><strong>plot 和 scatter 对比：性能提醒</strong></h2><p>除了上面说的plt.plot和plt.scatter对于每个散点不同属性的支持不同之外，还有别的因素影响对这两个函数的选择吗？对于小的数据集来说，两者并无差别，当数据集增长到几千个点时，plt.plot会明显比plt.scatter的性能要高。造成这个差异的原因是plt.scatter支持每个点使用不同的大小和颜色，因此渲染每个点时需要完成更多额外的工作。而plt.plot来说，每个点都是简单的复制另一个点产生，因此对于整个数据集来说，确定每个点的展示属性的工作仅需要进行一次即可。对于很大的数据集来说，这个差异会导致两者性能的巨大区别，因此，对于大数据集应该优先使用plt.plot函数。</p><h1 id="3-误差可视化"><a href="#3-误差可视化" class="headerlink" title="3.误差可视化"></a><strong>3.误差可视化</strong></h1><p>对于任何的科学测量来说，精确计算误差与精确报告测量值基本上同等重要。例如，设想我正在使用一些天文物理学观测值来估算哈勃常数，即本地观测的宇宙膨胀系数。我从一些文献中知道这个值大概是 71 (km/s)/Mpc，而我测量得到的值是 74 (km/s)/Mpc,。这两个值是否一致？在仅给定这些数据的情况下，这个问题的答案是，无法回答。</p><p>Mpc（百万秒差距）参见秒差距[4]</p><p>如果我们将信息增加一些，给出不确定性：最新的文献表示哈勃常数的值大约是 71  2.5 (km/s)/Mpc，我的测量值是 74  5 (km/s)/Mpc。这两个值是一致的吗？这就是一个可以准确回答的问题了。</p><p>在数据和结果的可视化中，有效地展示这些误差能使你的图表涵盖和提供更加完整的信息。</p><h2 id="基础误差条"><a href="#基础误差条" class="headerlink" title="基础误差条"></a><strong>基础误差条</strong></h2><p>调用一个 Matplotlib 函数就能创建一个基础的误差条：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.style.use(<span class="string">'seaborn-whitegrid'</span>)</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">10</span>, <span class="number">50</span>)</span><br><span class="line">dy = <span class="number">0.8</span></span><br><span class="line">y = np.sin(x) + dy * np.random.randn(<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line">plt.errorbar(x, y, yerr=dy, fmt=<span class="string">'.k'</span>);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224220.png" alt=""></p><p>这里的fmt参数是用来控制线条和点风格的代码，与plt.plot有着相同的语法，参见[简单的折线图]和[简单的散点图]。</p><p>除了上面的基本参数，errorbar函数还有很多参数可以用来精细调节图表输出。使用这些参数你可以很容易的个性化调整误差条的样式。作者发现通常将误差线条颜色调整为浅色会更加清晰，特别是在数据点比较密集的情况下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.errorbar(x, y, yerr=dy, fmt=<span class="string">'o'</span>, color=<span class="string">'black'</span>,</span><br><span class="line">             ecolor=<span class="string">'lightgray'</span>, elinewidth=<span class="number">3</span>, capsize=<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224225.png" alt=""></p><p>除了上面介绍的参数，你还可以指定水平方向的误差条（xerr），单边误差条和其他很多的参数。参阅plt.errorbar的帮助文档获得更多信息。</p><h2 id="连续误差"><a href="#连续误差" class="headerlink" title="连续误差"></a><strong>连续误差</strong></h2><p>在某些情况下可能需要对连续值展示误差条。虽然 Matplotlib 没有內建的函数能直接完成这个任务，但是你可以通过简单将plt.plot和plt.fill_between函数结合起来达到目标。</p><p>这里我们会采用简单的高斯过程回归方法，Scikit-Learn 提供了 API。这个方法非常适合在非参数化的函数中获得连续误差。我们在这里不会详细介绍高斯过程回归，仅仅聚焦在如何绘制连续误差本身：</p><p>译者注：新版的 sklearn 修改了高斯过程回归实现方法，下面代码做了相应修改。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.gaussian_process <span class="keyword">import</span> GaussianProcessRegressor</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义模型和一些符合模型的点</span></span><br><span class="line">model = <span class="keyword">lambda</span> x: x * np.sin(x)</span><br><span class="line">xdata = np.array([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>])</span><br><span class="line">ydata = model(xdata)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算高斯过程回归，使其符合 fit 数据点</span></span><br><span class="line">gp = GaussianProcessRegressor()</span><br><span class="line">gp.fit(xdata[:, np.newaxis], ydata)</span><br><span class="line"></span><br><span class="line">xfit = np.linspace(<span class="number">0</span>, <span class="number">10</span>, <span class="number">1000</span>)</span><br><span class="line">yfit, std = gp.predict(xfit[:, np.newaxis], return_std=<span class="literal">True</span>)</span><br><span class="line">dyfit = <span class="number">2</span> * std  <span class="comment"># 两倍sigma ~ 95% 确定区域</span></span><br></pre></td></tr></table></figure><p>我们现在有了xfit、yfit和dyfit，作为对我们数据的连续拟合值以及误差限。当然我们也可以像上面一样使用plt.errorbar绘制误差条，但是事实上我们不希望在图标上绘制 1000 个点的误差条。于是我们可以使用plt.fill_between函数在误差限区域内填充一道浅色的误差带来展示连续误差：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可视化结果</span></span><br><span class="line">plt.plot(xdata, ydata, <span class="string">'or'</span>)</span><br><span class="line">plt.plot(xfit, yfit, <span class="string">'-'</span>, color=<span class="string">'gray'</span>)</span><br><span class="line"></span><br><span class="line">plt.fill_between(xfit, yfit - dyfit, yfit + dyfit,</span><br><span class="line">                 color=<span class="string">'gray'</span>, alpha=<span class="number">0.2</span>)</span><br><span class="line">plt.xlim(<span class="number">0</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224230.png" alt=""></p><p>注意上面我们调用fill_between函数：我们传递了的参数包括 x 值，y 值的低限，然后是 y 值的高限，结果是图表中介于低限和高限之间的区域会被填充。</p><p>上图为我们提供了一个非常直观的高斯过程回归展示：在观测点的附近，模型会被限制在一个很小的区域内，反映了这些数据的误差比较小。在远离观测点的区域，模型开始发散，反映了这时的数据误差比较大。</p><p>如果需要获得plt.fill_between（以及类似的plt.fill函数）更多参数的信息，请查阅函数的帮助文档或 Matplotlib 在线文档。</p><h1 id="4-密度和轮廓图"><a href="#4-密度和轮廓图" class="headerlink" title="4.密度和轮廓图"></a><strong>4.密度和轮廓图</strong></h1><p>有些情况下，我们需要在二维图表中使用轮廓或颜色区域来展示三维的数据（可以设想等高线地图或温度分布图）。Matplotlib 提供了三个有用的函数来处理这项任务：plt.contour绘制轮廓图，plt.contourf来绘制填充区域颜色的图表以及plt.imshow来展示图像。本节会介绍几个使用它们的例子。当然我们还是首先从将需要使用的包导入 notebook 和初始化工作开始：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.style.use(<span class="string">'seaborn-white'</span>)</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><h2 id="三维可视化函数"><a href="#三维可视化函数" class="headerlink" title="三维可视化函数"></a><strong>三维可视化函数</strong></h2><p>我们首先使用一个简单的函数  绘制一个轮廓图来进行说明，我们用来作为数组广播运算的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> np.sin(x) ** <span class="number">10</span> + np.cos(<span class="number">10</span> + y * x) * np.cos(x)</span><br></pre></td></tr></table></figure><p>轮廓图可以使用plt.contour函数进行创建。它接收三个参数：x参数代表三维网格的平面横轴坐标，y参数代表三维网格的平面纵轴坐标，而z参数代表三维网格的高度坐标。最容易用来准备这种网格数据的是np.meshgrid函数，可以将两个一维的数组构造成一个二维的网格：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">5</span>, <span class="number">50</span>)</span><br><span class="line">y = np.linspace(<span class="number">0</span>, <span class="number">5</span>, <span class="number">40</span>)</span><br><span class="line"></span><br><span class="line">X, Y = np.meshgrid(x, y)</span><br><span class="line">Z = f(X, Y)</span><br></pre></td></tr></table></figure><p>下面我们可以绘制标准的轮廓线图表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.contour(X, Y, Z, colors=<span class="string">'black'</span>);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224235.png" alt=""></p><p>图中值得注意的是，当使用单色绘制轮廓图时，虚线代表的是负数的数值，而实线代表的是正数。而轮廓线可以通过指定cmap参数来设置线条的色图。下例中展示了使用色图且绘制了更多的轮廓线的例子，会在整个数据范围区域内等距分布有 20 条轮廓线：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.contour(X, Y, Z, <span class="number">20</span>, cmap=<span class="string">'RdGy'</span>);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224238.png" alt=""></p><p>上例中我们选择了RdGy（Red-Gray的缩写）色图，这对于聚集的数据来说是一个不错的选择。Matplotlib 有大量的颜色图可供使用，你可以通过在 IPython 中对plt.cm模块使用 TAB 自动补全方法就可以看到：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.cm.&lt;TAB&gt;</span><br></pre></td></tr></table></figure><p>上面的图看起来比第一幅图好多了，但是线条之间的空隙还是有点让人混淆。我们可以将上面的图改为填充轮廓图来解决这个问题，使用plt.contourf()函数（注意函数名最后有个 f，代表填充 fill），这个函数的语法基本上与plt.contour()保持一致。</p><p>并且我们加上了plt.colorbar()函数，这个函数会在图表边上创建一个颜色图例用以展示颜色所表示的数值区域：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.contourf(X, Y, Z, <span class="number">20</span>, cmap=<span class="string">'RdGy'</span>)</span><br><span class="line">plt.colorbar();</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224241.png" alt=""></p><p>有了图例，很容易可以看出黑色区域代表着“峰”，而红色区域代表这“谷”。</p><p>上图有一个缺点，那就是图中颜色的阶梯是离散的而不是连续的，这通常不是我们想要的。我们可以通过设置很高的轮廓线数量来改善，但是这会导致绘制图表的性能降低：Matplotlib 必须在每个颜色阶梯上绘制一条新的轮廓多边形。更好的办法是使用plt.imshow()函数，它会将一个二维的网格图表转换为一张图像。</p><p>下面的例子展示了该方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plt.imshow(Z, extent=[<span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">5</span>], origin=<span class="string">'lower'</span>,</span><br><span class="line">           cmap=<span class="string">'RdGy'</span>)</span><br><span class="line">plt.colorbar()</span><br><span class="line">plt.axis(aspect=<span class="string">'image'</span>);</span><br></pre></td></tr></table></figure><p>C:\Users\gdc\Anaconda3\lib\site-packages\ipykernel_launcher.py:4: MatplotlibDeprecationWarning: Passing unsupported keyword arguments to axis() will raise a TypeError in 3.3.<br>  after removing the cwd from sys.path.</p><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224241.png" alt=""></p><p>然而，在使用imshow()的时候也有一些坑：</p><ul><li>plt.imshow()不接受 x 和 y 网格值作为参数，因此你需要手动指定extent参数[xmin, xmax, ymin, ymax]来设置图表的数据范围。</li><li>plt.imshow()使用的是默认的图像坐标，即左上角坐标点是原点，而不是通常图表的左下角坐标点。这可以通过设置origin参数来设置。</li><li>plt.imshow()会自动根据输入数据调整坐标轴的比例；这可以通过参数来设置，例如，plt.axis(aspect=’image’)能让 x 和 y 轴的单位一致。</li></ul><p>最后，有时可能需要将轮廓图和图像结合起来。例如，下例中我们使用了半透明的背景图像（通过alpha参数设置透明度），然后在背景图层之上绘制了轮廓图，并带有每个轮廓的数值标签（使用plt.clabel()函数绘制标签）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">contours = plt.contour(X, Y, Z, <span class="number">3</span>, colors=<span class="string">'black'</span>)</span><br><span class="line">plt.clabel(contours, inline=<span class="literal">True</span>, fontsize=<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">plt.imshow(Z, extent=[<span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">5</span>], origin=<span class="string">'lower'</span>,</span><br><span class="line">           cmap=<span class="string">'RdGy'</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line">plt.colorbar();</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224249.png" alt=""></p><p>通过组合使用plt.contour、plt.contourf和plt.imshow这三个函数，基本可以满足我们绘制所有这种在二维图标上的三维数据的需求。需要了解更多函数的参数信息，参考它们的文档字符串。如果你对于使用三维图表展示这种数据感兴趣，参见[在 matplotlib 中创建三维图表]。</p><h1 id="5-直方图，分桶和密度"><a href="#5-直方图，分桶和密度" class="headerlink" title="5.直方图，分桶和密度"></a><strong>5.直方图，分桶和密度</strong></h1><p>一个简单的直方图可以是我们开始理解数据集的第一步。前面我们看到了 Matplotlib 的直方图函数，我们可以用一行代码绘制基础的直方图，当然首先需要将需要用的包导入 notebook：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.style.use(<span class="string">'seaborn-white'</span>)</span><br><span class="line"></span><br><span class="line">data = np.random.randn(<span class="number">1000</span>)</span><br><span class="line">plt.hist(data);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224252.png" alt=""></p><p>hist()函数有很多的参数可以用来调整运算和展示；下面又一个更加个性化的直方图展示：</p><p>译者注：normed 参数已经过时，此处对代码进行了相应修改，使用了替代的 density 参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plt.hist(data, bins=<span class="number">30</span>, density=<span class="literal">True</span>, alpha=<span class="number">0.5</span>,</span><br><span class="line">         histtype=<span class="string">'stepfilled'</span>, color=<span class="string">'steelblue'</span>,</span><br><span class="line">         edgecolor=<span class="string">'none'</span>);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224255.png" alt=""></p><p>plt.hist文档中有更多关于个性化参数的信息。作者发现联合使用histtype=’stepfilled’和alpha参数设置透明度在对不同分布的数据集进行比较展示时很有用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x1 = np.random.normal(<span class="number">0</span>, <span class="number">0.8</span>, <span class="number">1000</span>)</span><br><span class="line">x2 = np.random.normal(<span class="number">-2</span>, <span class="number">1</span>, <span class="number">1000</span>)</span><br><span class="line">x3 = np.random.normal(<span class="number">3</span>, <span class="number">2</span>, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">kwargs = dict(histtype=<span class="string">'stepfilled'</span>, alpha=<span class="number">0.3</span>, density=<span class="literal">True</span>, bins=<span class="number">40</span>)</span><br><span class="line"></span><br><span class="line">plt.hist(x1, **kwargs)</span><br><span class="line">plt.hist(x2, **kwargs)</span><br><span class="line">plt.hist(x3, **kwargs);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224258.png" alt=""></p><p>如果你只是需要计算直方图的数值（即每个桶的数据点数量）而不是展示图像，np.histogram()函数可以完成这个目标：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">counts, bin_edges = np.histogram(data, bins=<span class="number">5</span>)</span><br><span class="line">print(counts)</span><br></pre></td></tr></table></figure><p>[ 49 273 471 183  24]</p><h2 id="二维直方图和分桶"><a href="#二维直方图和分桶" class="headerlink" title="二维直方图和分桶"></a><strong>二维直方图和分桶</strong></h2><p>正如前面我们可以在一维上使用数值对应的直线划分桶一样，我们也可以在二维上使用数据对应的点来划分桶。本节我们介绍几种实现的方法。首先定义数据集，从多元高斯分布中获得x和y数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mean = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">cov = [[<span class="number">1</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">2</span>]]</span><br><span class="line">x, y = np.random.multivariate_normal(mean, cov, <span class="number">10000</span>).T</span><br></pre></td></tr></table></figure><h3 id="plt-hist2d：二维直方图"><a href="#plt-hist2d：二维直方图" class="headerlink" title="plt.hist2d：二维直方图"></a><strong>plt.hist2d：二维直方图</strong></h3><p>绘制二维直方图最直接的方法是使用 Matplotlib 的plt.hist2d函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plt.hist2d(x, y, bins=<span class="number">30</span>, cmap=<span class="string">'Blues'</span>)</span><br><span class="line">cb = plt.colorbar()</span><br><span class="line">cb.set_label(<span class="string">'counts in bin'</span>)</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224304.png" alt=""></p><p>类似plt.hist，plt.hist2d有许多额外的参数来调整分桶计算和图表展示，可以通过文档了解更多信息。而且，plt.hist有np.histogram，plt.hist2d也有其对应的函数np.histogram2d。如下例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">counts, xedges, yedges = np.histogram2d(x, y, bins=<span class="number">30</span>)</span><br></pre></td></tr></table></figure><p>如果要获得更高维度的分桶结果，参见np.histogramd函数文档。</p><h3 id="plt-hexbin：六角形分桶"><a href="#plt-hexbin：六角形分桶" class="headerlink" title="plt.hexbin：六角形分桶"></a><strong>plt.hexbin：六角形分桶</strong></h3><p>刚才的二维分桶是沿着坐标轴将每个桶分为正方形。另一个很自然的分桶形状就是正六边形。对于这个需求，Matplotlib 提供了plt.hexbin函数，它也是在二维平面上分桶展示，不过每个桶（即图表上的每个数据格）将会是六边形：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.hexbin(x, y, gridsize=<span class="number">30</span>, cmap=<span class="string">'Blues'</span>)</span><br><span class="line">cb = plt.colorbar(label=<span class="string">'count in bin'</span>)</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224308.png" alt=""></p><p>plt.hexbin有许多有趣的参数，包括能对每个点设置权重和将每个桶的输出数据结果改为任意的 NumPy 聚合结果（带权重的平均值，带权重的标准差等）。</p><h3 id="核密度估计"><a href="#核密度估计" class="headerlink" title="核密度估计"></a><strong>核密度估计</strong></h3><p>另外一个常用来统计多维数据密度的工具是核密度估计（KDE）。目前我们只需要知道 KDE 被认为是一种可以用来填补数据的空隙并补充上平滑变化数据的方法就足够了。快速和简单的 KDE 算法已经在scipy.stats模块中有了成熟的实现。下面我们就一个简单的例子来说明如何使用 KDE 和绘制相应的二维直方图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> gaussian_kde</span><br><span class="line"></span><br><span class="line"><span class="comment"># 产生和处理数据，初始化KDE</span></span><br><span class="line">data = np.vstack([x, y])</span><br><span class="line">kde = gaussian_kde(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在通用的网格中计算得到Z的值</span></span><br><span class="line">xgrid = np.linspace(<span class="number">-3.5</span>, <span class="number">3.5</span>, <span class="number">40</span>)</span><br><span class="line">ygrid = np.linspace(<span class="number">-6</span>, <span class="number">6</span>, <span class="number">40</span>)</span><br><span class="line">Xgrid, Ygrid = np.meshgrid(xgrid, ygrid)</span><br><span class="line">Z = kde.evaluate(np.vstack([Xgrid.ravel(), Ygrid.ravel()]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将图表绘制成一张图像</span></span><br><span class="line">plt.imshow(Z.reshape(Xgrid.shape),</span><br><span class="line">           origin=<span class="string">'lower'</span>, aspect=<span class="string">'auto'</span>,</span><br><span class="line">           extent=[<span class="number">-3.5</span>, <span class="number">3.5</span>, <span class="number">-6</span>, <span class="number">6</span>],</span><br><span class="line">           cmap=<span class="string">'Blues'</span>)</span><br><span class="line">cb = plt.colorbar()</span><br><span class="line">cb.set_label(<span class="string">"density"</span>)</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224313.png" alt=""></p><p>KDE 有着光滑的长度，可以在细节和光滑度中有效的进行调节（一个例子是方差偏差权衡）。这方面有大量的文献介绍：高斯核密度估计gaussian_kde使用了经验法则来寻找输入数据附近的优化光滑长度值。</p><p>其他的 KDE 实现也可以在 SciPy 中找到，每一种都有它的优点和缺点；参见sklearn.neighbors.KernelDensity和statsmodels.nonparametric.kernel_density.KDEMultivariate。要绘制基于 KDE 进行可视化的图表，Matplotlib 写出的代码会比较冗长。</p><h1 id="6-自定义图标图例"><a href="#6-自定义图标图例" class="headerlink" title="6.自定义图标图例"></a><strong>6.自定义图标图例</strong></h1><p>图例可以为可视化赋予实际含义，为不同的图标元素附上明确说明。我们前面看到了一些简单的图例创建例子；本小节中我们来介绍一下在 Matplotlib 中自定义图例的位置和进行美化的方法。</p><p>可以使用plt.legend()函数来创建最简单的图例，这个函数能自动创建任何带有标签属性的图表元素的图例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.style.use(<span class="string">'classic'</span>)</span><br><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">10</span>, <span class="number">1000</span>)</span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line">ax.plot(x, np.sin(x), <span class="string">'-b'</span>, label=<span class="string">'Sine'</span>)</span><br><span class="line">ax.plot(x, np.cos(x), <span class="string">'--r'</span>, label=<span class="string">'Cosine'</span>)</span><br><span class="line">ax.axis(<span class="string">'equal'</span>)</span><br><span class="line">leg = ax.legend();</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224317.png" alt=""></p><p>但除此之外还有很多能自定义图例的方法。例如，我们可以指定图例位置并且去除边框：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ax.legend(loc=<span class="string">'upper left'</span>, frameon=<span class="literal">False</span>)</span><br><span class="line">fig</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224322.png" alt=""></p><p>我们可以使用ncol属性设置图例中每行的列数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ax.legend(frameon=<span class="literal">False</span>, loc=<span class="string">'lower center'</span>, ncol=<span class="number">2</span>)</span><br><span class="line">fig</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224325.png" alt=""></p><p>还可以使用圆角方框（fancybox）或者增加阴影，设置方框的透明度（alpha 值）或修改文字的边距：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ax.legend(fancybox=<span class="literal">True</span>, framealpha=<span class="number">1</span>, shadow=<span class="literal">True</span>, borderpad=<span class="number">1</span>)</span><br><span class="line">fig</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224328.png" alt=""></p><p>要获取更多 legend 函数的可用选项信息，请参考plt.legend的文档字符串。</p><h2 id="选择设置图例的元素"><a href="#选择设置图例的元素" class="headerlink" title="选择设置图例的元素"></a><strong>选择设置图例的元素</strong></h2><p>正如我们前面例子所示，绘制的图例默认包括所有带标签的元素。如果这不是想要的效果，我们可以调整哪些元素和标签会出现在图例当中，这可以通过设置 plot 函数或方法返回的对象实现。plt.plot函数能够同时产生多条折线，然后将这些线条的实例列表返回。将其中的部分实例传递到plt.legend()函数就能设置哪些线条会出现在图例中，再通过一个标签的列表指定图例的名称：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">y = np.sin(x[:, np.newaxis] + np.pi * np.arange(<span class="number">0</span>, <span class="number">2</span>, <span class="number">0.5</span>))</span><br><span class="line">lines = plt.plot(x, y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># lines是一个线条实例的列表</span></span><br><span class="line">plt.legend(lines[:<span class="number">2</span>], [<span class="string">'first'</span>, <span class="string">'second'</span>]);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224332.png" alt=""></p><p>作者更加倾向于使用第一种方式，因为更加清晰。通过将标签应用在图表元素上，然后绘制到图例中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(x, y[:, <span class="number">0</span>], label=<span class="string">'first'</span>)</span><br><span class="line">plt.plot(x, y[:, <span class="number">1</span>], label=<span class="string">'second'</span>)</span><br><span class="line">plt.plot(x, y[:, <span class="number">2</span>:])</span><br><span class="line">plt.legend(framealpha=<span class="number">1</span>, frameon=<span class="literal">True</span>);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224336.png" alt=""></p><p>请注意默认情况下，legend 会忽略所有不带标签的元素。</p><h2 id="散点大小的图例"><a href="#散点大小的图例" class="headerlink" title="散点大小的图例"></a><strong>散点大小的图例</strong></h2><p>某些情况下默认的图例不足以满足特定的可视化需求。例如，你在使用散点的大小来标记数据的某个特征，然后希望创建一个相应的图例。下面的例子是加州城市人口的散点图，我们使用散点的大小表现该城市的面积，散点的颜色来表现城市的人口数量（自然对数值）。我们希望使用一个图例来指明散点尺寸的比例，同时用一个颜色条来说明人口数量，我们可以通过自定义绘制一些标签数据来实现尺寸图例：</p><p>译者注：新版 Matplotlib 已经取消 aspect 参数，此处改为使用新的’scaled’参数调用 axis 函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">cities = pd.read_csv(<span class="string">r'D:\python\Github学习材料\Python数据科学手册\data\california_cities.csv'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取我们感兴趣的数据</span></span><br><span class="line">lat, lon = cities[<span class="string">'latd'</span>], cities[<span class="string">'longd'</span>]</span><br><span class="line">population, area = cities[<span class="string">'population_total'</span>], cities[<span class="string">'area_total_km2'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制散点图，使用尺寸代表面积，颜色代表人口，不带标签</span></span><br><span class="line">plt.scatter(lon, lat, label=<span class="literal">None</span>,</span><br><span class="line">            c=np.log10(population), cmap=<span class="string">'viridis'</span>,</span><br><span class="line">            s=area, linewidth=<span class="number">0</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line">plt.axis(<span class="string">'scaled'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'longitude'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'latitude'</span>)</span><br><span class="line">plt.colorbar(label=<span class="string">'log$_&#123;10&#125;$(population)'</span>)</span><br><span class="line">plt.clim(<span class="number">3</span>, <span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面我们创建图例：</span></span><br><span class="line"><span class="comment"># 使用空列表绘制图例中的散点，使用不同面积和标签，带透明度</span></span><br><span class="line"><span class="keyword">for</span> area <span class="keyword">in</span> [<span class="number">100</span>, <span class="number">300</span>, <span class="number">500</span>]:</span><br><span class="line">    plt.scatter([], [], c=<span class="string">'k'</span>, alpha=<span class="number">0.3</span>, s=area,</span><br><span class="line">                label=str(area) + <span class="string">' km$^2$'</span>)</span><br><span class="line">plt.legend(scatterpoints=<span class="number">1</span>, frameon=<span class="literal">False</span>, labelspacing=<span class="number">1</span>, title=<span class="string">'City Area'</span>)</span><br><span class="line"></span><br><span class="line">plt.title(<span class="string">'California Cities: Area and Population'</span>);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224339.png" alt=""></p><p>之前的图例都关联着图表上的一些对象，因此如果我们需要展示图例的话我们首先需要绘制图表元素。在上例中，我们需要的图例对象（灰色圆圈）不在图表上，因此我们采用绘制空列表的方式将它们仿造在图表上（实际上图上没有点），但是还是需要注意，只有那些带标签的元素才会出现在图例中。</p><p>通过绘制空列表，我们创建了三个带标签的对象，然后就可以出现在图例当中，这个图例就能表示出有关城市面积的相关信息。这个策略在很多复杂可视化图表构建过程中都被用到。</p><p>最后我们注意到这个图表实际上是一个地理位置图表，如果我们能在上面绘制州界线或其他地图相关的元素的话，会更加清晰。Matplotlib 提供了一个 Basemap 额外工具集来实现这个目标。</p><h2 id="多重图例"><a href="#多重图例" class="headerlink" title="多重图例"></a><strong>多重图例</strong></h2><p>有时候我们可能需要在同一个图表维度中设计多个图例。不幸的是，Matplotlib 并没有提供很简单的方式实现：通过标准的legend接口，只能在整张图表上创建一个图例。如果你试图使用plt.legend()或ax.legend()创建第二个图例，那么第二条语句创建的图例会覆盖第一条语句创建的。我们只能通过从底层开始来创建一个新的图例 artist 这种方法来解决这个问题，然后使用ax.add_artist()的底层方法手动将第二个作者加到图表上：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots()</span><br><span class="line"></span><br><span class="line">lines = []</span><br><span class="line">styles = [<span class="string">'-'</span>, <span class="string">'--'</span>, <span class="string">'-.'</span>, <span class="string">':'</span>]</span><br><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">10</span>, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">    lines += ax.plot(x, np.sin(x - i * np.pi / <span class="number">2</span>),</span><br><span class="line">                     styles[i], color=<span class="string">'black'</span>)</span><br><span class="line">ax.axis(<span class="string">'equal'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定第一个图例的线条和标签</span></span><br><span class="line">ax.legend(lines[:<span class="number">2</span>], [<span class="string">'line A'</span>, <span class="string">'line B'</span>],</span><br><span class="line">          loc=<span class="string">'upper right'</span>, frameon=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 手动创建第二个图例，并将作者添加到图表中</span></span><br><span class="line"><span class="keyword">from</span> matplotlib.legend <span class="keyword">import</span> Legend</span><br><span class="line">leg = Legend(ax, lines[<span class="number">2</span>:], [<span class="string">'line C'</span>, <span class="string">'line D'</span>],</span><br><span class="line">             loc=<span class="string">'lower right'</span>, frameon=<span class="literal">False</span>)</span><br><span class="line">ax.add_artist(leg);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224343.png" alt=""></p><p>上例展示了用来组成任何 Matplotlib 图表的底层 artist 对象的简单说明。如果你去查看ax.legend()的源代码（你可以通过 IPython 的ax.legend帮助工具做到），你可以看到这个方法包含了用来构建合适Legend的 artist 对象的逻辑，构建的对象被保存在legend_属性当中，当绘制时被添加到图表上进行展示。</p><h1 id="7-个性化颜色条"><a href="#7-个性化颜色条" class="headerlink" title="7.个性化颜色条"></a><strong>7.个性化颜色条</strong></h1><p>图例可以将离散的点标示为离散的标签。对于建立在不同颜色之上的连续的值（点线面）来说，标注了的颜色条是非常方便的工具。Matplotlib 的颜色条是独立于图表之外的一个类似于比色卡的图形，用来展示图表中不同颜色的数值含义。因为本书是使用黑白打印的，本节内容中的所有带色彩的图都可以在(<a href="https://github.com/wangyingsm/Python-Data-Science-Handbook)中找到。我们还是首先导入本节需要的包和模块：" target="_blank" rel="noopener">https://github.com/wangyingsm/Python-Data-Science-Handbook)中找到。我们还是首先导入本节需要的包和模块：</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.style.use(<span class="string">'classic'</span>)</span><br><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><p>通过plt.colorbar函数可以创建最简单的颜色条，在本节中我们会多次看到：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">10</span>, <span class="number">1000</span>)</span><br><span class="line">I = np.sin(x) * np.cos(x[:, np.newaxis])</span><br><span class="line"></span><br><span class="line">plt.imshow(I)</span><br><span class="line">plt.colorbar();</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224347.png" alt=""></p><p>我们下面来讨论如何个性化颜色条以及在不同的场合高效的使用它们。</p><h2 id="自定义颜色条"><a href="#自定义颜色条" class="headerlink" title="自定义颜色条"></a><strong>自定义颜色条</strong></h2><p>颜色条可以通过cmap参数指定使用的色谱系统（或叫色图）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.imshow(I, cmap=<span class="string">'gray'</span>);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224352.png" alt=""></p><p>所有可用的色图都可以在plt.cm模块中找到；在 IPython 中使用 Tab 自动补全功能能列出所有的色图列表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.cm.&lt;TAB&gt;</span><br></pre></td></tr></table></figure><p>但是知道在哪里选择色图只是第一步，更重要的是在各种选项中选出合适的色图。这个选择比你预料的要微妙的多。</p><h3 id="选择色图"><a href="#选择色图" class="headerlink" title="选择色图"></a><strong>选择色图</strong></h3><p>在可视化方案中选择颜色完整的介绍说明超出了本书的范围，如果你对这个课题和相关内容有兴趣，可以参考文章<a href="http://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1003833" target="_blank" rel="noopener">“绘制更漂亮图表的 10 个简单规则”</a>。Matplotlib 的在线文档也有一章关于色图选择的有趣讨论[5]。</p><p>通常来说，你应该注意以下三种不同类型的色图：</p><ul><li>序列色图：这类型的色谱只包括一个连续序列的色系（例如binary或viridis）。</li><li>分化色图：这类型的色谱包括两种独立的色系，这两种颜色有着非常大的对比度（例如RdBu或PuOr）。</li><li>定性色图：这类型的色图混合了非特定连续序列的颜色（例如rainbow或jet）。</li></ul><p>jet色图，在 Matplotlib 2.0 版本之前都是默认的色图，是定性色图的一个例子。jet作为默认色图的位置其实有点尴尬，因为定性图通常都不是对定量数据进行展示的好选择。原因是定性图通常都不能在范围增加时提供亮度的均匀增长。</p><p>我们可以通过将jet颜色条转换为黑白来看到这点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.colors <span class="keyword">import</span> LinearSegmentedColormap</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grayscale_cmap</span><span class="params">(cmap)</span>:</span></span><br><span class="line">    <span class="string">"""返回给定色图的灰度版本"""</span></span><br><span class="line">    cmap = plt.cm.get_cmap(cmap) <span class="comment"># 使用名称获取色图对象</span></span><br><span class="line">    colors = cmap(np.arange(cmap.N)) <span class="comment"># 将色图对象转为RGBA矩阵，形状为N×4</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将RGBA颜色转换为灰度</span></span><br><span class="line">    <span class="comment"># 参考 http://alienryderflex.com/hsp.html</span></span><br><span class="line">    RGB_weight = [<span class="number">0.299</span>, <span class="number">0.587</span>, <span class="number">0.114</span>] <span class="comment"># RGB三色的权重值</span></span><br><span class="line">    luminance = np.sqrt(np.dot(colors[:, :<span class="number">3</span>] ** <span class="number">2</span>, RGB_weight)) <span class="comment"># RGB平方值和权重的点积开平方根</span></span><br><span class="line">    colors[:, :<span class="number">3</span>] = luminance[:, np.newaxis] <span class="comment"># 得到灰度值矩阵</span></span><br><span class="line">    <span class="comment"># 返回相应的灰度值色图</span></span><br><span class="line">    <span class="keyword">return</span> LinearSegmentedColormap.from_list(cmap.name + <span class="string">"_gray"</span>, colors, cmap.N)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">view_colormap</span><span class="params">(cmap)</span>:</span></span><br><span class="line">    <span class="string">"""将色图对应的灰度版本绘制出来"""</span></span><br><span class="line">    cmap = plt.cm.get_cmap(cmap)</span><br><span class="line">    colors = cmap(np.arange(cmap.N))</span><br><span class="line"></span><br><span class="line">    cmap = grayscale_cmap(cmap)</span><br><span class="line">    grayscale = cmap(np.arange(cmap.N))</span><br><span class="line"></span><br><span class="line">    fig, ax = plt.subplots(<span class="number">2</span>, figsize=(<span class="number">6</span>, <span class="number">2</span>),</span><br><span class="line">                           subplot_kw=dict(xticks=[], yticks=[]))</span><br><span class="line">    ax[<span class="number">0</span>].imshow([colors], extent=[<span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">    ax[<span class="number">1</span>].imshow([grayscale], extent=[<span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">view_colormap(<span class="string">'jet'</span>)</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224358.png" alt=""></p><p>注意一下上面的灰度图中亮条纹的位置。即使在上述彩色图中，也出现了这种不规则的亮条纹，这会导致眼睛被区域中亮条纹所吸引，这很可能造成阅读者被不重要的数据集部分干扰了。更好的选择是使用类似viridis这样的色图（Matplotlib 2.0 后默认色图），它们被设计为有着均匀的亮度变化。因此它们无论是在彩色图中还是在灰度图中都有着同样的亮度变化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view_colormap(<span class="string">'viridis'</span>)</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224401.png" alt=""></p><p>如果你更喜欢彩虹方案，另一个好的选择是使用cubehelix色图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view_colormap(<span class="string">'cubehelix'</span>)</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224404.png" alt=""></p><p>对于其他的情况，例如某种正负分布的数据集，双色颜色条如RdBu（Red-Blue）会很常用。然而正如你从下面例子看到的，如果将双色颜色条转化为灰度的话，正负或两级的信息就会丢失：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view_colormap(<span class="string">'RdBu'</span>)</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224407.png" alt=""></p><p>后面我们会看到更多使用这些色图的例子。</p><p>Matplotlib 中有大量可用的色图；要看到它们的列表，你可以使用 IPython 来探索plt.cm模块。要在 Python 中更加正规的使用颜色，你可以查看 Seaborn 库的工具和文档。</p><h3 id="颜色限制和扩展"><a href="#颜色限制和扩展" class="headerlink" title="颜色限制和扩展"></a><strong>颜色限制和扩展</strong></h3><p>Matplotlib 允许你对颜色条进行大量的自定义。颜色条本身就是一个plt.Axes对象，因此所有轴和刻度定制的技巧都可以应用在上面。颜色条也有着一些有趣的自定义行为：例如，我们可以缩小颜色的范围并且通过设置extend参数将超出范围之外的数值展示为顶部和底部的三角箭头形状。这对于展示一些受到噪声干扰的数据时非常方便：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在I数组中人为生成不超过1%的噪声</span></span><br><span class="line">speckles = (np.random.random(I.shape) &lt; <span class="number">0.01</span>)</span><br><span class="line">I[speckles] = np.random.normal(<span class="number">0</span>, <span class="number">3</span>, np.count_nonzero(speckles))</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">3.5</span>))</span><br><span class="line"><span class="comment"># 不考虑去除噪声时的颜色分布</span></span><br><span class="line">plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">plt.imshow(I, cmap=<span class="string">'RdBu'</span>)</span><br><span class="line">plt.colorbar()</span><br><span class="line"><span class="comment"># 设置去除噪声时的颜色分布</span></span><br><span class="line">plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">plt.imshow(I, cmap=<span class="string">'RdBu'</span>)</span><br><span class="line">plt.colorbar(extend=<span class="string">'both'</span>)</span><br><span class="line">plt.clim(<span class="number">-1</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224412.png" alt=""></p><p>注意到在左边的图表中，默认的颜色阈值是包括了噪声的，因此整体的条纹形状都被噪声数据冲刷淡化了。而右边的图表，我们手动设置了颜色的阈值，并在绘制颜色条是加上了extend参数来表示超出阈值的数据。对于我们的数据来说，右图比左图要好的多。</p><h3 id="离散颜色条"><a href="#离散颜色条" class="headerlink" title="离散颜色条"></a><strong>离散颜色条</strong></h3><p>色图默认是连续的，但是在某些情况下你可能需要展示离散值。最简单的方法是使用plt.cm.get_cmap()函数，在传递某个色图名称的同时，还额外传递一个颜色分桶的数量值参数给该函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plt.imshow(I, cmap=plt.cm.get_cmap(<span class="string">'Blues'</span>, <span class="number">6</span>))</span><br><span class="line">plt.colorbar()</span><br><span class="line">plt.clim(<span class="number">-1</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224415.png" alt=""></p><p>离散色图的使用方式和其他色图没有任何区别。</p><h2 id="例子：手写数字"><a href="#例子：手写数字" class="headerlink" title="例子：手写数字"></a><strong>例子：手写数字</strong></h2><p>最后我们来看一个很有实用价值的例子，让我们实现对一些手写数字图像数据的可视化分析。这个数据包含在 Sciki-Learn 中，以供包含有将近 2,000 张  大小的不同笔迹的手写数字缩略图。</p><p>首先，我们下载这个数据集，然后使用plt.imshow()将其中部分数据展示出来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读取数字0-5的手写图像，然后使用Matplotlib展示头64张缩略图</span></span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_digits</span><br><span class="line">digits = load_digits(n_class=<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(<span class="number">8</span>, <span class="number">8</span>, figsize=(<span class="number">6</span>, <span class="number">6</span>))</span><br><span class="line"><span class="keyword">for</span> i, axi <span class="keyword">in</span> enumerate(ax.flat):</span><br><span class="line">    axi.imshow(digits.images[i], cmap=<span class="string">'binary'</span>)</span><br><span class="line">    axi.set(xticks=[], yticks=[])</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224419.png" alt=""></p><p>因为每个数字都是使用 64 个像素点渲染出来的，我们可以认为每个数字是一个 64 维空间中的点：每个维度代表这其中一个像素的灰度值。但是要在图表中将这么高维度空间的联系可视化出来是非常困难的。有一种做法是使用降维技术，比方说使用流形学习来减少数据的维度然而不会丢失数据中有效的信息。</p><p>我们来看一下将这些手写数字图像数据映射到二维流形学习当中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用Isomap将手写数字图像映射到二维流形学习中</span></span><br><span class="line"><span class="keyword">from</span> sklearn.manifold <span class="keyword">import</span> Isomap</span><br><span class="line">iso = Isomap(n_components=<span class="number">2</span>)</span><br><span class="line">projection = iso.fit_transform(digits.data)</span><br></pre></td></tr></table></figure><p>我们使用离散颜色条来展示结果，设置ticks和clim来进一步美化结果的颜色条：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 绘制图表结果</span></span><br><span class="line">plt.scatter(projection[:, <span class="number">0</span>], projection[:, <span class="number">1</span>], lw=<span class="number">0.1</span>,</span><br><span class="line">            c=digits.target, cmap=plt.cm.get_cmap(<span class="string">'cubehelix'</span>, <span class="number">6</span>))</span><br><span class="line">plt.colorbar(ticks=range(<span class="number">6</span>), label=<span class="string">'digit value'</span>)</span><br><span class="line">plt.clim(<span class="number">-0.5</span>, <span class="number">5.5</span>)</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224423.png" alt=""></p><p>我们从流形学习中的映射中可以观察到一些有趣现象：例如，图表中 5 和 3 有一些重叠的部分，这表示一些手写体中 5 和 3 是比较难以辨别的，因此对于自动识别算法来说这是比较容易混淆的部分。而 0 和 1，它们在图表中距离很远，这表示两者比较容易辨别，不太可能造成混淆。这个图表分析与我们的直觉一致，因为 5 和 3 显然比 0 和 1 看起来更加接近。</p><h1 id="8-多个子图表"><a href="#8-多个子图表" class="headerlink" title="8.多个子图表"></a><strong>8.多个子图表</strong></h1><p>在一些情况中，如果能将不同的数据图表并列展示，对于我们进行数据分析和比较会很有帮助。Matplotlib 提供了子图表的概念来实现这一点：单个图表中可以包括一组小的 axes 用来展示多个子图表。这些子图表可以是插图，网格状分布或其他更复杂的布局。在本节中我们会介绍 Matplotlib 中用来构建子图表的四个函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.style.use(<span class="string">'seaborn-white'</span>)</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><h2 id="plt-axes：手动构建子图表"><a href="#plt-axes：手动构建子图表" class="headerlink" title="plt.axes：手动构建子图表"></a><strong>plt.axes：手动构建子图表</strong></h2><p>构建 axes 作为子图表的最基础方法就是使用plt.axes函数。正如我们前面已经看到，默认情况下，这个函数够创建一个标准的 axes 对象填满整个图表区域。plt.axes函数也可以接收一个可选的列表参数用来指定在 axes 在整个图表中的坐标点位置。列表中有四个数值分别为[left, bottom, width, height]（取值都是 0-1），代表着子图表的左边、底部、宽度、高度在整个图表中左边、底部、宽度、高度所占的比例值。</p><p>例如，我们可以在距离左边和底部 65%的位置，以插图的形式放置一个宽度和高度都是 20%子图表，上述数值应该为[0.65, 0.65, 0.2, 0.2]：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ax1 = plt.axes()  <span class="comment"># 标准图表</span></span><br><span class="line">ax2 = plt.axes([<span class="number">0.65</span>, <span class="number">0.65</span>, <span class="number">0.2</span>, <span class="number">0.2</span>]) <span class="comment">#子图表</span></span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224427.png" alt=""></p><p>与上述等价的面向对象接口的语法是fig.add_axes()。我们使用这个方法来创建两个垂直堆叠的子图表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fig = plt.figure() <span class="comment"># 获得figure对象</span></span><br><span class="line">ax1 = fig.add_axes([<span class="number">0.1</span>, <span class="number">0.5</span>, <span class="number">0.8</span>, <span class="number">0.4</span>],</span><br><span class="line">                   xticklabels=[], ylim=(<span class="number">-1.2</span>, <span class="number">1.2</span>)) <span class="comment"># 左边10% 底部50% 宽80% 高40%</span></span><br><span class="line">ax2 = fig.add_axes([<span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.8</span>, <span class="number">0.4</span>],</span><br><span class="line">                   ylim=(<span class="number">-1.2</span>, <span class="number">1.2</span>)) <span class="comment"># 左边10% 底部10% 宽80% 高40%</span></span><br><span class="line"></span><br><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">ax1.plot(np.sin(x))</span><br><span class="line">ax2.plot(np.cos(x));</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224430.png" alt=""></p><p>这样我们就有两个子图表（上面的子图表没有 x 轴刻度），这两个子图表正好吻合：上面图表的底部是整个图表高度 50%位置，而下面图表的顶部也是整个图表的 50%位置（0.1+0.4）。</p><h2 id="plt-subplot：简单网格的子图表"><a href="#plt-subplot：简单网格的子图表" class="headerlink" title="plt.subplot：简单网格的子图表"></a><strong>plt.subplot：简单网格的子图表</strong></h2><p>将子图表的行与列对齐是一个很常见的需求，因此 Matplotlib 提供了一些简单的函数来实现它们。这些函数当中最底层的是plt.subplot()，它会在网格中创建一个子图表。函数接受三个整数参数，网格行数，网格列数以及该网格子图表的序号（从左上角向右下角递增）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">7</span>):</span><br><span class="line">    plt.subplot(<span class="number">2</span>, <span class="number">3</span>, i)</span><br><span class="line">    plt.text(<span class="number">0.5</span>, <span class="number">0.5</span>, str((<span class="number">2</span>, <span class="number">3</span>, i)),</span><br><span class="line">             fontsize=<span class="number">18</span>, ha=<span class="string">'center'</span>)</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224433.png" alt=""></p><p>plt.subplots_adjust函数用来调整这些子图表之间的距离。下面的代码使用了与plt.subplot()等价的面向对象接口方法fig.add_subplot()：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fig = plt.figure()</span><br><span class="line">fig.subplots_adjust(hspace=<span class="number">0.4</span>, wspace=<span class="number">0.4</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">7</span>):</span><br><span class="line">    ax = fig.add_subplot(<span class="number">2</span>, <span class="number">3</span>, i)</span><br><span class="line">    ax.text(<span class="number">0.5</span>, <span class="number">0.5</span>, str((<span class="number">2</span>, <span class="number">3</span>, i)),</span><br><span class="line">           fontsize=<span class="number">18</span>, ha=<span class="string">'center'</span>)</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224437.png" alt=""></p><p>上例中我们指定了plt.subplots_adjust函数的hspace和wspace参数，它们代表这沿着高度和宽度方向子图表之间的距离，单位是子图表的大小（在本例中，距离是子图表宽度和高度的 40%）。</p><h2 id="plt-subplots：一句代码设置所有网格子图表"><a href="#plt-subplots：一句代码设置所有网格子图表" class="headerlink" title="plt.subplots：一句代码设置所有网格子图表"></a><strong>plt.subplots：一句代码设置所有网格子图表</strong></h2><p>上面的方法在我们需要创建大量的子图表网格时会变得非常冗长乏味，特别是如果我们需要将内部图表 x 轴和 y 轴标签隐藏的情况下。因此，plt.subplots在这种情况下是一个合适的工具（注意末尾有个 s）。这个函数会一次性创建所有的网格子图表，而不是单个网格，并将它们存储在一个 NumPy 数组中返回。参数是行数和列数，还有两个可选的关键字参数sharex和sharey，可以让你指定不同子图表之间的关联。</p><p>下面我们来创建一个  网格的子图表，其中每一行的子图表共享它们的 y 轴，而每一列的子图表共享它们的 x 轴：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(<span class="number">2</span>, <span class="number">3</span>, sharex=<span class="string">'col'</span>, sharey=<span class="string">'row'</span>)</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224441.png" alt=""></p><p>注意上面我们设置了sharex和sharey之后，内部子图表的 x 轴和 y 轴的标签就自动被去掉了。返回值中 ax 是一个 NumPy 数组，里面含有每一个子图表的实例，你可以使用 NumPy 索引的语法很简单的获得它们：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># axes是一个2×3的数组，可以通过[row, col]进行索引访问</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        ax[i, j].text(<span class="number">0.5</span>, <span class="number">0.5</span>, str((i, j)),</span><br><span class="line">                      fontsize=<span class="number">18</span>, ha=<span class="string">'center'</span>)</span><br><span class="line">fig</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224444.png" alt=""></p><p>并且相对于plt.subplot，plt.subplots()更复合 Python 从 0 开始进行索引的习惯。</p><h2 id="plt-GridSpec：更复杂的排列"><a href="#plt-GridSpec：更复杂的排列" class="headerlink" title="plt.GridSpec：更复杂的排列"></a><strong>plt.GridSpec：更复杂的排列</strong></h2><p>当你需要子图表在网格中占据多行或多列时，plt.GridSpec()正是你所需要的。plt.GridSpec()对象并不自己创建图表；它只是一个可以被传递给plt.subplot()的参数。例如，一个两行三列并带有指定的宽度高度间隔的 gridspec 可以如下创建：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grid = plt.GridSpec(<span class="number">2</span>, <span class="number">3</span>, wspace=<span class="number">0.4</span>, hspace=<span class="number">0.3</span>)</span><br></pre></td></tr></table></figure><p>使用这个对象我们可以指定子图表的位置和占据的网格，仅需要使用熟悉的 Python 切片语法即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plt.subplot(grid[<span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line">plt.subplot(grid[<span class="number">0</span>, <span class="number">1</span>:])</span><br><span class="line">plt.subplot(grid[<span class="number">1</span>, :<span class="number">2</span>])</span><br><span class="line">plt.subplot(grid[<span class="number">1</span>, <span class="number">2</span>]);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224449.png" alt=""></p><p>这种灵活的网格对齐控制方式有着广泛的应用。作者经常在需要创建多个直方图的联合图表中使用这种方法，如下例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构建二维正态分布数据</span></span><br><span class="line">mean = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">cov = [[<span class="number">1</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">2</span>]]</span><br><span class="line">x, y = np.random.multivariate_normal(mean, cov, <span class="number">3000</span>).T</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用GridSpec创建网格并加入子图表</span></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">6</span>, <span class="number">6</span>))</span><br><span class="line">grid = plt.GridSpec(<span class="number">4</span>, <span class="number">4</span>, hspace=<span class="number">0.2</span>, wspace=<span class="number">0.2</span>)</span><br><span class="line">main_ax = fig.add_subplot(grid[:<span class="number">-1</span>, <span class="number">1</span>:])</span><br><span class="line">y_hist = fig.add_subplot(grid[:<span class="number">-1</span>, <span class="number">0</span>], xticklabels=[], sharey=main_ax)</span><br><span class="line">x_hist = fig.add_subplot(grid[<span class="number">-1</span>, <span class="number">1</span>:], yticklabels=[], sharex=main_ax)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在主图表中绘制散点图</span></span><br><span class="line">main_ax.plot(x, y, <span class="string">'ok'</span>, markersize=<span class="number">3</span>, alpha=<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分别在x轴和y轴方向绘制直方图</span></span><br><span class="line">x_hist.hist(x, <span class="number">40</span>, histtype=<span class="string">'stepfilled'</span>,</span><br><span class="line">            orientation=<span class="string">'vertical'</span>, color=<span class="string">'gray'</span>)</span><br><span class="line">x_hist.invert_yaxis() <span class="comment"># x轴方向（右下）直方图倒转y轴方向</span></span><br><span class="line"></span><br><span class="line">y_hist.hist(y, <span class="number">40</span>, histtype=<span class="string">'stepfilled'</span>,</span><br><span class="line">            orientation=<span class="string">'horizontal'</span>, color=<span class="string">'gray'</span>)</span><br><span class="line">y_hist.invert_xaxis() <span class="comment"># y轴方向（左上）直方图倒转x轴方向</span></span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224452.png" alt=""></p><p>这种沿着数据各自方向分布并绘制相应图表的需求是很通用的，因此在 Seaborn 包中它们有专门的 API 来实现。</p><h1 id="9-文本和标注"><a href="#9-文本和标注" class="headerlink" title="9.文本和标注"></a><strong>9.文本和标注</strong></h1><p>创建一个优秀的可视化图表的关键在于引导读者，让他们能理解图表所讲述的故事。在一些情况下，这个故事可以通过纯图像的方式表达，不需要额外添加文字，但是在另外一些情况中，图表需要文字的提示和标签才能将故事讲好。也许标注最基本的类型就是图表的标签和标题，但是其中的选项参数却有很多。让我们在本节中使用一些数据来创建可视化图表并标注这些图表来表达这些有趣的信息。首先还是需要将要用到的模块和包导入 notebook：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> mpl</span><br><span class="line">plt.style.use(<span class="string">'seaborn-whitegrid'</span>)</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br></pre></td></tr></table></figure><h2 id="例子：节假日对美国出生率的影响"><a href="#例子：节假日对美国出生率的影响" class="headerlink" title="例子：节假日对美国出生率的影响"></a><strong>例子：节假日对美国出生率的影响</strong></h2><p>本例中的数据可以在 <a href="https://raw.githubusercontent.com/jakevdp/data-CDCbirths/master/births.csv" target="_blank" rel="noopener">https://raw.githubusercontent.com/jakevdp/data-CDCbirths/master/births.csv</a> 下载。</p><p>我们先按照前面的方式进行同样的数据清洗程序，然后以图表展示这个结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">births = pd.read_csv(<span class="string">r'D:\python\Github学习材料\Python数据科学手册\data\births.csv'</span>)</span><br><span class="line"></span><br><span class="line">quartiles = np.percentile(births[<span class="string">'births'</span>], [<span class="number">25</span>, <span class="number">50</span>, <span class="number">75</span>])</span><br><span class="line">mu, sig = quartiles[<span class="number">1</span>], <span class="number">0.74</span> * (quartiles[<span class="number">2</span>] - quartiles[<span class="number">0</span>])</span><br><span class="line">births = births.query(<span class="string">'(births &gt; @mu - 5 * @sig) &amp; (births &lt; @mu + 5 * @sig)'</span>)</span><br><span class="line"></span><br><span class="line">births[<span class="string">'day'</span>] = births[<span class="string">'day'</span>].astype(int)</span><br><span class="line"></span><br><span class="line">births.index = pd.to_datetime(<span class="number">10000</span> * births.year +</span><br><span class="line">                              <span class="number">100</span> * births.month +</span><br><span class="line">                              births.day, format=<span class="string">'%Y%m%d'</span>)</span><br><span class="line">births_by_date = births.pivot_table(<span class="string">'births'</span>,</span><br><span class="line">                                    [births.index.month, births.index.day])</span><br><span class="line">births_by_date.index = [pd.datetime(<span class="number">2012</span>, month, day)</span><br><span class="line">                        <span class="keyword">for</span> (month, day) <span class="keyword">in</span> births_by_date.index]</span><br></pre></td></tr></table></figure><p>C:\Users\gdc\Anaconda3\lib\site-packages\ipykernel_launcher.py:15: FutureWarning: The pandas.datetime class is deprecated and will be removed from pandas in a future version. Import from datetime module instead.<br>  from ipykernel import kernelapp as app</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">12</span>, <span class="number">4</span>))</span><br><span class="line">births_by_date.plot(ax=ax);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224456.png" alt=""></p><p>当我们绘制了这样的图表来表达数据时，如果我们能对一些图表的特性作出标注来，这对吸引读者的注意力通常是非常有帮助的。这可以通过调用plt.text或ax.text函数来实现，它们可以在某个特定的 x，y 轴位置输出一段文字：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">12</span>, <span class="number">4</span>))</span><br><span class="line">births_by_date.plot(ax=ax)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在折线的特殊位置标注文字</span></span><br><span class="line">style = dict(size=<span class="number">10</span>, color=<span class="string">'gray'</span>)</span><br><span class="line"></span><br><span class="line">ax.text(<span class="string">'2012-1-1'</span>, <span class="number">3950</span>, <span class="string">"New Year's Day"</span>, **style)</span><br><span class="line">ax.text(<span class="string">'2012-7-4'</span>, <span class="number">4250</span>, <span class="string">"Independence Day"</span>, ha=<span class="string">'center'</span>, **style)</span><br><span class="line">ax.text(<span class="string">'2012-9-4'</span>, <span class="number">4850</span>, <span class="string">"Labor Day"</span>, ha=<span class="string">'center'</span>, **style)</span><br><span class="line">ax.text(<span class="string">'2012-10-31'</span>, <span class="number">4600</span>, <span class="string">"Halloween"</span>, ha=<span class="string">'right'</span>, **style)</span><br><span class="line">ax.text(<span class="string">'2012-11-25'</span>, <span class="number">4450</span>, <span class="string">"Thanksgiving"</span>, ha=<span class="string">'center'</span>, **style)</span><br><span class="line">ax.text(<span class="string">'2012-12-25'</span>, <span class="number">3850</span>, <span class="string">"Christmas "</span>, ha=<span class="string">'right'</span>, **style)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置标题和y轴标签</span></span><br><span class="line">ax.set(title=<span class="string">'USA births by day of year (1969-1988)'</span>,</span><br><span class="line">       ylabel=<span class="string">'average daily births'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置x轴标签月份居中</span></span><br><span class="line">ax.xaxis.set_major_locator(mpl.dates.MonthLocator())</span><br><span class="line">ax.xaxis.set_minor_locator(mpl.dates.MonthLocator(bymonthday=<span class="number">15</span>))</span><br><span class="line">ax.xaxis.set_major_formatter(plt.NullFormatter())</span><br><span class="line">ax.xaxis.set_minor_formatter(mpl.dates.DateFormatter(<span class="string">'%h'</span>));</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224500.png" alt=""></p><p>ax.text方法接收 x 位置、y 位置、一个字符串和额外可选的关键字参数可以用来设置颜色、大小、样式、对齐等文本格式。上面我们使用了ha=’right’和ha=’center’，这里的ha是<em>hirizonal alignment（水平对齐）</em>的缩写。要查阅更多的可用参数，请查看plt.text()和mpl.text.Text()的文档字符串内容。</p><h2 id="转换和文本位置"><a href="#转换和文本位置" class="headerlink" title="转换和文本位置"></a><strong>转换和文本位置</strong></h2><p>在刚才的例子中，我们将文字标注根据数据位置进行了定位。有些时候我们需要将文字标注独立于数据位置而根据图表位置进行定位。Matplotlib 通过转换完成这项工作。</p><p>任何的图形显示框架都需要在坐标系统之间进行转换的机制。例如，一个数据点位于  被转换为图表中的某个位置，进而转换为屏幕上显示的像素。这样的坐标转换在数学上都相对来说比较直接，而且 Matplotlib 提供了一系列的工具实现了转换（这些工具可以在matplotlib.transforms模块中找到）。</p><p>一般来说，用户很少需要关注这些转换的细节，但是当考虑将文本在图表上展示时，这些知识却比较有用。在这种情况中，下面三种定义好的转换是比较有用的：</p><ul><li>ax.transData：与数据坐标相关的转换</li><li>ax.tranAxes：与 Axes 尺寸相关的转换（单位是 axes 的宽和高）</li><li>ax.tranFigure：与 figure 尺寸相关的转换（单位是 figure 的宽和高）</li></ul><p>下面我们来看看使用这些转换将文字写在图表中不同位置的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(facecolor=<span class="string">'lightgray'</span>)</span><br><span class="line">ax.axis([<span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">10</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># transform=ax.transData是默认的，这里写出来是为了明确对比</span></span><br><span class="line">ax.text(<span class="number">1</span>, <span class="number">5</span>, <span class="string">". Data: (1, 5)"</span>, transform=ax.transData)</span><br><span class="line">ax.text(<span class="number">0.5</span>, <span class="number">0.1</span>, <span class="string">". Axes: (0.5, 0.1)"</span>, transform=ax.transAxes)</span><br><span class="line">ax.text(<span class="number">0.2</span>, <span class="number">0.2</span>, <span class="string">". Figure: (0.2, 0.2)"</span>, transform=fig.transFigure);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224504.png" alt=""></p><p>注意默认情况下，文字是在指定坐标位置靠左对齐的：这里每个字符串开始的”.”的位置就是每种转换的坐标位置。</p><p>transData坐标给定的是通常使用的 x 和 y 轴坐标位置。transAxes坐标给定的是从 axes 左下角开始算起（白色区域）的坐标位置，使用的是宽度和长度的占比。transFigure坐标类似，给定的是从 figure 左下角开始算起（灰色区域）的坐标位置，使用的也是宽度和长度的占比。</p><p>因此如果我们改变了轴的最大长度，只有transData坐标会收到影响，其他两个还是保持在相同位置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ax.set_xlim(<span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">ax.set_ylim(<span class="number">-6</span>, <span class="number">6</span>)</span><br><span class="line">fig</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224507.png" alt=""></p><p>这个变化可以通过动态改变轴的最大长度看的更加清楚：如果你在 notebook 执行这段代码，你可以将%matplotlib inline改为%matplotlib notebook，然后使用图表的菜单来交互式的改变图表。</p><h2 id="箭头和标注"><a href="#箭头和标注" class="headerlink" title="箭头和标注"></a><strong>箭头和标注</strong></h2><p>除了刻度标签和文字标签，另一种常用的标注是箭头。</p><p>在 Matplotlib 中绘制箭头通常比你想象的难得多。虽然有plt.arrow()函数，作者不建议使用它：这个函数绘制的箭头是一个 SVG 对象，因此在图表使用不同的比例的情况会产生问题，结果通常不能让用户满意。因此，作者建议使用plt.annotate()函数。这个函数会绘制一些文字以及一个箭头，并且箭头可以非常灵活的进行配置。</p><p>下面我们提供一些参数来使用annotate函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line"></span><br><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">20</span>, <span class="number">1000</span>)</span><br><span class="line">ax.plot(x, np.cos(x))</span><br><span class="line">ax.axis(<span class="string">'equal'</span>)</span><br><span class="line"></span><br><span class="line">ax.annotate(<span class="string">'local maximum'</span>, xy=(<span class="number">6.28</span>, <span class="number">1</span>), xytext=(<span class="number">10</span>, <span class="number">4</span>),</span><br><span class="line">            arrowprops=dict(facecolor=<span class="string">'black'</span>, shrink=<span class="number">0.05</span>))</span><br><span class="line"></span><br><span class="line">ax.annotate(<span class="string">'local minimum'</span>, xy=(<span class="number">5</span> * np.pi, <span class="number">-1</span>), xytext=(<span class="number">2</span>, <span class="number">-6</span>),</span><br><span class="line">            arrowprops=dict(arrowstyle=<span class="string">"-&gt;"</span>,</span><br><span class="line">                            connectionstyle=<span class="string">"angle3,angleA=0,angleB=-90"</span>));</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224511.png" alt=""></p><p>箭头的样式是使用箭头属性字典值进行控制的，里面有很多可用的参数。这些参数在 Matplotlib 的在线文档中已经有了很详细的说明，因此在这里就不将这部分内容重复介绍一遍了。我们在前面出生率图上再使用一些参数进行更多的说明：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">12</span>, <span class="number">4</span>))</span><br><span class="line">births_by_date.plot(ax=ax)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为图表添加标注</span></span><br><span class="line">ax.annotate(<span class="string">"New Year's Day"</span>, xy=(<span class="string">'2012-1-1'</span>, <span class="number">4100</span>),  xycoords=<span class="string">'data'</span>,</span><br><span class="line">            xytext=(<span class="number">50</span>, <span class="number">-30</span>), textcoords=<span class="string">'offset points'</span>,</span><br><span class="line">            arrowprops=dict(arrowstyle=<span class="string">"-&gt;"</span>,</span><br><span class="line">                            connectionstyle=<span class="string">"arc3,rad=-0.2"</span>))</span><br><span class="line"></span><br><span class="line">ax.annotate(<span class="string">"Independence Day"</span>, xy=(<span class="string">'2012-7-4'</span>, <span class="number">4250</span>),  xycoords=<span class="string">'data'</span>,</span><br><span class="line">            bbox=dict(boxstyle=<span class="string">"round"</span>, fc=<span class="string">"none"</span>, ec=<span class="string">"gray"</span>),</span><br><span class="line">            xytext=(<span class="number">10</span>, <span class="number">-40</span>), textcoords=<span class="string">'offset points'</span>, ha=<span class="string">'center'</span>,</span><br><span class="line">            arrowprops=dict(arrowstyle=<span class="string">"-&gt;"</span>))</span><br><span class="line"></span><br><span class="line">ax.annotate(<span class="string">'Labor Day'</span>, xy=(<span class="string">'2012-9-4'</span>, <span class="number">4850</span>), xycoords=<span class="string">'data'</span>, ha=<span class="string">'center'</span>,</span><br><span class="line">            xytext=(<span class="number">0</span>, <span class="number">-20</span>), textcoords=<span class="string">'offset points'</span>)</span><br><span class="line">ax.annotate(<span class="string">''</span>, xy=(<span class="string">'2012-9-1'</span>, <span class="number">4850</span>), xytext=(<span class="string">'2012-9-7'</span>, <span class="number">4850</span>),</span><br><span class="line">            xycoords=<span class="string">'data'</span>, textcoords=<span class="string">'data'</span>,</span><br><span class="line">            arrowprops=&#123;<span class="string">'arrowstyle'</span>: <span class="string">'|-|,widthA=0.2,widthB=0.2'</span>, &#125;)</span><br><span class="line"></span><br><span class="line">ax.annotate(<span class="string">'Halloween'</span>, xy=(<span class="string">'2012-10-31'</span>, <span class="number">4600</span>),  xycoords=<span class="string">'data'</span>,</span><br><span class="line">            xytext=(<span class="number">-80</span>, <span class="number">-40</span>), textcoords=<span class="string">'offset points'</span>,</span><br><span class="line">            arrowprops=dict(arrowstyle=<span class="string">"fancy"</span>,</span><br><span class="line">                            fc=<span class="string">"0.6"</span>, ec=<span class="string">"none"</span>,</span><br><span class="line">                            connectionstyle=<span class="string">"angle3,angleA=0,angleB=-90"</span>))</span><br><span class="line"></span><br><span class="line">ax.annotate(<span class="string">'Thanksgiving'</span>, xy=(<span class="string">'2012-11-25'</span>, <span class="number">4500</span>),  xycoords=<span class="string">'data'</span>,</span><br><span class="line">            xytext=(<span class="number">-120</span>, <span class="number">-60</span>), textcoords=<span class="string">'offset points'</span>,</span><br><span class="line">            bbox=dict(boxstyle=<span class="string">"round4,pad=.5"</span>, fc=<span class="string">"0.9"</span>),</span><br><span class="line">            arrowprops=dict(arrowstyle=<span class="string">"-&gt;"</span>,</span><br><span class="line">                            connectionstyle=<span class="string">"angle,angleA=0,angleB=80,rad=20"</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ax.annotate(<span class="string">'Christmas'</span>, xy=(<span class="string">'2012-12-25'</span>, <span class="number">3850</span>),  xycoords=<span class="string">'data'</span>,</span><br><span class="line">             xytext=(<span class="number">-30</span>, <span class="number">0</span>), textcoords=<span class="string">'offset points'</span>,</span><br><span class="line">             size=<span class="number">13</span>, ha=<span class="string">'right'</span>, va=<span class="string">"center"</span>,</span><br><span class="line">             bbox=dict(boxstyle=<span class="string">"round"</span>, alpha=<span class="number">0.1</span>),</span><br><span class="line">             arrowprops=dict(arrowstyle=<span class="string">"wedge,tail_width=0.5"</span>, alpha=<span class="number">0.1</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置图表标题和坐标轴标记</span></span><br><span class="line">ax.set(title=<span class="string">'USA births by day of year (1969-1988)'</span>,</span><br><span class="line">       ylabel=<span class="string">'average daily births'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置月份坐标居中显示</span></span><br><span class="line">ax.xaxis.set_major_locator(mpl.dates.MonthLocator())</span><br><span class="line">ax.xaxis.set_minor_locator(mpl.dates.MonthLocator(bymonthday=<span class="number">15</span>))</span><br><span class="line">ax.xaxis.set_major_formatter(plt.NullFormatter())</span><br><span class="line">ax.xaxis.set_minor_formatter(mpl.dates.DateFormatter(<span class="string">'%h'</span>));</span><br><span class="line"></span><br><span class="line">ax.set_ylim(<span class="number">3600</span>, <span class="number">5400</span>);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224515.png" alt=""></p><p>上图中箭头和文字框都非常详尽了：可以看出你几乎可以使用plt.annotate创建任何你想要的箭头样式。不幸的是，这意味着这种特性都需要手工进行调整，因此如果需要获得印刷质量的图像，这将是一个非常耗费时间的工作。最后，必须指出，上述这种多种样式混合的方式来展现数据肯定不是最佳实践，这里只是为了尽可能多的介绍可用的参数。</p><p>更多关于 Matplotlib 的箭头和标注样式的讨论和例子可以访问 Matplotlib gallery，特别是标注演示[6]。</p><h1 id="10-自定义刻度"><a href="#10-自定义刻度" class="headerlink" title="10.自定义刻度"></a><strong>10.自定义刻度</strong></h1><p>Matplotlib 默认的刻度标志和格式被设计成能满足许多通用场景的需求，但是不会是所有图表的最佳选择。本节会介绍一些调整刻度位置和格式的例子来说明自定义刻度的使用。</p><p>在介绍例子之前，我们应该加深对 Matplotlib 图表的对象层次的理解。Matplotlib 的设计目标是展示在图表中的所有内容都会表达成为 Python 的对象：例如，回忆前面我们介绍过figure指的是用来展示图表所有内容的方框。每个 Matplotlib 对象也被设计为其子对象的一个容器：例如figure对象中可以包含一个或多个axes对象，每个axes对象都依次包含着其他用来展示图表的内容对象。</p><p>刻度也不例外。每个axes对象都有着属性xaxis和yaxis，表示 x 和 y 轴，其中包含着所有的属性用来指代轴的线、刻度和标签。</p><h2 id="主要的和次要的刻度"><a href="#主要的和次要的刻度" class="headerlink" title="主要的和次要的刻度"></a><strong>主要的和次要的刻度</strong></h2><p>在每个坐标轴上，都有主要的刻度和次要的刻度概念。正如名字指代的，主要刻度通常是大的和更多用到的，而次要刻度通常是小的。默认 Matplotlib 很少使用次要刻度，但是在对数图表中我们可能会看到它们：</p><p>在 Matplotlib 2.0 之后，当 axis 的跨度过大时，默认次要刻度将会不再展示，因此，下面的代码经过了修改，加上了 xlim 和 ylim 参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.style.use(<span class="string">'classic'</span>)</span><br><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">ax = plt.axes(xscale=<span class="string">'log'</span>, yscale=<span class="string">'log'</span>, xlim=[<span class="number">10e-5</span>, <span class="number">10e5</span>], ylim=[<span class="number">10e-5</span>, <span class="number">10e5</span>])</span><br><span class="line">ax.grid();</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224519.png" alt=""></p><p>我们看到每个主要刻度显示了一个大的标志和标签，而每个次要刻度显示了一个小的刻度标志没有标签。</p><p>这些刻度属性，位置和标签，都可以使用每个轴的formatter和locator对象进行个性化设置。下面我们来查看一下 x 轴的相应对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(ax.xaxis.get_major_locator())</span><br><span class="line">print(ax.xaxis.get_minor_locator())</span><br></pre></td></tr></table></figure><p><matplotlib.ticker.LogLocator object at 0x000001E8074AF108></p><matplotlib.ticker.LogLocator object at 0x000001E8074AD908><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(ax.xaxis.get_major_formatter())</span><br><span class="line">print(ax.xaxis.get_minor_formatter())</span><br></pre></td></tr></table></figure><p><matplotlib.ticker.LogFormatterSciNotation object at 0x000001E8074AEB88></p><matplotlib.ticker.LogFormatterSciNotation object at 0x000001E8074ADB48><p><matplotlib.ticker.LogFormatterSciNotation object at 0x000001E8074AEB88></p><matplotlib.ticker.LogFormatterSciNotation object at 0x000001E8074ADB48><p>我们看到主要和次要刻度的位置都是使用LogLocator来设置的（对于对数图表来说那是理所当然的）。然而次要刻度的标签的格式是NullFormatter：这表示次要刻度不会显示标签。</p><p>译者注：新版 Matplotlib 已经修改，可以看到 Formatter 都统一成为了 LogFormatterSciNotation，再根据图表实际情况选择是否展示标签。</p><p>下面我们就可以开始介绍一些设置这些 locator 和 formatter 的例子了。</p><h2 id="隐藏刻度和标签"><a href="#隐藏刻度和标签" class="headerlink" title="隐藏刻度和标签"></a><strong>隐藏刻度和标签</strong></h2><p>也许最常见的刻度/标签格式设置的操作是隐藏刻度或标签。这可以通过使用plt.NullLocator()和plt.NullFormatter()来设置，如下例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ax &#x3D; plt.axes()</span><br><span class="line">ax.plot(np.random.rand(50))</span><br><span class="line"></span><br><span class="line">ax.yaxis.set_major_locator(plt.NullLocator())</span><br><span class="line">ax.xaxis.set_major_formatter(plt.NullFormatter())</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224522.png" alt=""></p><p>注意上图中我们去除了 x 轴的标签（但是保留了刻度或网格线），y 轴的刻度和标签都被去除了。图表中没有刻度和标签在很多情况下很有用，例如，当你希望展示一个图像的网格。比方说，考虑下面的图表，包含着不同的头像，一个很常见的监督机器学习问题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(<span class="number">5</span>, <span class="number">5</span>, figsize=(<span class="number">5</span>, <span class="number">5</span>))</span><br><span class="line">fig.subplots_adjust(hspace=<span class="number">0</span>, wspace=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从scikit-learn载入头像数据集</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> fetch_olivetti_faces</span><br><span class="line">faces = fetch_olivetti_faces().images</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        ax[i, j].xaxis.set_major_locator(plt.NullLocator())</span><br><span class="line">        ax[i, j].yaxis.set_major_locator(plt.NullLocator())</span><br><span class="line">        ax[i, j].imshow(faces[<span class="number">10</span> * i + j], cmap=<span class="string">"bone"</span>)</span><br></pre></td></tr></table></figure><p>downloading Olivetti faces from<br><a href="https://ndownloader.figshare.com/files/5976027" target="_blank" rel="noopener">https://ndownloader.figshare.com/files/5976027</a><br>to C:\Users\gdc\scikit_learn_data</p><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224526.png" alt=""></p><p>注意上图中每张图像都有它自己的 axes，我们将每一个 axes 的 locator 都设置为 null 因为这些刻度值（像素值）在这里并没有任何实际意义。</p><h2 id="减少或增加刻度的数量"><a href="#减少或增加刻度的数量" class="headerlink" title="减少或增加刻度的数量"></a><strong>减少或增加刻度的数量</strong></h2><p>默认设置的一个常见问题是当子图表较小时，刻度标签可能会粘在一起。我们可以从下面例子看到：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(<span class="number">4</span>, <span class="number">4</span>, sharex=<span class="literal">True</span>, sharey=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224529.png" alt=""></p><p>特别是 x 轴，标签的数字就快重叠在一起了，这让这些标签难以认清。我们可以通过plt.MaxNLocator()来修正这点，用它可以设置最大展示刻度的数量。Matplotlib 会自己计算按照这个最大数量计算的刻度位置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对x和y轴设置刻度最大数量</span></span><br><span class="line"><span class="keyword">for</span> axi <span class="keyword">in</span> ax.flat:</span><br><span class="line">    axi.xaxis.set_major_locator(plt.MaxNLocator(<span class="number">3</span>))</span><br><span class="line">    axi.yaxis.set_major_locator(plt.MaxNLocator(<span class="number">3</span>))</span><br><span class="line">fig</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224532.png" alt=""></p><p>上图就清晰多了。如果你希望对于刻度位置进行更加精细的控制，你可以使用plt.MultipleLocator，我们会接下来讨论这个对象。</p><h2 id="复杂的刻度格式"><a href="#复杂的刻度格式" class="headerlink" title="复杂的刻度格式"></a><strong>复杂的刻度格式</strong></h2><p>Matplotlib 的默认刻度格式只能在很多常见情况下工作良好，但是在特殊情况下你会希望能够更多的进行个性化。考虑下面的正弦和余弦图表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 绘制正弦和余弦图表</span></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">3</span> * np.pi, <span class="number">1000</span>)</span><br><span class="line">ax.plot(x, np.sin(x), lw=<span class="number">3</span>, label=<span class="string">'Sine'</span>)</span><br><span class="line">ax.plot(x, np.cos(x), lw=<span class="number">3</span>, label=<span class="string">'Cosine'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置网格、图例和轴极限</span></span><br><span class="line">ax.grid(<span class="literal">True</span>)</span><br><span class="line">ax.legend(frameon=<span class="literal">False</span>)</span><br><span class="line">ax.axis(<span class="string">'equal'</span>)</span><br><span class="line">ax.set_xlim(<span class="number">0</span>, <span class="number">3</span> * np.pi);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224535.png" alt=""></p><p>这里有几个我们希望进行的改变。首先，如果刻度的间距和网格线是  的倍数会显得更加自然。我们可以通过MultipleLocator来设置它，这个对象用来设置刻度的配置。为了更直观，我们设置主要刻度为  位置，设置次要刻度为  位置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ax.xaxis.set_major_locator(plt.MultipleLocator(np.pi / <span class="number">2</span>))</span><br><span class="line">ax.xaxis.set_minor_locator(plt.MultipleLocator(np.pi / <span class="number">4</span>))</span><br><span class="line">fig</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224538.png" alt=""></p><p>但是上图看起来有点傻：我们可以看出刻度确实是  的倍数，但是使用了小数的展示让它们看起来很奇怪。要修正这些标签，我们需要修改刻度的 formatter。在这种情况中，没有內建的 formatter 可以给我们使用，因此我们使用<code>plt.FuncFormatter</code>，这个对象能够接受一个用户自定义的函数来提供对于刻度标签的精细控制：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">format_func</span><span class="params">(value, tick_number)</span>:</span></span><br><span class="line">    <span class="comment"># N是pi/2的倍数</span></span><br><span class="line">    N = int(np.round(<span class="number">2</span> * value / np.pi))</span><br><span class="line">    <span class="keyword">if</span> N == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"0"</span> <span class="comment"># 0点</span></span><br><span class="line">    <span class="keyword">elif</span> N == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">r"$\frac&#123;\pi&#125;&#123;2&#125;$"</span> <span class="comment"># pi/2</span></span><br><span class="line">    <span class="keyword">elif</span> N == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">r"$\pi$"</span> <span class="comment"># pi</span></span><br><span class="line">    <span class="keyword">elif</span> N % <span class="number">2</span> &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">r"$\frac&#123;&#123;%d&#125;\pi&#125;&#123;2&#125;$"</span> %N <span class="comment"># n*pi/2 n是奇数</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">r"$&#123;0&#125;\pi$"</span>.format(N // <span class="number">2</span>) <span class="comment"># n*pi n是整数</span></span><br><span class="line"></span><br><span class="line">ax.xaxis.set_major_formatter(plt.FuncFormatter(format_func))</span><br><span class="line">fig</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224541.png" alt=""></p><p>上图看起来好多了。注意到我们使用到了 Matplotlib 的 LaTeX 支持，使用美元符号将 LaTeX 字符串括起来。这是用来展示数学符号和公式的简便方法：在这个例子中”$\pi$”被渲染成希腊字母 。</p><p>plt.FuncFomatter()提供了对于图表刻度最高级的自定义和精细控制，并且当你需要创建需要印刷或出版的图表时非常方便。</p><h2 id="Formatter-和-Locator-总结"><a href="#Formatter-和-Locator-总结" class="headerlink" title="Formatter 和 Locator 总结"></a><strong>Formatter 和 Locator 总结</strong></h2><p>我们已经介绍了一些 formatter 和 locator。在最后我们通过将內建的 locator 和 formatter 参数列出来对本节做一个总结。要获得更多相关内容，请参阅文档或 Matplotlib 的在线文档。下表中列出的对象在plt命名空间中都是有效的：</p><div class="table-container"><table><thead><tr><th style="text-align:left">Locator 对象</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>NullLocator</code></td><td style="text-align:left">无刻度</td></tr><tr><td style="text-align:left"><code>FixedLocator</code></td><td style="text-align:left">固定刻度位置</td></tr><tr><td style="text-align:left"><code>IndexLocator</code></td><td style="text-align:left">序号图表刻度 (例如 x = range(len(y)))</td></tr><tr><td style="text-align:left"><code>LinearLocator</code></td><td style="text-align:left">从最小到最大值的均匀分割刻度</td></tr><tr><td style="text-align:left"><code>LogLocator</code></td><td style="text-align:left">从最小到最大值的对数分割刻度</td></tr><tr><td style="text-align:left"><code>MultipleLocator</code></td><td style="text-align:left">某个基数的倍数刻度</td></tr><tr><td style="text-align:left"><code>MaxNLocator</code></td><td style="text-align:left">刻度数量最大值</td></tr><tr><td style="text-align:left"><code>AutoLocator</code></td><td style="text-align:left">默认的刻度数量最大值</td></tr><tr><td style="text-align:left"><code>AutoMinorLocator</code></td><td style="text-align:left">默认的次要刻度</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:left">Formatter 对象</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>NullFormatter</code></td><td style="text-align:left">无标签</td></tr><tr><td style="text-align:left"><code>IndexFormatter</code></td><td style="text-align:left">从一个列表获得标签</td></tr><tr><td style="text-align:left"><code>FixedFormatter</code></td><td style="text-align:left">从固定的字符串设置标签</td></tr><tr><td style="text-align:left"><code>FuncFormatter</code></td><td style="text-align:left">使用自定义函数设置标签</td></tr><tr><td style="text-align:left"><code>FormatStrFormatter</code></td><td style="text-align:left">使用一个格式化字符串设置标签</td></tr><tr><td style="text-align:left"><code>ScalarFormatter</code></td><td style="text-align:left">默认的标量标签</td></tr><tr><td style="text-align:left"><code>LogFormatter</code></td><td style="text-align:left">默认的对数标签</td></tr></tbody></table></div><h1 id="11-在-matplotlib-中创建三维图表"><a href="#11-在-matplotlib-中创建三维图表" class="headerlink" title="11.在 matplotlib 中创建三维图表"></a><strong>11.在 matplotlib 中创建三维图表</strong></h1><p>Matplotlib 最开始被设计为仅支持二维的图表。到 1.0 版本发布左右，一些三维图表的工具在二维展示的基础上被创建了出来，结果就是 Matplotlib 提供了一个方便的（同时也是有限的）的可用于三维数据可视化的一套工具。三维图表可以使用载入mplot3d工具包来激活，这个包会随着 Matplotlib 自动安装：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mpl_toolkits <span class="keyword">import</span> mplot3d</span><br></pre></td></tr></table></figure><p>一旦模块被导入，三维 axes 就可以像其他普通 axes 一样通过关键字参数projection=’3d’来创建：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax = plt.axes(projection=<span class="string">'3d'</span>)</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224547.png" alt=""></p><p>三维 axes 激活后，我们可以在上面绘制不同的三维图表类型。三维图表在 notebook 中使用交互式图表展示会优于使用静态展示；回忆我们前面介绍过，你可以使用%matplotlib notebook而不是%matplotlib inline来激活交互式展示模式。</p><h2 id="三维的点和线"><a href="#三维的点和线" class="headerlink" title="三维的点和线"></a><strong>三维的点和线</strong></h2><p>三维图表中最基础的是使用(x, y, z)坐标定义的一根线或散点的集合。前面介绍过普通的二维图表，作为类比，使用ax.plot3D和ax.scatter3D函数可以创建三维折线和散点图。这两个函数的签名与二维的版本基本一致，你可以参考[简单折线图]和[简单散点图]来复习一下这部分的内容。下面我们绘制一个三维中的三角螺旋，在线的附近在绘制一些随机的点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ax = plt.axes(projection=<span class="string">'3d'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 三维螺旋线的数据</span></span><br><span class="line">zline = np.linspace(<span class="number">0</span>, <span class="number">15</span>, <span class="number">1000</span>)</span><br><span class="line">xline = np.sin(zline)</span><br><span class="line">yline = np.cos(zline)</span><br><span class="line">ax.plot3D(xline, yline, zline, <span class="string">'gray'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 三维散点的数据</span></span><br><span class="line">zdata = <span class="number">15</span> * np.random.random(<span class="number">100</span>)</span><br><span class="line">xdata = np.sin(zdata) + <span class="number">0.1</span> * np.random.randn(<span class="number">100</span>)</span><br><span class="line">ydata = np.cos(zdata) + <span class="number">0.1</span> * np.random.randn(<span class="number">100</span>)</span><br><span class="line">ax.scatter3D(xdata, ydata, zdata, c=zdata, cmap=<span class="string">'Greens'</span>);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224555.png" alt=""></p><p>注意默认情况下，图中的散点会有透明度的区别，用于体现在图中散点的深度。虽然三维效果在静态图像中难以显示，你可以使用交互式的视图来获得更佳的三维直观效果。</p><h2 id="三维轮廓图"><a href="#三维轮廓图" class="headerlink" title="三维轮廓图"></a><strong>三维轮廓图</strong></h2><p>类似于我们在[密度和轮廓图]中介绍的内容，mplot3d也包含着能够创建三维浮雕图像的工具。就像二维的ax.contour图表，ax.contour3D要求输入数据的格式是二维普通网格上计算得到的 Z 轴的数据值。下面我们展示一个三维的正弦函数轮廓图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> np.sin(np.sqrt(x ** <span class="number">2</span> + y ** <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">x = np.linspace(<span class="number">-6</span>, <span class="number">6</span>, <span class="number">30</span>)</span><br><span class="line">y = np.linspace(<span class="number">-6</span>, <span class="number">6</span>, <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">X, Y = np.meshgrid(x, y)</span><br><span class="line">Z = f(X, Y)</span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax = plt.axes(projection=<span class="string">'3d'</span>)</span><br><span class="line">ax.contour3D(X, Y, Z, <span class="number">50</span>, cmap=<span class="string">'binary'</span>)</span><br><span class="line">ax.set_xlabel(<span class="string">'x'</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">'y'</span>)</span><br><span class="line">ax.set_zlabel(<span class="string">'z'</span>);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224600.png" alt=""></p><p>有时候默认的视角角度不是最理想的，在这种情况下我们可以使用view_init函数来设置水平角和方位角。在下面的例子中，我们使用的是 60° 的水平角（即以 60° 俯视 x-y 平面）和 35° 的方位角（即将 z 轴逆时针旋转 35°）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ax.view_init(<span class="number">60</span>, <span class="number">35</span>)</span><br><span class="line">fig</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224603.png" alt=""></p><p>同样，注意到当使用 Matplotlib 交互式展示时，这样的旋转可以通过鼠标点击和拖拽来实现。</p><h2 id="框线图和表面图"><a href="#框线图和表面图" class="headerlink" title="框线图和表面图"></a><strong>框线图和表面图</strong></h2><p>使用网格数据生成的三维图表还有框线图和表面图。这两种图表将网格数据投射到特定的三维表面，能够使得结果图像非常直观和具有说服力。下面是一个框线图的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fig = plt.figure()</span><br><span class="line">ax = plt.axes(projection=<span class="string">'3d'</span>)</span><br><span class="line">ax.plot_wireframe(X, Y, Z, color=<span class="string">'black'</span>)</span><br><span class="line">ax.set_title(<span class="string">'wireframe'</span>);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224606.png" alt=""></p><p>表面图类似框线图，区别在于每个框线构成的多边形都使用颜色进行了填充。添加色图用于填充多边形能够让图形表面展示出来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ax = plt.axes(projection=<span class="string">'3d'</span>)</span><br><span class="line">ax.plot_surface(X, Y, Z, rstride=<span class="number">1</span>, cstride=<span class="number">1</span>,</span><br><span class="line">                cmap=<span class="string">'viridis'</span>, edgecolor=<span class="string">'none'</span>)</span><br><span class="line">ax.set_title(<span class="string">'surface'</span>);</span><br></pre></td></tr></table></figure><p>注意虽<img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224611.png" alt="">然每个颜色填充的表面都是二维的，但是表面的边缘不需要是直线构成的。下面的例子使用surface3D绘制了一个部分极坐标网格，能够让我们切入到函数内部观察效果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">r = np.linspace(<span class="number">0</span>, <span class="number">6</span>, <span class="number">20</span>)</span><br><span class="line">theta = np.linspace(<span class="number">-0.9</span> * np.pi, <span class="number">0.8</span> * np.pi, <span class="number">40</span>)</span><br><span class="line">r, theta = np.meshgrid(r, theta)</span><br><span class="line"></span><br><span class="line">X = r * np.sin(theta)</span><br><span class="line">Y = r * np.cos(theta)</span><br><span class="line">Z = f(X, Y)</span><br><span class="line"></span><br><span class="line">ax = plt.axes(projection=<span class="string">'3d'</span>)</span><br><span class="line">ax.plot_surface(X, Y, Z, rstride=<span class="number">1</span>, cstride=<span class="number">1</span>,</span><br><span class="line">                cmap=<span class="string">'viridis'</span>, edgecolor=<span class="string">'none'</span>);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224615.png" alt=""></p><h2 id="表面三角剖分"><a href="#表面三角剖分" class="headerlink" title="表面三角剖分"></a><strong>表面三角剖分</strong></h2><p>在一些应用场合中，上面的这种均匀网格绘制的图表方式太过于局限和不方便。在这些情况下，三角剖分的图表可以派上用场。如果我们并不是使用笛卡尔坐标系或极坐标系的网格来绘制三维图表，而是使用一组随机的点来绘制三维图表呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">theta = <span class="number">2</span> * np.pi * np.random.random(<span class="number">1000</span>)</span><br><span class="line">r = <span class="number">6</span> * np.random.random(<span class="number">1000</span>)</span><br><span class="line">x = np.ravel(r * np.sin(theta))</span><br><span class="line">y = np.ravel(r * np.cos(theta))</span><br><span class="line">z = f(x, y)</span><br></pre></td></tr></table></figure><p>有了上面的数据之后，我们可以使用它们来绘制一张散点图表现出样本所在表面的情况：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ax = plt.axes(projection=<span class="string">'3d'</span>)</span><br><span class="line">ax.scatter(x, y, z, c=z, cmap=<span class="string">'viridis'</span>, linewidth=<span class="number">0.5</span>);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224628.png" alt=""></p><p>上图并未形象的表示出表面情况。这种情况下我们可以使用ax.plot_trisurf函数，它能首先根据我们的数据输入找到各点内在的三角函数形式，然后绘制表面（注意的是这里的 x，y，z 是一维的数组）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ax = plt.axes(projection=<span class="string">'3d'</span>)</span><br><span class="line">ax.plot_trisurf(x, y, z,</span><br><span class="line">                cmap=<span class="string">'viridis'</span>, edgecolor=<span class="string">'none'</span>);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224632.png" alt=""></p><p>上图的结果很显然没有使用网格绘制表面图那么清晰，但是对于我们并不是使用函数构建数据样本（数据样本通常来自真实世界的采样）的情况下，这能提供很大的帮助。例如我们下面会看到，能使用这种方法绘制一条三维的莫比乌斯环。</p><h3 id="例子：绘制莫比乌斯环"><a href="#例子：绘制莫比乌斯环" class="headerlink" title="例子：绘制莫比乌斯环"></a><strong>例子：绘制莫比乌斯环</strong></h3><p>莫比乌斯环是使用一条纸条，一端翻折后与另一端粘起来形成的环形。在拓扑学中这是非常有趣的一个形状，因为它只有一个面。我们下面使用 Matplotlib 的三维工具绘制莫比乌斯环。创建莫比乌斯环的关键在于能参数化它：莫比乌斯环是一个二维的环状结构，因此我们需要两个特定的维度。一个我们称为 ，取值范围是  表示整个环状，还有一个称为 ，取值范围是  表示纸带的宽度：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">theta = np.linspace(<span class="number">0</span>, <span class="number">2</span> * np.pi, <span class="number">30</span>)</span><br><span class="line">w = np.linspace(<span class="number">-0.25</span>, <span class="number">0.25</span>, <span class="number">8</span>)</span><br><span class="line">w, theta = np.meshgrid(w, theta)</span><br></pre></td></tr></table></figure><p>有了这两个参数之后，我们需要确定莫比乌斯环上<em>(x, y, z)</em>坐标的位置。</p><p>仔细思考一下，我们会发现在莫比乌斯环上有两个自转发生：一个是纸带绕环形中央位置的旋转（我们称为 ），另一个纸带绕着中间轴线的旋转（我们称为 ）。纸带中央位置旋转一整圈  时，纸带绕中间轴线旋转刚好半圈 ，我们将整个旋转均匀分布在纸带上时，就会有 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">phi = <span class="number">0.5</span> * theta</span><br></pre></td></tr></table></figure><p>现在我们已经有了所有需要获得三维坐标值的参数了。我们定义  为每个坐标点距离环形中间的位置，使用它来计算最终  三维坐标系的坐标值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># r是坐标点距离环形中心的距离值</span></span><br><span class="line">r = <span class="number">1</span> + w * np.cos(phi)</span><br><span class="line"><span class="comment"># 利用简单的三角函数知识算得x，y，z坐标值</span></span><br><span class="line">x = np.ravel(r * np.cos(theta))</span><br><span class="line">y = np.ravel(r * np.sin(theta))</span><br><span class="line">z = np.ravel(w * np.sin(phi))</span><br></pre></td></tr></table></figure><p>最后，为了绘制对象，我们必须保证三角剖分是正确的。实现这个最好的方法是在底层的参数上面实现三角剖分，最后让 Matplotlib 将这个三角剖分投射到三维空间中形成莫比乌斯环。下面的代码最终绘制图形：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在底层参数的基础上进行三角剖分</span></span><br><span class="line"><span class="keyword">from</span> matplotlib.tri <span class="keyword">import</span> Triangulation</span><br><span class="line">tri = Triangulation(np.ravel(w), np.ravel(theta))</span><br><span class="line"></span><br><span class="line">ax = plt.axes(projection=<span class="string">'3d'</span>)</span><br><span class="line">ax.plot_trisurf(x, y, z, triangles=tri.triangles,</span><br><span class="line">                cmap=<span class="string">'viridis'</span>, linewidths=<span class="number">0.2</span>);</span><br><span class="line"></span><br><span class="line">ax.set_xlim(<span class="number">-1</span>, <span class="number">1</span>); ax.set_ylim(<span class="number">-1</span>, <span class="number">1</span>); ax.set_zlim(<span class="number">-1</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/微信图片_20201102224638.png" alt=""></p><p>结合这些技巧，能够为你提供在 Matplotlib 创建和展现大量三维对象和模式的能力。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h3><p>[1]PythonDataScienceHandbook:<a href="https://github.com/jakevdp/PythonDataScienceHandbook/tree/master/notebooks" target="_blank" rel="noopener">https://github.com/jakevdp/PythonDataScienceHandbook/tree/master/notebooks</a></p><p>[2]Pythons数据科学:<a href="https://github.com/wangyingsm/Python-Data-Science-Handbook/tree/master/notebooks" target="_blank" rel="noopener">https://github.com/wangyingsm/Python-Data-Science-Handbook/tree/master/notebooks</a></p><p>[3]颜色代码:<a href="https://www.w3schools.com/colors/colors_names.asp" target="_blank" rel="noopener">https://www.w3schools.com/colors/colors_names.asp</a></p><p>[4]秒差距:<a href="https://zh.wikipedia.org/wiki/%E7%A7%92%E5%B7%AE%E8%B7%9D" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E7%A7%92%E5%B7%AE%E8%B7%9D</a></p><p>[5]有趣讨论:<a href="http://Matplotlib.org/1.4.1/users/colormaps.html" target="_blank" rel="noopener">http://Matplotlib.org/1.4.1/users/colormaps.html</a></p><p>[6]标注示:<a href="http://matplotlib.org/examples/pylab_examples/annotation_demo2.html" target="_blank" rel="noopener">http://matplotlib.org/examples/pylab_examples/annotation_demo2.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Matplotlib </tag>
            
            <tag> 数据可视化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习之神经网络实现MNIST手写字识别</title>
      <link href="/2020/10/25/Neural-networks-realizes-MNIST-handwriting-recognition/"/>
      <url>/2020/10/25/Neural-networks-realizes-MNIST-handwriting-recognition/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="一、神经网络原理"><a href="#一、神经网络原理" class="headerlink" title="一、神经网络原理"></a>一、神经网络原理</h2><p>线性回归（Linear Regression）和逻辑回归（Logistic Regression）通常用来处理线性模型，如果利用线性回归或逻辑回归对多特征的非线性问题进行分类，则涉及太多特征组合的计算，往往导致计算负荷增大，并不适合解决这类问题。</p><p>假设我们需要训练一个模型用来判断一张图片中是否出现汽车，可能有很多用来训练模型的数据，这些图片有的包含小汽车，有的没有，利用这些图片的一个个像素值作为特征，训练一个满足这样功能的模型。训练过程需要处理可能百万级别甚至更多的数据，对于这样问题通常采用神经网络（Neural Networks）解决。</p><a id="more"></a><h3 id="1-1-模型"><a href="#1-1-模型" class="headerlink" title="1.1 模型"></a>1.1 模型</h3><p><a href="https://imgchr.com/i/BQBHfO" target="_blank" rel="noopener"><img src="/loading.gif" data-original="https://s1.ax1x.com/2020/10/27/BQBHfO.png" alt=""></a></p><p>这个一个简单的3层神经网络，第一层为输入层（Input Layers），最后一层为输出层（Output Layers），中间层称为隐藏层（Hidden Layers）</p><h3 id="1-2-前向传播"><a href="#1-2-前向传播" class="headerlink" title="1.2 前向传播"></a>1.2 前向传播</h3><h4 id="1-2-1-激活函数"><a href="#1-2-1-激活函数" class="headerlink" title="1.2.1 激活函数"></a>1.2.1 激活函数</h4><p>（1）Sigmoid函数</p><p>一个常见的激活函数，其数学表达式为<a href="https://www.codecogs.com/eqnedit.php?latex=Sig(z)=\frac{1}{1&plus;e^{-z}}" target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?Sig(z)=\frac{1}{1&plus;e^{-z}}" title="Sig(z)=\frac{1}{1+e^{-z}}" /></a>。</p><p>Python实现代码为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>/(<span class="number">1</span>+np.exp(-x))</span><br></pre></td></tr></table></figure><p>（2）ReLU函数</p><p>计算速度更快，是目前的主流激活函数。数学表达式为：<a href="https://www.codecogs.com/eqnedit.php?latex=ReLU(x)=\left\{\begin{matrix}&space;x&space;&&space;if&space;x>0\\&space;0&space;&&space;if&space;x\leq&space;0&space;\end{matrix}\right." target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?ReLU(x)=\left\{\begin{matrix}&space;x&space;&&space;if&space;x>0\\&space;0&space;&&space;if&space;x\leq&space;0&space;\end{matrix}\right." title="ReLU(x)=\left\{\begin{matrix} x & if x>0\\ 0 & if x\leq 0 \end{matrix}\right." /></a></p><p>Python实现代码为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">relu</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> np.maximum(<span class="number">0</span>,x)</span><br></pre></td></tr></table></figure><h4 id="1-2-2-前向传播过程"><a href="#1-2-2-前向传播过程" class="headerlink" title="1.2.2 前向传播过程"></a>1.2.2 前向传播过程</h4><p>除输入层外，每一层神经元都有前一层的神经元作为本层神经元的输入，本层神经元的输出又可以作为下一层神经元的输入，依次向前传播最终得到一个输出值，这个由输入值经输入层经过一系列处理最终到达输出层得到输出值的过程称为前向传播。</p><p><a href="https://imgchr.com/i/B0npqA" target="_blank" rel="noopener"><img src="/loading.gif" data-original="https://s1.ax1x.com/2020/11/01/B0npqA.md.png" alt=""></a></p><p>其中x1, x2, x3是输入单元，即原始的输入数据，a1, a2, a3是中间单元，负责将输入的数据处理然后传递到下一层，最后是输出单元，负责计算<a href="https://www.codecogs.com/eqnedit.php?latex=h_{\Theta&space;}(x)" target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?h_{\Theta&space;}(x)" title="h_{\Theta }(x)" /></a>。计算的过程中为每一层都添加了一个偏置（bias unit）。</p><p>上图中<a href="https://www.codecogs.com/eqnedit.php?latex=\Theta&space;_{1}" target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?\Theta&space;_{1}" title="\Theta _{1}" /></a>，<a href="https://www.codecogs.com/eqnedit.php?latex=\Theta&space;_{2}" target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?\Theta&space;_{2}" title="\Theta _{2}" /></a>分别代表输入层到隐藏层的权重和隐藏层到输出层的权重，对于上图的网络模型激活单元和输出分别表达为：</p><p><a href="https://www.codecogs.com/eqnedit.php?latex=a_{1}^{(2)}=g(\Theta&space;_{10}^{(1)}x_{0}&plus;\Theta&space;_{11}^{(1)}x_{1}&plus;\Theta&space;_{12}^{(1)}x_{2}&plus;\Theta&space;_{13}^{(1)}x_{3})" target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?a_{1}^{(2)}=g(\Theta&space;_{10}^{(1)}x_{0}&plus;\Theta&space;_{11}^{(1)}x_{1}&plus;\Theta&space;_{12}^{(1)}x_{2}&plus;\Theta&space;_{13}^{(1)}x_{3})" title="a_{1}^{(2)}=g(\Theta _{10}^{(1)}x_{0}+\Theta _{11}^{(1)}x_{1}+\Theta _{12}^{(1)}x_{2}+\Theta _{13}^{(1)}x_{3})" /></a></p><p><a href="https://www.codecogs.com/eqnedit.php?latex=a_{2}^{(2)}=g(\Theta&space;_{20}^{(1)}x_{0}&plus;\Theta&space;_{21}^{(1)}x_{1}&plus;\Theta&space;_{22}^{(1)}x_{2}&plus;\Theta&space;_{23}^{(1)}x_{3})" target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?a_{2}^{(2)}=g(\Theta&space;_{20}^{(1)}x_{0}&plus;\Theta&space;_{21}^{(1)}x_{1}&plus;\Theta&space;_{22}^{(1)}x_{2}&plus;\Theta&space;_{23}^{(1)}x_{3})" title="a_{2}^{(2)}=g(\Theta _{20}^{(1)}x_{0}+\Theta _{21}^{(1)}x_{1}+\Theta _{22}^{(1)}x_{2}+\Theta _{23}^{(1)}x_{3})" /></a></p><p><a href="https://www.codecogs.com/eqnedit.php?latex=a_{3}^{(2)}=g(\Theta&space;_{30}^{(1)}x_{0}&plus;\Theta&space;_{31}^{(1)}x_{1}&plus;\Theta&space;_{32}^{(1)}x_{2}&plus;\Theta&space;_{33}^{(1)}x_{3})" target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?a_{3}^{(2)}=g(\Theta&space;_{30}^{(1)}x_{0}&plus;\Theta&space;_{31}^{(1)}x_{1}&plus;\Theta&space;_{32}^{(1)}x_{2}&plus;\Theta&space;_{33}^{(1)}x_{3})" title="a_{3}^{(2)}=g(\Theta _{30}^{(1)}x_{0}+\Theta _{31}^{(1)}x_{1}+\Theta _{32}^{(1)}x_{2}+\Theta _{33}^{(1)}x_{3})" /></a></p><p><a href="https://www.codecogs.com/eqnedit.php?latex=h_{\Theta&space;}(x)=g(\Theta&space;_{10}^{(2)}a_{0}^{(2)}&plus;\Theta&space;_{11}^{(2)}a_{1}^{(2)}&plus;\Theta&space;_{12}^{(2)}a_{2}^{(2)}&plus;\Theta&space;_{13}^{(2)}a_{3}^{(2)})" target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?h_{\Theta&space;}(x)=g(\Theta&space;_{10}^{(2)}a_{0}^{(2)}&plus;\Theta&space;_{11}^{(2)}a_{1}^{(2)}&plus;\Theta&space;_{12}^{(2)}a_{2}^{(2)}&plus;\Theta&space;_{13}^{(2)}a_{3}^{(2)})" title="h_{\Theta }(x)=g(\Theta _{10}^{(2)}a_{0}^{(2)}+\Theta _{11}^{(2)}a_{1}^{(2)}+\Theta _{12}^{(2)}a_{2}^{(2)}+\Theta _{13}^{(2)}a_{3}^{(2)})" /></a></p><p>如此，从左到右的算法称为前向传播算法，实际应用中为了计算方便通常是以矩阵方式计算的。</p><p>Python实现示例（示例不能直接运行）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self,X)</span>:</span></span><br><span class="line">    <span class="comment"># 前向传播算法forward_propagation，实现预测</span></span><br><span class="line">    self.a1 = X.T</span><br><span class="line">    self.z2 = np.dot(self.W1,self.a1)+self.b1</span><br><span class="line">    self.a2 = relu(self.z2)</span><br><span class="line">    self.z3 = np.dot(self.W2,self.a2)+self.b2</span><br><span class="line">    self.a3 = relu(self.z3)</span><br><span class="line">    out = self.a3</span><br><span class="line">    p = np.argmax(out, axis=<span class="number">0</span>)  <span class="comment"># 输出层的最大索引下标即为标签值，标签值0-9</span></span><br><span class="line">    <span class="keyword">return</span> p</span><br></pre></td></tr></table></figure><h3 id="1-3-代价函数"><a href="#1-3-代价函数" class="headerlink" title="1.3 代价函数"></a>1.3 代价函数</h3><p><a href="https://imgchr.com/i/B0M4F1" target="_blank" rel="noopener"><img src="/loading.gif" data-original="https://s1.ax1x.com/2020/11/01/B0M4F1.md.png" alt=""></a></p><p>通过代价函数观察预测的结果与真实情况的误差有多大。</p><h3 id="1-4-反向传播算法"><a href="#1-4-反向传播算法" class="headerlink" title="1.4 反向传播算法"></a>1.4 反向传播算法</h3><p>一般的训练算法可以分为两个阶段：</p><p>（1）求解代价函数关于权值（参数）的导数。（BP）</p><p>（2）用得到的导数进一步计算权值的调整量。（梯度下降等优化算法）</p><p>反向传播（BP）算法主要应用第一阶段,非常高效的计算这些导数。</p><h4 id="1-4-1-推导过程"><a href="#1-4-1-推导过程" class="headerlink" title="1.4.1 推导过程"></a>1.4.1 推导过程</h4><p>假设有一个四层的神经网络，其相关参数为： Sl=4, L=4（其中L表示网络层数，Sl表示l层有多少个神经元），用<a href="https://www.codecogs.com/eqnedit.php?latex=\sigma" target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?\sigma" title="\sigma" /></a>表示误差，结合前面介绍的前向传播过程，则：</p><p><a href="https://www.codecogs.com/eqnedit.php?latex=\sigma&space;^{(4)}=a^{(4)}-y" target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?\sigma&space;^{(4)}=a^{(4)}-y" title="\sigma ^{(4)}=a^{(4)}-y" /></a></p><p>前一层误差为：<a href="https://www.codecogs.com/eqnedit.php?latex=\sigma&space;^{(3)}=(\Theta&space;^{(3)})^{T}\sigma&space;^{(4)}*g^{'}(z^{(2)})" target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?\sigma&space;^{(3)}=(\Theta&space;^{(3)})^{T}\sigma&space;^{(4)}*g^{'}(z^{(2)})" title="\sigma ^{(3)}=(\Theta ^{(3)})^{T}\sigma ^{(4)}*g^{'}(z^{(3)})" /></a></p><p>其中<a href="https://www.codecogs.com/eqnedit.php?latex=g^{'}(z^{(2)})" target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?g^{'}(z^{(2)})" title="g^{'}(z^{(2)})" /></a>是Sig函数的导数。</p><p>接着第二层的误差为：<a href="https://www.codecogs.com/eqnedit.php?latex=\sigma&space;^{(2)}=(\Theta&space;^{(2)})^{T}\sigma&space;^{(3)}*g^{'}(z^{(2)})" target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?\sigma&space;^{(2)}=(\Theta&space;^{(2)})^{T}\sigma&space;^{(3)}*g^{'}(z^{(2)})" title="\sigma ^{(2)}=(\Theta ^{(2)})^{T}\sigma ^{(3)}*g^{'}(z^{(2)})" /></a></p><p>第一层是输入变量，不存在误差，此时不考虑正则项，则有：<a href="https://www.codecogs.com/eqnedit.php?latex=\frac{\partial&space;}{\partial&space;\Theta&space;_{ij}^{(l)}}J(\Theta&space;)=a_{ij}^{(l)}\sigma&space;_{i}^{l&plus;1}" target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?\frac{\partial&space;}{\partial&space;\Theta&space;_{ij}^{(l)}}J(\Theta&space;)=a_{ij}^{(l)}\sigma&space;_{i}^{l&plus;1}" title="\frac{\partial }{\partial \Theta _{ij}^{(l)}}J(\Theta )=a_{ij}^{(l)}\sigma _{i}^{l+1}" /></a></p><p>要求的导数 = 权值输出端单元的误差项 * 权值输入端单元的激活值。</p><p>Python实现示例（示例不能直接运行）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#反向传播：</span></span><br><span class="line"><span class="comment">#1、m表示样本个数</span></span><br><span class="line"><span class="comment">#2、梯度下降，更新W和b</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backward</span><span class="params">(self, dAL)</span>:</span></span><br><span class="line">    m=<span class="number">60000</span></span><br><span class="line">    dZ3=np.multiply(dAL,relu_derivative(self.z3))</span><br><span class="line">    dW2=np.dot(dZ3, self.a2.T)/m</span><br><span class="line">    db2=np.mean(dZ3,axis=<span class="number">1</span>)</span><br><span class="line">    dAL_1 = np.dot(self.W2.T, dZ3)</span><br><span class="line">    dZ2 = np.multiply(dAL_1, relu_derivative(self.z2))</span><br><span class="line">    dW1 = np.dot(dZ2, self.a1.T) / m</span><br><span class="line">    db1 = np.mean(dZ2, axis=<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 更新权值</span></span><br><span class="line">    self.W2-=self.lr*dW2</span><br><span class="line">    self.b2-=self.lr*db2</span><br><span class="line">    self.W1 -= self.lr * dW1</span><br><span class="line">    self.b1 -= self.lr * db1</span><br></pre></td></tr></table></figure><h2 id="二、数据集解析"><a href="#二、数据集解析" class="headerlink" title="二、数据集解析"></a>二、数据集解析</h2><p>数据集来源：<a href="http://yann.lecun.com/exdb/mnist，选用MNIST手写字数据集训练神经网络，数据集使用Python模块Struct解析二进制文件。手写字特征为28*28=784个像素点，输出为手写字值。解析过程不做详细介绍，其数据解析的一种Python实现为：" target="_blank" rel="noopener">http://yann.lecun.com/exdb/mnist，选用MNIST手写字数据集训练神经网络，数据集使用Python模块Struct解析二进制文件。手写字特征为28*28=784个像素点，输出为手写字值。解析过程不做详细介绍，其数据解析的一种Python实现为：</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line">file1=<span class="string">"./MNIST_data/train-images.idx3-ubyte"</span></span><br><span class="line">file2=<span class="string">"./MNIST_data/train-labels.idx1-ubyte"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_images_ana</span><span class="params">(filepath)</span>:</span></span><br><span class="line">    <span class="string">"""解析图片数据集 .idx3-ubyte格式"""</span></span><br><span class="line">    <span class="comment"># 以二进制方式读取文件</span></span><br><span class="line">    <span class="keyword">with</span> open(filepath,<span class="string">'rb'</span>) <span class="keyword">as</span> fbj:</span><br><span class="line">        bin_data=fbj.read()</span><br><span class="line">    offset=<span class="number">0</span></span><br><span class="line">    magic_num,image_num,rows_num,column_num=struct.unpack_from(<span class="string">'&gt;iiii'</span>,bin_data,offset)</span><br><span class="line">    offset+=struct.calcsize(<span class="string">'&gt;iiii'</span>)</span><br><span class="line">    imgsize=image_num*rows_num*column_num</span><br><span class="line">    fmt_image=<span class="string">'&gt;'</span>+str(imgsize)+<span class="string">'B'</span>      <span class="comment"># 训练集数据有60000*28*28</span></span><br><span class="line">    images=struct.unpack_from(fmt_image,bin_data,offset)</span><br><span class="line">    img=np.reshape(images,(image_num,rows_num*column_num))     <span class="comment"># 构造一个60000*784的矩阵</span></span><br><span class="line">    <span class="keyword">return</span> img</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_labels_ana</span><span class="params">(filepath)</span>:</span></span><br><span class="line">    <span class="string">"""解析特征数据集 .idx1-ubyte格式"""</span></span><br><span class="line">    <span class="comment"># 以二进制格式处理文件</span></span><br><span class="line">    <span class="keyword">with</span> open(filepath,<span class="string">'rb'</span>) <span class="keyword">as</span> fbj:</span><br><span class="line">        bin_data=fbj.read()</span><br><span class="line">    offset=<span class="number">0</span></span><br><span class="line">    magic_num,items_num=struct.unpack_from(<span class="string">'&gt;ii'</span>,bin_data,offset)</span><br><span class="line">    offset+=struct.calcsize(<span class="string">'&gt;ii'</span>)</span><br><span class="line">    fmt_label=<span class="string">'&gt;'</span>+str(items_num)+<span class="string">'B'</span></span><br><span class="line">    labels=struct.unpack_from(fmt_label,bin_data,offset)</span><br><span class="line">    label=np.reshape(labels,[items_num])</span><br><span class="line">    <span class="keyword">return</span> label</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    imgs=train_images_ana(file1)</span><br><span class="line">    print(np.shape(imgs[<span class="number">1</span>]))</span><br><span class="line">    labels = train_labels_ana(file2)</span><br><span class="line">    print(labels)</span><br><span class="line">    print(np.shape(labels[<span class="number">1</span>]))</span><br><span class="line">    <span class="comment"># 查看前10个手写字灰度图</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        img=np.reshape(imgs[i],[<span class="number">28</span>,<span class="number">28</span>])</span><br><span class="line">        plt.imshow(img,cmap=<span class="string">'gray'</span>)</span><br><span class="line">        print(labels[i])</span><br><span class="line">        plt.show()</span><br></pre></td></tr></table></figure><h2 id="三、神经网络搭建"><a href="#三、神经网络搭建" class="headerlink" title="三、神经网络搭建"></a>三、神经网络搭建</h2><p>搭建一个三层神经网络，输入层、隐藏层、输出层节点分别为：784，100，10。</p><h2 id="四、附录"><a href="#四、附录" class="headerlink" title="四、附录"></a>四、附录</h2><p>network.py文件，构建神经网络类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> activation_func <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> loss <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Network</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,inputnodes,hidnodes,outputnodes,learning_rate)</span>:</span></span><br><span class="line">        self.innodes = inputnodes</span><br><span class="line">        self.hidnodes = hidnodes</span><br><span class="line">        self.outnodes = outputnodes</span><br><span class="line">        self.lr = learning_rate</span><br><span class="line">        <span class="comment">#各层权重 偏置</span></span><br><span class="line">        self.W1 = np.random.randn(self.hidnodes, self.innodes) * <span class="number">0.01</span></span><br><span class="line">        self.W2 = np.random.randn(self.outnodes, self.hidnodes) * <span class="number">0.01</span></span><br><span class="line">        self.b1 = np.random.randn(self.hidnodes, <span class="number">1</span>) * <span class="number">0.01</span></span><br><span class="line">        self.b2 = np.random.randn(self.outnodes, <span class="number">1</span>) * <span class="number">0.01</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self,X)</span>:</span></span><br><span class="line">        <span class="comment"># 前向传播算法forward_propagation，实现预测</span></span><br><span class="line">        self.a1 = X.T</span><br><span class="line">        self.z2 = np.dot(self.W1,self.a1)+self.b1</span><br><span class="line">        self.a2 = relu(self.z2)</span><br><span class="line">        self.z3 = np.dot(self.W2,self.a2)+self.b2</span><br><span class="line">        self.a3 = relu(self.z3)</span><br><span class="line">        out = self.a3</span><br><span class="line">        p = np.argmax(out, axis=<span class="number">0</span>)  <span class="comment"># 输出层的最大索引下标即为标签值，标签值0-9</span></span><br><span class="line">        <span class="keyword">return</span> p</span><br><span class="line"></span><br><span class="line">    <span class="comment">#反向传播：</span></span><br><span class="line">    <span class="comment">#1、m表示样本个数</span></span><br><span class="line">    <span class="comment">#2、梯度下降，更新W和b</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backward</span><span class="params">(self, dAL)</span>:</span></span><br><span class="line">        m=<span class="number">60000</span></span><br><span class="line">        dZ3=np.multiply(dAL,relu_derivative(self.z3))</span><br><span class="line">        dW2=np.dot(dZ3, self.a2.T)/m</span><br><span class="line">        db2=np.mean(dZ3,axis=<span class="number">1</span>)</span><br><span class="line">        dAL_1 = np.dot(self.W2.T, dZ3)</span><br><span class="line">        dZ2 = np.multiply(dAL_1, relu_derivative(self.z2))</span><br><span class="line">        dW1 = np.dot(dZ2, self.a1.T) / m</span><br><span class="line">        db1 = np.mean(dZ2, axis=<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 梯度下降</span></span><br><span class="line">        self.W2-=self.lr*dW2</span><br><span class="line">        self.b2-=self.lr*db2</span><br><span class="line">        self.W1 -= self.lr * dW1</span><br><span class="line">        self.b1 -= self.lr * db1</span><br></pre></td></tr></table></figure><p>loss.py文件，损失函数计算代价。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment">#交叉熵损失函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cross_entropy</span><span class="params">(y, y_predict)</span>:</span></span><br><span class="line">    y_predict = np.clip(y_predict,<span class="number">1e-10</span>,<span class="number">1</span><span class="number">-1e-10</span>) <span class="comment">#防止0*log(0)出现。导致计算结果变为NaN</span></span><br><span class="line">    <span class="keyword">return</span> -(y * np.log(y_predict) + (<span class="number">1</span> - y) * np.log(<span class="number">1</span> - y_predict))</span><br><span class="line"></span><br><span class="line"><span class="comment">#交叉熵损失函数的导函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cross_entropy_der</span><span class="params">(y,y_predict)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> -y/y_predict+(<span class="number">1</span>-y)/(<span class="number">1</span>-y_predict)</span><br></pre></td></tr></table></figure><p>activation.py文件，激活函数及其导数实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    激活函数</span></span><br><span class="line"><span class="string">    选择非线性的激活函数处理非线性假设</span></span><br><span class="line"><span class="string">    常用激活函数relu、sigmoid</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>/(<span class="number">1</span>+np.exp(-x))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">relu</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> np.maximum(<span class="number">0</span>,x)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sig_derivative</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="comment">#sig函数求导</span></span><br><span class="line">    fx=sigmoid(x)</span><br><span class="line">    <span class="keyword">return</span> fx*(<span class="number">1</span>-fx)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">relu_derivative</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (x&gt;=<span class="number">0</span>).astype(np.float64)</span><br></pre></td></tr></table></figure><p>load_data.py文件，加载数据集。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line">file1=<span class="string">"./MNIST_data/train-images.idx3-ubyte"</span></span><br><span class="line">file2=<span class="string">"./MNIST_data/train-labels.idx1-ubyte"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_images_ana</span><span class="params">(filepath)</span>:</span></span><br><span class="line">    <span class="string">"""解析图片数据集 .idx3-ubyte格式"""</span></span><br><span class="line">    <span class="comment"># 以二进制方式读取文件</span></span><br><span class="line">    <span class="keyword">with</span> open(filepath,<span class="string">'rb'</span>) <span class="keyword">as</span> fbj:</span><br><span class="line">        bin_data=fbj.read()</span><br><span class="line"></span><br><span class="line">    offset=<span class="number">0</span></span><br><span class="line">    magic_num,image_num,rows_num,column_num=struct.unpack_from(<span class="string">'&gt;iiii'</span>,bin_data,offset)</span><br><span class="line">    offset+=struct.calcsize(<span class="string">'&gt;iiii'</span>)</span><br><span class="line">    imgsize=image_num*rows_num*column_num</span><br><span class="line">    fmt_image=<span class="string">'&gt;'</span>+str(imgsize)+<span class="string">'B'</span>      <span class="comment"># 训练集数据有60000*28*28</span></span><br><span class="line">    images=struct.unpack_from(fmt_image,bin_data,offset)</span><br><span class="line">    img=np.reshape(images,(image_num,rows_num*column_num))     <span class="comment"># 构造一个60000*784的矩阵</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> img</span><br><span class="line"></span><br><span class="line"><span class="comment">#print(magic_num,image_num,rows_num,column_num)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_labels_ana</span><span class="params">(filepath)</span>:</span></span><br><span class="line">    <span class="string">"""解析特征数据集 .idx1-ubyte格式"""</span></span><br><span class="line">    <span class="comment"># 以二进制格式处理文件</span></span><br><span class="line">    <span class="keyword">with</span> open(filepath,<span class="string">'rb'</span>) <span class="keyword">as</span> fbj:</span><br><span class="line">        bin_data=fbj.read()</span><br><span class="line"></span><br><span class="line">    offset=<span class="number">0</span></span><br><span class="line">    magic_num,items_num=struct.unpack_from(<span class="string">'&gt;ii'</span>,bin_data,offset)</span><br><span class="line">    offset+=struct.calcsize(<span class="string">'&gt;ii'</span>)</span><br><span class="line">    fmt_label=<span class="string">'&gt;'</span>+str(items_num)+<span class="string">'B'</span></span><br><span class="line">    labels=struct.unpack_from(fmt_label,bin_data,offset)</span><br><span class="line">    label=np.reshape(labels,[items_num])</span><br><span class="line">    <span class="keyword">return</span> label</span><br></pre></td></tr></table></figure><p>train.py文件，训练模型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> network <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> load_data <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">input_nodes = <span class="number">784</span></span><br><span class="line">hidden_nodes = <span class="number">100</span></span><br><span class="line">output_nodes = <span class="number">10</span></span><br><span class="line">learning_rate = <span class="number">0.1</span></span><br><span class="line">n = Network(input_nodes, hidden_nodes, output_nodes, learning_rate)</span><br><span class="line"></span><br><span class="line">X=train_images_ana(file1)</span><br><span class="line">Y=train_labels_ana(file2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练神经网络</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    cnt = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">60000</span>):</span><br><span class="line">        Y_predict = n.predict(np.mat(X[i]))</span><br><span class="line">        <span class="keyword">if</span> (Y[i]==Y_predict):</span><br><span class="line">            cnt+=<span class="number">1</span></span><br><span class="line">        dA = cross_entropy_der(np.mat(Y[i]),Y_predict)</span><br><span class="line">        n.backward(dA)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'epoch %d:accurac=%f'</span>%(epoch,cnt/<span class="number">60000</span>))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Machine-Learning </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 神经网络 </tag>
            
            <tag> MNIST </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MNIST手写字符集的数据解析</title>
      <link href="/2020/10/18/Data-analysis-of-MNIST-handwritten-character-set/"/>
      <url>/2020/10/18/Data-analysis-of-MNIST-handwritten-character-set/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p>最近在做MNIST手写字识别，官方MNIST数据集为 .idx3-ubyte 格式，程序无法直接读取，涉及MNIST数据集的解析。</p><p>MNIST数据集：<a href="http://yann.lecun.com/exdb/mnist/" target="_blank" rel="noopener">http://yann.lecun.com/exdb/mnist/</a></p><a id="more"></a><h3 id="2-数据集说明"><a href="#2-数据集说明" class="headerlink" title="2.数据集说明"></a>2.数据集说明</h3><p>官网数据集说明：</p><blockquote><p>train-images-idx3-ubyte.gz:  training set images (9912422 bytes)<br>train-labels-idx1-ubyte.gz:  training set labels (28881 bytes)<br>t10k-images-idx3-ubyte.gz:   test set images (1648877 bytes)<br>t10k-labels-idx1-ubyte.gz:   test set labels (4542 bytes)</p></blockquote><p>一个四个文件，训练图片集、训练特征集、测试图片集、测试特征集。</p><p>官网对图片集和特征集的说明如下：</p><p><strong>TRAINING SET LABEL FILE (train-labels-idx1-ubyte):</strong></p><div class="table-container"><table><thead><tr><th>[offset]</th><th>[type]</th><th style="text-align:left">[value]</th><th>[description]</th></tr></thead><tbody><tr><td>0000</td><td>32 bit integer</td><td style="text-align:left">0x00000801(2049)</td><td>magic number (MSB first)</td></tr><tr><td>0004</td><td>32 bit integer</td><td style="text-align:left">60000</td><td>number of items</td></tr><tr><td>0008</td><td>unsigned byte</td><td style="text-align:left">??</td><td>label</td></tr><tr><td>0009</td><td>unsigned byte</td><td style="text-align:left">??</td><td>label</td></tr><tr><td>……</td><td></td><td style="text-align:left"></td></tr></tbody></table></div><p>The labels values are 0 to 9.</p><p><strong>TRAINING SET IMAGE FILE (train-images-idx3-ubyte):</strong></p><div class="table-container"><table><thead><tr><th>[offset]</th><th>[type]</th><th>[value]</th><th>[description]</th></tr></thead><tbody><tr><td>0000</td><td>32 bit integer</td><td>0x00000803(2051)</td><td>magic number</td></tr><tr><td>0004</td><td>32 bit integer</td><td>60000</td><td>number of images</td></tr><tr><td>0008</td><td>32 bit integer</td><td>28</td><td>number of rows</td></tr><tr><td>0012</td><td>32 bit integer</td><td>28</td><td>number of columns</td></tr><tr><td>0016</td><td>unsigned byte</td><td>??</td><td>pixel</td></tr><tr><td>0017</td><td>unsigned byte</td><td>??</td><td>pixel</td></tr><tr><td>……</td><td></td><td></td></tr></tbody></table></div><p>Pixels are organized row-wise. Pixel values are 0 to 255. 0 means background (white), 255 means foreground (black).</p><h3 id="3-二进制文件解析"><a href="#3-二进制文件解析" class="headerlink" title="3.二进制文件解析"></a>3.二进制文件解析</h3><p>Python中解析二进制文件需要用到Struct模块，Struct的基本函数说明参考：<a href="https://wnxy.xyz/2020/10/17/Daily-usage-of-Struct-module-in-Python/">https://wnxy.xyz/2020/10/17/Daily-usage-of-Struct-module-in-Python/</a></p><p>相关代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line">file1=<span class="string">"./MNIST_data/train-images.idx3-ubyte"</span></span><br><span class="line">file2=<span class="string">"./MNIST_data/train-labels.idx1-ubyte"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_images_ana</span><span class="params">(filepath)</span>:</span></span><br><span class="line">    <span class="string">"""解析图片数据集 .idx3-ubyte格式"""</span></span><br><span class="line">    <span class="comment"># 以二进制方式读取文件</span></span><br><span class="line">    <span class="keyword">with</span> open(filepath,<span class="string">'rb'</span>) <span class="keyword">as</span> fbj:</span><br><span class="line">        bin_data=fbj.read()</span><br><span class="line">    offset=<span class="number">0</span></span><br><span class="line">    magic_num,image_num,rows_num,column_num=struct.unpack_from(<span class="string">'&gt;iiii'</span>,bin_data,offset)</span><br><span class="line">    offset+=struct.calcsize(<span class="string">'&gt;iiii'</span>)</span><br><span class="line">    imgsize=image_num*rows_num*column_num</span><br><span class="line">    fmt_image=<span class="string">'&gt;'</span>+str(imgsize)+<span class="string">'B'</span>      <span class="comment"># 训练集数据有60000*28*28</span></span><br><span class="line">    images=struct.unpack_from(fmt_image,bin_data,offset)</span><br><span class="line">    img=np.reshape(images,(image_num,rows_num*column_num))     <span class="comment"># 构造一个60000*784的矩阵</span></span><br><span class="line">    <span class="keyword">return</span> img</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_labels_ana</span><span class="params">(filepath)</span>:</span></span><br><span class="line">    <span class="string">"""解析特征数据集 .idx1-ubyte格式"""</span></span><br><span class="line">    <span class="comment"># 以二进制格式处理文件</span></span><br><span class="line">    <span class="keyword">with</span> open(filepath,<span class="string">'rb'</span>) <span class="keyword">as</span> fbj:</span><br><span class="line">        bin_data=fbj.read()</span><br><span class="line">    offset=<span class="number">0</span></span><br><span class="line">    magic_num,items_num=struct.unpack_from(<span class="string">'&gt;ii'</span>,bin_data,offset)</span><br><span class="line">    offset+=struct.calcsize(<span class="string">'&gt;ii'</span>)</span><br><span class="line">    fmt_label=<span class="string">'&gt;'</span>+str(items_num)+<span class="string">'B'</span></span><br><span class="line">    labels=struct.unpack_from(fmt_label,bin_data,offset)</span><br><span class="line">    label=np.reshape(labels,[items_num])</span><br><span class="line">    <span class="keyword">return</span> label</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    imgs=train_images_ana(file1)</span><br><span class="line">    <span class="comment"># 查看前10个手写字灰度图</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        img=np.reshape(imgs[i],[<span class="number">28</span>,<span class="number">28</span>])</span><br><span class="line">        plt.imshow(img,cmap=<span class="string">'gray'</span>)</span><br><span class="line">        plt.show()</span><br><span class="line">    labels=train_labels_ana(file2)</span><br><span class="line">    <span class="comment">#print(labels)</span></span><br></pre></td></tr></table></figure><p>相关文章：</p><ul><li><a href="https://wnxy.xyz/2020/10/17/Daily-usage-of-Struct-module-in-Python/">Python中Struct模块的日常用法</a></li></ul><p>参考文章：</p><ul><li><a href="https://blog.csdn.net/qq_32166627/article/details/62218072" target="_blank" rel="noopener">mnist数据集解析</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Machine-Learning </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 数据解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python中Struct模块的日常用法</title>
      <link href="/2020/10/17/Daily-usage-of-Struct-module-in-Python/"/>
      <url>/2020/10/17/Daily-usage-of-Struct-module-in-Python/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>最近在训练mnist字符集时用到二进制数据的处理，面向Google编程后稍稍搞懂了一点，故做一点笔记，以作备忘。</strong></p><p>Python 中用来处理二进制数据时采用 Struct 模块。</p><p>Struct模块中最常用的函数为:</p><a id="more"></a><ul><li>pack()</li><li>unpack()</li><li>pack_into()</li><li>unpack_from()</li><li>calcsize()</li></ul><p>pack(fmt, v1, v2, …)  ： 按照给定的格式 fmt（format），把数据封装成字符串。</p><p>unpack(fmt, string) ： 按照给定的格式(fmt)解析字节流 string，解析结果为元组。</p><p>struct.pack_into(fmt, buffer, offset, v1, v2, …) ： 把values：<em>v1, v2, …</em>打包按格式<em>fmt</em>转换后写入指定的内存 <em>buffer</em> 中，并且可以指定<em>buffer</em>中的<em>offset</em>即偏移量，从哪里开始写。</p><p>struct.unpack_from(fmt, buffer, offset=0) ： 从内存中的指定 <em>buffer</em> 区读取出来，然后按照 <em>fmt</em> 格式解析。可以指定<em>offset</em>，从 <em>buffer</em> 的哪个位置开始读取。</p><p>calcsize(fmt) ： 计算给定的格式(fmt)占用多少字节的内存 。</p><p>Struct中支持的格式如下表：</p><div class="table-container"><table><thead><tr><th>Format</th><th>C Type</th><th>Python</th><th>字节数</th></tr></thead><tbody><tr><td>x</td><td>pad byte</td><td>no value</td><td>1</td></tr><tr><td>c</td><td>char</td><td>string of length 1</td><td>1</td></tr><tr><td>b</td><td>signed char</td><td>integer</td><td>1</td></tr><tr><td>B</td><td>unsigned char</td><td>integer</td><td>1</td></tr><tr><td>?</td><td>_Bool</td><td>bool</td><td>1</td></tr><tr><td>h</td><td>short</td><td>integer</td><td>4</td></tr><tr><td>H</td><td>unsigned short</td><td>integer</td><td>4</td></tr><tr><td>i</td><td>int</td><td>integer</td><td>4</td></tr><tr><td>I</td><td>unsigned int</td><td>integer of long</td><td>4</td></tr><tr><td>l</td><td>long</td><td>integer</td><td>4</td></tr><tr><td>L</td><td>unsigned long</td><td>long</td><td>4</td></tr><tr><td>q</td><td>long long</td><td>long</td><td>8</td></tr><tr><td>Q</td><td>unsigned long long</td><td>long</td><td>8</td></tr><tr><td>f</td><td>float</td><td>float</td><td>4</td></tr><tr><td>d</td><td>double</td><td>float</td><td>8</td></tr><tr><td>s</td><td>char[]</td><td>string</td><td>1</td></tr><tr><td>p</td><td>char[]</td><td>string</td><td>1</td></tr><tr><td>P</td><td>void *</td><td>long</td></tr></tbody></table></div><p><strong>q和Q只在机器支持64位操作时有意思</strong></p><p><strong>每个格式前可以有一个数字，表示个数</strong></p><p><strong>s格式表示一个长度的字符串，4s表示长度为4的字符串，但是p表示的是pascal字符串</strong></p><p><strong>P用来转换一个指针，其长度和机器字长相关</strong></p><p><strong>最后一个可以用来表示指针类型的，占4个字节</strong></p><p>参考文章：<a href="https://www.cnblogs.com/gala/archive/2011/09/22/2184801.html" target="_blank" rel="noopener">https://www.cnblogs.com/gala/archive/2011/09/22/2184801.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Struct模块 </tag>
            
            <tag> 二进制处理 </tag>
            
            <tag> Binary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习——逻辑回归算法（Logistic Regression）思想及算法实现</title>
      <link href="/2020/10/11/Machine-learning-logistic-regression-algorithm/"/>
      <url>/2020/10/11/Machine-learning-logistic-regression-algorithm/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-分类原理"><a href="#1-分类原理" class="headerlink" title="1.分类原理"></a>1.分类原理</h1><h2 id="1-1-逻辑回归"><a href="#1-1-逻辑回归" class="headerlink" title="1.1 逻辑回归"></a>1.1 逻辑回归</h2><p>逻辑回归算法是一个分类算法，其性质是它的输出值永远在0到1之间，是目前最流行、最广泛使用的一直学习算法。</p><h2 id="1-2-Sigmoid函数"><a href="#1-2-Sigmoid函数" class="headerlink" title="1.2 Sigmoid函数"></a>1.2 Sigmoid函数</h2><p>根据线性回归模型我们只能预测连续的值，然而对于分类问题，我们需要输出0或1，此时引入逻辑回归模型，模型核心为Sigmoid函数，公式为：$g(z)=\frac{1}{1+e^{-z}}$</p><p>其中：$z=-\Theta^{T} X$</p><a id="more"></a><p>该函数图像为：</p><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/sigmoid.png" alt=""></p><p>$h_{\Theta}(x)$的作用是对于给定的输入变量，根据选择的参数计算出输出变量=1的可能性。</p><h2 id="1-3-代价函数"><a href="#1-3-代价函数" class="headerlink" title="1.3 代价函数"></a>1.3 代价函数</h2><p>在逻辑回归中可以判定当$h_{\Theta}(x)$大于等于0.5时，预测y=1。</p><p>当$h_{\Theta}(x)$小于0.5时，预测y=0。</p><p>逻辑回归中使用最大似然法来拟合参数：<a href="https://www.codecogs.com/eqnedit.php?latex=z=\Theta&space;_{0}&plus;\Theta&space;_{1}x_{1}&plus;\Theta&space;_{2}x_{2}&plus;...&plus;\Theta&space;_{n}x_{n}" target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?z=\Theta&space;_{0}&plus;\Theta&space;_{1}x_{1}&plus;\Theta&space;_{2}x_{2}&plus;...&plus;\Theta&space;_{n}x_{n}" title="z=\Theta _{0}+\Theta _{1}x_{1}+\Theta _{2}x_{2}+...+\Theta _{n}x_{n}" /></a></p><p>训练样本的特征向量为：<a href="https://www.codecogs.com/eqnedit.php?latex=x\epsilon&space;\begin{bmatrix}x_{0}&space;\\&space;x_{1}&space;\\&space;...&space;\\x_{n}&space;\end{bmatrix}" target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?x\epsilon&space;\begin{bmatrix}x_{0}&space;\\&space;x_{1}&space;\\&space;...&space;\\x_{n}&space;\end{bmatrix}" title="x\epsilon \begin{bmatrix}x_{0} \\ x_{1} \\ ... \\x_{n} \end{bmatrix}" /></a></p><p>其中：<a href="https://www.codecogs.com/eqnedit.php?latex=x_{0}=1,y\epsilon&space;\left&space;\{&space;0&space;,1\right&space;\}" target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?x_{0}=1,y\epsilon&space;\left&space;\{&space;0&space;,1\right&space;\}" title="x_{0}=1,y\epsilon \left \{ 0 ,1\right \}" /></a></p><p>构建代价函数为：<a href="https://www.codecogs.com/eqnedit.php?latex=J\left&space;(&space;\Theta&space;\right&space;)=-\frac{1}{m}\sum_{i=1}^{m}\left&space;[&space;y^{\left&space;(&space;i&space;\right&space;)}log\left&space;(&space;h_{\Theta&space;}\left&space;(&space;x^{\left&space;(&space;i&space;\right&space;)}&space;\right&space;)&space;\right&space;)&space;&plus;\left&space;(&space;1-y^{\left&space;(&space;i&space;\right&space;)}&space;\right&space;)log\left&space;(&space;1-h_{\Theta&space;}&space;\left&space;(&space;x^{\left&space;(&space;i&space;\right&space;)}&space;\right&space;)\right&space;)\right&space;]" target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?J\left&space;(&space;\Theta&space;\right&space;)=-\frac{1}{m}\sum_{i=1}^{m}\left&space;[&space;y^{\left&space;(&space;i&space;\right&space;)}log\left&space;(&space;h_{\Theta&space;}\left&space;(&space;x^{\left&space;(&space;i&space;\right&space;)}&space;\right&space;)&space;\right&space;)&space;&plus;\left&space;(&space;1-y^{\left&space;(&space;i&space;\right&space;)}&space;\right&space;)log\left&space;(&space;1-h_{\Theta&space;}&space;\left&space;(&space;x^{\left&space;(&space;i&space;\right&space;)}&space;\right&space;)\right&space;)\right&space;]" title="J\left ( \Theta \right )=-\frac{1}{m}\sum_{i=1}^{m}\left [ y^{\left ( i \right )}log\left ( h_{\Theta }\left ( x^{\left ( i \right )} \right ) \right ) +\left ( 1-y^{\left ( i \right )} \right )log\left ( 1-h_{\Theta } \left ( x^{\left ( i \right )} \right )\right )\right ]" /></a></p><p>使用梯度下降算法求使得代价函数最小的参数：</p><p><img src="/loading.gif" data-original="https://s1.ax1x.com/2020/10/12/0WELAx.png" alt=""></p><h1 id="2-算法实现"><a href="#2-算法实现" class="headerlink" title="2.算法实现"></a>2.算法实现</h1><h2 id="2-1-Sigmoid函数python实现"><a href="#2-1-Sigmoid函数python实现" class="headerlink" title="2.1 Sigmoid函数python实现"></a>2.1 Sigmoid函数python实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义sigmoid函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(z)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>/(<span class="number">1</span>+np.exp(-z))</span><br></pre></td></tr></table></figure><h2 id="2-2-梯度下降算法python实现"><a href="#2-2-梯度下降算法python实现" class="headerlink" title="2.2 梯度下降算法python实现"></a>2.2 梯度下降算法python实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gradAscent</span><span class="params">(dataMatIn, classLabels)</span>:</span></span><br><span class="line">    dataMatrix = mat(dataMatIn)  <span class="comment"># 转换为矩阵</span></span><br><span class="line">    labelMat = mat(classLabels).transpose()  <span class="comment"># 转换为矩阵</span></span><br><span class="line"></span><br><span class="line">    m, n = shape(dataMatrix)</span><br><span class="line">    alpha = <span class="number">0.001</span>   <span class="comment"># 学习率</span></span><br><span class="line">    maxCycles = <span class="number">505</span>   <span class="comment"># 迭代次数</span></span><br><span class="line">    weights = ones((n, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(maxCycles):  <span class="comment"># 迭代拟合参数</span></span><br><span class="line">        h = sigmoid(dataMatrix * weights)  <span class="comment"># 求h</span></span><br><span class="line">        error = (h - labelMat)    <span class="comment"># 求误差量</span></span><br><span class="line">        weights=weights-alpha*dataMatrix.transpose()*error/len(dataMatrix)</span><br><span class="line">    <span class="keyword">return</span> weights</span><br></pre></td></tr></table></figure><h1 id="3-数据集说明"><a href="#3-数据集说明" class="headerlink" title="3.数据集说明"></a>3.数据集说明</h1><p>参考数据集网址: <a href="http://archive.ics.uci.edu/ml/" target="_blank" rel="noopener">http://archive.ics.uci.edu/ml/</a></p><p>本次机器学习逻辑回归算法实现分类使用的是经典数据集 Iris Data（鸢尾花数据集），数据集包含3个类（Iris Setosa、Iris Versicolour、Iris Virginica），每个类有50个实例，其中每个类都涉及一种鸢尾花品种。预测的属性为鸢尾花植物的类别。</p><p>此次算法实现中删掉了其中一个鸢尾花种类，算法引入的数据集只做鸢尾花种类的二分类，并且分别将鸢尾花种类数据集按 8：2 的比例分为训练数据集和测试数据集。</p><p>鸢尾花数据集的属性信息：</p><ul><li>萼片长度（厘米）</li><li>萼片宽度（厘米）</li><li>花瓣长度（厘米）</li><li>花瓣宽度（厘米）</li></ul><p>逻辑回归分类算法的模型训练过程使用鸢尾花的全部四个特征，将鸢尾花样本可视化及分类可视化过程选取了鸢尾花的前两个属性（萼片长度、萼片宽度）。</p><h1 id="4-程序说明"><a href="#4-程序说明" class="headerlink" title="4.程序说明"></a>4.程序说明</h1><h2 id="4-1-载入数据集"><a href="#4-1-载入数据集" class="headerlink" title="4.1 载入数据集"></a>4.1 载入数据集</h2><p>将源数据集载入算法，并初始处理样本，将鸢尾花种类分为正向类和负向类。函数返回鸢尾花的特征向量和对应的鸢尾花种类向量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""载入数据集"""</span></span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">path=<span class="string">"iris_train.data"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loadDataSet</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""读取数据"""</span></span><br><span class="line">    x_data=[]</span><br><span class="line">    y_data=[]</span><br><span class="line">    <span class="keyword">with</span> open(path) <span class="keyword">as</span> f_obj:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f_obj.readlines():</span><br><span class="line">            lineArr=line.strip().split(<span class="string">','</span>)</span><br><span class="line">            lineArr.insert(<span class="number">0</span>,<span class="number">1.0</span>)</span><br><span class="line">            <span class="keyword">if</span> (lineArr[<span class="number">-1</span>]==<span class="string">'Iris-setosa'</span>):</span><br><span class="line">                y_data.append(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">elif</span>(lineArr[<span class="number">-1</span>]==<span class="string">'Iris-versicolor'</span>):</span><br><span class="line">                y_data.append(<span class="number">1</span>)</span><br><span class="line">            x_data.append(list(map(float, lineArr[:<span class="number">-1</span>])))</span><br><span class="line">        <span class="keyword">return</span> x_data,y_data</span><br></pre></td></tr></table></figure><h2 id="4-2-分类可视化"><a href="#4-2-分类可视化" class="headerlink" title="4.2 分类可视化"></a>4.2 分类可视化</h2><h3 id="4-2-1-鸢尾花数据集二分类"><a href="#4-2-1-鸢尾花数据集二分类" class="headerlink" title="4.2.1 鸢尾花数据集二分类"></a>4.2.1 鸢尾花数据集二分类</h3><p>为了直观理解分类结果，便于可视化，利用matplotlib库的pyplot函数，按照鸢尾花数据特征中的萼片长度、萼片宽度属性绘制训练数据集的散点图，并绘制判定边界。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plotBestFit</span><span class="params">(weights)</span>:</span></span><br><span class="line">    dataMat, labelMat = loadDataSet()</span><br><span class="line">    dataArr = array(dataMat)</span><br><span class="line">    n = shape(dataArr)[<span class="number">0</span>]</span><br><span class="line">    xcord1,xcord2 = [],[]</span><br><span class="line">    ycord1,ycord2 = [],[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">if</span> int(labelMat[i]) == <span class="number">1</span>:</span><br><span class="line">            xcord1.append(dataArr[i, <span class="number">1</span>])</span><br><span class="line">            ycord1.append(dataArr[i, <span class="number">2</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            xcord2.append(dataArr[i, <span class="number">1</span>])</span><br><span class="line">            ycord2.append(dataArr[i, <span class="number">2</span>])</span><br><span class="line">    fig = plt.figure()</span><br><span class="line">    ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line">    ax.scatter(xcord1, ycord1, s=<span class="number">30</span>, c=<span class="string">'red'</span>, marker=<span class="string">'s'</span>)</span><br><span class="line">    ax.scatter(xcord2, ycord2, s=<span class="number">30</span>, c=<span class="string">'green'</span>)</span><br><span class="line">    x = arange(<span class="number">3.0</span>, <span class="number">8.0</span>, <span class="number">0.1</span>)</span><br><span class="line">    y = (-(float)(weights[<span class="number">0</span>][<span class="number">0</span>]) - (float)(weights[<span class="number">1</span>][<span class="number">0</span>]) * x) / (float)(weights[<span class="number">2</span>][<span class="number">0</span>])</span><br><span class="line">    ax.plot(x, y)</span><br><span class="line">    plt.title(<span class="string">'Iris data set classification'</span>,fontsize=<span class="number">24</span>)</span><br><span class="line">    plt.xlabel(<span class="string">'Sepal length'</span>)</span><br><span class="line">    plt.ylabel(<span class="string">'Sepal width'</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><h3 id="4-2-分类结果"><a href="#4-2-分类结果" class="headerlink" title="4.2 分类结果"></a>4.2 分类结果</h3><p><img src="/loading.gif" data-original="https://s1.ax1x.com/2020/10/12/0RzjyV.png" alt=""></p><h2 id="4-3-鸢尾花测试集预测"><a href="#4-3-鸢尾花测试集预测" class="headerlink" title="4.3 鸢尾花测试集预测"></a>4.3 鸢尾花测试集预测</h2><h3 id="4-3-1-预测函数"><a href="#4-3-1-预测函数" class="headerlink" title="4.3.1 预测函数"></a>4.3.1 预测函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predictClass</span><span class="params">()</span>:</span></span><br><span class="line">    x,y=[],[]</span><br><span class="line">    dataMat = loadDataSet()</span><br><span class="line">    print(len(mat(dataMat)))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(mat(dataMat))):</span><br><span class="line">        <span class="comment"># 梯度下降算法拟合的最优参数</span></span><br><span class="line">        weights= [<span class="number">0.75401377</span>,<span class="number">-0.2401068</span>,<span class="number">0.15175685</span>,<span class="number">0.64057407</span>,<span class="number">0.93906922</span>]</span><br><span class="line">        z=mat(weights[:<span class="number">-2</span>])*mat(dataMat[i][:<span class="number">-2</span>]).transpose()</span><br><span class="line">        x.append(z)</span><br><span class="line">        h=sigmoid(mat(weights[:<span class="number">-2</span>])*mat(dataMat[i][:<span class="number">-2</span>]).transpose())</span><br><span class="line">        y.append(h)</span><br><span class="line">    <span class="keyword">return</span> x,y</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scatterClass</span><span class="params">()</span>:</span></span><br><span class="line">    x,y=predictClass()</span><br><span class="line">    plt.scatter(x, y, c=<span class="string">'red'</span>,s=<span class="number">40</span>)</span><br><span class="line">    <span class="comment"># 设置坐标轴的取值范围</span></span><br><span class="line">    plt.axis([<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><h3 id="4-3-2-预测结果"><a href="#4-3-2-预测结果" class="headerlink" title="4.3.2 预测结果"></a>4.3.2 预测结果</h3><p>测试可视化过程只选取了梯度下降法得到的前三个最优权值，以此计算预测结果（sigmoid函数值）。</p><p><a href="https://imgchr.com/i/0HUIr6" target="_blank" rel="noopener"><img src="/loading.gif" data-original="https://s1.ax1x.com/2020/10/16/0HUIr6.png" alt=""></a></p><p>鸢尾花测试数据集为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">5.1,3.5,1.4,0.2,Iris-setosa</span><br><span class="line">4.9,3.0,1.4,0.2,Iris-setosa</span><br><span class="line">4.7,3.2,1.3,0.2,Iris-setosa</span><br><span class="line">4.6,3.1,1.5,0.2,Iris-setosa</span><br><span class="line">5.0,3.6,1.4,0.2,Iris-setosa</span><br><span class="line">5.4,3.9,1.7,0.4,Iris-setosa</span><br><span class="line">4.6,3.4,1.4,0.3,Iris-setosa</span><br><span class="line">5.0,3.4,1.5,0.2,Iris-setosa</span><br><span class="line">4.4,2.9,1.4,0.2,Iris-setosa</span><br><span class="line">4.9,3.1,1.5,0.1,Iris-setosa</span><br><span class="line">7.0,3.2,4.7,1.4,Iris-versicolor</span><br><span class="line">6.4,3.2,4.5,1.5,Iris-versicolor</span><br><span class="line">6.9,3.1,4.9,1.5,Iris-versicolor</span><br><span class="line">5.5,2.3,4.0,1.3,Iris-versicolor</span><br><span class="line">6.5,2.8,4.6,1.5,Iris-versicolor</span><br><span class="line">5.7,2.8,4.5,1.3,Iris-versicolor</span><br><span class="line">6.3,3.3,4.7,1.6,Iris-versicolor</span><br><span class="line">4.9,2.4,3.3,1.0,Iris-versicolor</span><br><span class="line">6.6,2.9,4.6,1.3,Iris-versicolor</span><br><span class="line">5.2,2.7,3.9,1.4,Iris-versicolor</span><br></pre></td></tr></table></figure><p>由模型测试图可看出测试结果可辨。</p><h1 id="5-附录"><a href="#5-附录" class="headerlink" title="5.附录"></a>5.附录</h1><p>load_data.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""载入数据集"""</span></span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line">path=<span class="string">"iris_train.data"</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loadDataSet</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""读取数据"""</span></span><br><span class="line">    x_data=[]</span><br><span class="line">    y_data=[]</span><br><span class="line">    <span class="keyword">with</span> open(path) <span class="keyword">as</span> f_obj:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f_obj.readlines():</span><br><span class="line">            lineArr=line.strip().split(<span class="string">','</span>)</span><br><span class="line">            lineArr.insert(<span class="number">0</span>,<span class="number">1.0</span>)</span><br><span class="line">            <span class="keyword">if</span> (lineArr[<span class="number">-1</span>]==<span class="string">'Iris-setosa'</span>):</span><br><span class="line">                y_data.append(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">elif</span>(lineArr[<span class="number">-1</span>]==<span class="string">'Iris-versicolor'</span>):</span><br><span class="line">                y_data.append(<span class="number">1</span>)</span><br><span class="line">            x_data.append(list(map(float, lineArr[:<span class="number">-1</span>])))</span><br><span class="line">        <span class="keyword">return</span> x_data,y_data</span><br></pre></td></tr></table></figure><p>sigmoid.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment">#定义sigmoid函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(z)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>/(<span class="number">1</span>+np.exp(-z))</span><br></pre></td></tr></table></figure><p>gradascent.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sigmoid <span class="keyword">import</span> sigmoid</span><br><span class="line"><span class="keyword">from</span> load_data <span class="keyword">import</span> loadDataSet</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gradAscent</span><span class="params">(dataMatIn, classLabels)</span>:</span></span><br><span class="line">    dataMatrix = mat(dataMatIn)  <span class="comment"># 转换为矩阵</span></span><br><span class="line">    labelMat = mat(classLabels).transpose()  <span class="comment"># 转换为矩阵</span></span><br><span class="line"></span><br><span class="line">    m, n = shape(dataMatrix)</span><br><span class="line">    alpha = <span class="number">0.001</span>   <span class="comment"># 学习率</span></span><br><span class="line">    maxCycles = <span class="number">505</span>   <span class="comment"># 迭代次数</span></span><br><span class="line">    weights = ones((n, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(maxCycles):  <span class="comment"># 迭代拟合参数</span></span><br><span class="line">        h = sigmoid(dataMatrix * weights)  <span class="comment"># 求h</span></span><br><span class="line">        error = (h - labelMat)    <span class="comment"># 求误差量</span></span><br><span class="line">        weights=weights-alpha*dataMatrix.transpose()*error/len(dataMatrix)</span><br><span class="line">    <span class="keyword">return</span> weights</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GetResult</span><span class="params">()</span>:</span></span><br><span class="line">    dataMat, labelMat = loadDataSet()</span><br><span class="line">    weights = gradAscent(dataMat, labelMat)</span><br><span class="line">    print(weights)</span><br><span class="line">    plotBestFit(weights)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plotBestFit</span><span class="params">(weights)</span>:</span></span><br><span class="line">    dataMat, labelMat = loadDataSet()</span><br><span class="line">    dataArr = array(dataMat)</span><br><span class="line">    n = shape(dataArr)[<span class="number">0</span>]</span><br><span class="line">    xcord1,xcord2 = [],[]</span><br><span class="line">    ycord1,ycord2 = [],[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">if</span> int(labelMat[i]) == <span class="number">1</span>:</span><br><span class="line">            xcord1.append(dataArr[i, <span class="number">1</span>])</span><br><span class="line">            ycord1.append(dataArr[i, <span class="number">2</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            xcord2.append(dataArr[i, <span class="number">1</span>])</span><br><span class="line">            ycord2.append(dataArr[i, <span class="number">2</span>])</span><br><span class="line">    fig = plt.figure()</span><br><span class="line">    ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line">    ax.scatter(xcord1, ycord1, s=<span class="number">30</span>, c=<span class="string">'red'</span>, marker=<span class="string">'s'</span>)</span><br><span class="line">    ax.scatter(xcord2, ycord2, s=<span class="number">30</span>, c=<span class="string">'green'</span>)</span><br><span class="line">    x = arange(<span class="number">3.0</span>, <span class="number">8.0</span>, <span class="number">0.1</span>)</span><br><span class="line">    y = (-(float)(weights[<span class="number">0</span>][<span class="number">0</span>]) - (float)(weights[<span class="number">1</span>][<span class="number">0</span>]) * x) / (float)(weights[<span class="number">2</span>][<span class="number">0</span>])</span><br><span class="line">    ax.plot(x, y)</span><br><span class="line">    plt.title(<span class="string">'Iris data set classification'</span>,fontsize=<span class="number">24</span>)</span><br><span class="line">    plt.xlabel(<span class="string">'Sepal length'</span>)</span><br><span class="line">    plt.ylabel(<span class="string">'Sepal width'</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    GetResult()</span><br></pre></td></tr></table></figure><p>predice_classfication.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sigmoid <span class="keyword">import</span> sigmoid</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">path=<span class="string">"iris_test.data"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loadDataSet</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""读取数据"""</span></span><br><span class="line">    x_data=[]</span><br><span class="line">    <span class="keyword">with</span> open(path) <span class="keyword">as</span> f_obj:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f_obj.readlines():</span><br><span class="line">            lineArr=line.strip().split(<span class="string">','</span>)</span><br><span class="line">            lineArr.insert(<span class="number">0</span>,<span class="number">1.0</span>)</span><br><span class="line">            x_data.append(list(map(float, lineArr[:<span class="number">-1</span>])))</span><br><span class="line">        <span class="keyword">return</span> x_data</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predictClass</span><span class="params">()</span>:</span></span><br><span class="line">    x,y=[],[]</span><br><span class="line">    dataMat = loadDataSet()</span><br><span class="line">    print(len(mat(dataMat)))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(mat(dataMat))):</span><br><span class="line">        weights= [<span class="number">0.75401377</span>,<span class="number">-0.2401068</span>,<span class="number">0.15175685</span>,<span class="number">0.64057407</span>,<span class="number">0.93906922</span>]</span><br><span class="line">        print(<span class="string">'z'</span>,mat(weights[:<span class="number">-2</span>])*mat(dataMat[i][:<span class="number">-2</span>]).transpose())</span><br><span class="line">        z=mat(weights[:<span class="number">-2</span>])*mat(dataMat[i][:<span class="number">-2</span>]).transpose()</span><br><span class="line">        x.append(z)</span><br><span class="line">        h=sigmoid(mat(weights[:<span class="number">-2</span>])*mat(dataMat[i][:<span class="number">-2</span>]).transpose())</span><br><span class="line">        y.append(h)</span><br><span class="line">        print(<span class="string">'h'</span>,h)</span><br><span class="line">    <span class="keyword">return</span> x,y</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scatterClass</span><span class="params">()</span>:</span></span><br><span class="line">    x,y=predictClass()</span><br><span class="line">    plt.scatter(x, y, c=<span class="string">'red'</span>,s=<span class="number">40</span>)</span><br><span class="line">    <span class="comment"># 设置坐标轴的取值范围</span></span><br><span class="line">    plt.axis([<span class="number">-0.75</span>, <span class="number">0.75</span>, <span class="number">0.2</span>, <span class="number">0.8</span>])</span><br><span class="line">    plt.title(<span class="string">'Iris data set prediction'</span>,fontsize=<span class="number">24</span>)</span><br><span class="line">    plt.xlabel(<span class="string">'Z'</span>)</span><br><span class="line">    plt.ylabel(<span class="string">'Sigmoid'</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    predictClass()</span><br><span class="line">    scatterClass()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Machine-Learning </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python数据可视化——函数图像绘制</title>
      <link href="/2020/10/09/Python-data-visualization/"/>
      <url>/2020/10/09/Python-data-visualization/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>利用python的matplotlib库进行数据可视化，绘制定义函数的图像。</p><p>以机器学习逻辑回归的sigmoid函数为例：</p><p><a href="https://www.codecogs.com/eqnedit.php?latex=g\left&space;(&space;z&space;\right&space;)=\frac{1}{1&plus;e^{-z}}" target="_blank"><img src="/loading.gif" data-original="https://latex.codecogs.com/gif.latex?g\left&space;(&space;z&space;\right&space;)=\frac{1}{1&plus;e^{-z}}" title="g\left ( z \right )=\frac{1}{1+e^{-z}}" /></a></p><p>python代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义sigmoid函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(z)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>/(<span class="number">1</span>+np.exp(-z))</span><br></pre></td></tr></table></figure><a id="more"></a><p>函数图像为：</p><p><img src="/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wnxy/wnxy_pic@master/img/sigmoid.png" alt=""></p><p>以下对python matplotlib库绘制函数图像做简单描述：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义sigmoid函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(z)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>/(<span class="number">1</span>+np.exp(-z))</span><br><span class="line"></span><br><span class="line"><span class="comment">#在-10到10之间生成1000个x值</span></span><br><span class="line">x=np.linspace(<span class="number">-10</span>,<span class="number">10</span>,<span class="number">1000</span>)</span><br><span class="line">y=sigmoid(x)</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取当前的坐标轴, gca = get current axis</span></span><br><span class="line">ax=plt.gca()</span><br><span class="line"><span class="comment">#设置右边框和上边框</span></span><br><span class="line">ax.spines[<span class="string">'right'</span>].set_color(<span class="string">'none'</span>)</span><br><span class="line">ax.spines[<span class="string">'top'</span>].set_color(<span class="string">'none'</span>)</span><br><span class="line"><span class="comment">#设置x坐标轴为下边框</span></span><br><span class="line">ax.xaxis.set_ticks_position(<span class="string">'bottom'</span>)</span><br><span class="line"><span class="comment">#设置y坐标轴为左边框</span></span><br><span class="line">ax.yaxis.set_ticks_position(<span class="string">'left'</span>)</span><br><span class="line"><span class="comment">#设置x轴, y周在(0, 0)的位置</span></span><br><span class="line">ax.spines[<span class="string">'bottom'</span>].set_position((<span class="string">'data'</span>, <span class="number">0</span>))</span><br><span class="line">ax.spines[<span class="string">'left'</span>].set_position((<span class="string">'data'</span>, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">plt.plot(x,y)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Machine-Learning </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> Matplotlib </tag>
            
            <tag> 函数图像 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo melody博客不蒜子统计无法显示问题解决</title>
      <link href="/2020/09/19/Hexo-melody-blog-beautification1/"/>
      <url>/2020/09/19/Hexo-melody-blog-beautification1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>参考文章：<a href="https://www.jianshu.com/p/0befb34dce16" target="_blank" rel="noopener">https://www.jianshu.com/p/0befb34dce16</a></p><p>存在问题：已发布的hexo melody主题博客不蒜子统计不能显示</p><p>解决：修改\themes\melody\layout\includes\count路径下busuanzi.pug文件</p><a id="more"></a><p>原文件为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">.busuanzi</span><br><span class="line">  script(async src&#x3D;&quot;&#x2F;&#x2F;busuanzi.ibruce.info&#x2F;busuanzi&#x2F;2.3&#x2F;busuanzi.pure.mini.js&quot;)</span><br><span class="line">  if(!is_post())</span><br><span class="line">    if(theme.busuanzi.site_uv)</span><br><span class="line">      span#busuanzi_container_site_uv!&#x3D; theme.busuanzi.site_uv_header         &lt;----改</span><br><span class="line">        span#busuanzi_value_site_uv</span><br><span class="line">        span!&#x3D;theme.busuanzi.site_uv_footer</span><br><span class="line">    if(theme.busuanzi.site_pv)</span><br><span class="line">      if(theme.busuanzi.site_pv)</span><br><span class="line">        span.footer-separator |</span><br><span class="line">      span#busuanzi_container_site_pv!&#x3D; theme.busuanzi.site_pv_header         &lt;----改</span><br><span class="line">        span#busuanzi_value_site_pv</span><br><span class="line">        span!&#x3D;theme.busuanzi.site_pv_footer</span><br><span class="line">  else</span><br><span class="line">    if(theme.busuanzi.page_pv)</span><br><span class="line">      span#busuanzi_container_page_pv!&#x3D; theme.busuanzi.page_pv_header         &lt;----改</span><br><span class="line">        span#busuanzi_value_page_pv</span><br><span class="line">        span!&#x3D;theme.busuanzi.page_pv_footer</span><br><span class="line">    else</span><br><span class="line">      if(theme.busuanzi.site_uv)</span><br><span class="line">        span#busuanzi_container_site_uv!&#x3D; theme.busuanzi.site_uv_header       &lt;----改</span><br><span class="line">          span#busuanzi_value_site_uv</span><br><span class="line">          span!&#x3D;theme.busuanzi.site_uv_footer</span><br><span class="line">      if(theme.busuanzi.site_pv)</span><br><span class="line">        if(theme.busuanzi.site_pv)</span><br><span class="line">          span.footer-separator |</span><br><span class="line">        span#busuanzi_container_site_pv!&#x3D; theme.busuanzi.site_pv_header       &lt;----改</span><br><span class="line">          span#busuanzi_value_site_pv</span><br><span class="line">          span!&#x3D;theme.busuanzi.site_pv_footer</span><br></pre></td></tr></table></figure><p>修改后文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">.busuanzi</span><br><span class="line">  script(async src&#x3D;&quot;&#x2F;&#x2F;busuanzi.ibruce.info&#x2F;busuanzi&#x2F;2.3&#x2F;busuanzi.pure.mini.js&quot;)</span><br><span class="line">  if(!is_post())</span><br><span class="line">    if(theme.busuanzi.site_uv)</span><br><span class="line">      span!&#x3D; theme.busuanzi.site_uv_header</span><br><span class="line">        span#busuanzi_value_site_uv</span><br><span class="line">        span!&#x3D;theme.busuanzi.site_uv_footer</span><br><span class="line">    if(theme.busuanzi.site_pv)</span><br><span class="line">      if(theme.busuanzi.site_pv)</span><br><span class="line">        span.footer-separator |</span><br><span class="line">      span!&#x3D; theme.busuanzi.site_pv_header</span><br><span class="line">        span#busuanzi_value_site_pv</span><br><span class="line">        span!&#x3D;theme.busuanzi.site_pv_footer</span><br><span class="line">  else</span><br><span class="line">    if(theme.busuanzi.page_pv)</span><br><span class="line">      span!&#x3D; theme.busuanzi.page_pv_header</span><br><span class="line">        span#busuanzi_value_page_pv</span><br><span class="line">        span!&#x3D;theme.busuanzi.page_pv_footer</span><br><span class="line">    else</span><br><span class="line">      if(theme.busuanzi.site_uv)</span><br><span class="line">        span!&#x3D; theme.busuanzi.site_uv_header</span><br><span class="line">          span#busuanzi_value_site_uv</span><br><span class="line">          span!&#x3D;theme.busuanzi.site_uv_footer</span><br><span class="line">      if(theme.busuanzi.site_pv)</span><br><span class="line">        if(theme.busuanzi.site_pv)</span><br><span class="line">          span.footer-separator |</span><br><span class="line">        span!&#x3D; theme.busuanzi.site_pv_header</span><br><span class="line">          span#busuanzi_value_site_pv</span><br><span class="line">          span!&#x3D;theme.busuanzi.site_pv_footer</span><br></pre></td></tr></table></figure><p>修改后不蒜子显示正常。</p>]]></content>
      
      
      <categories>
          
          <category> Hexo博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> melody </tag>
            
            <tag> 博客美化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>星光不负赶路人...</title>
      <link href="/2020/08/11/Starlight-lives-up-to-the-traveler/"/>
      <url>/2020/08/11/Starlight-lives-up-to-the-traveler/</url>
      
        <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Welcome to my blog, enter password to read.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="041166ff4c12570141e825e24b8f1037ad570f6b0dbb39a24673ca7d1b8e2178">d0d703fa332139beb12ceb85f23df7fc2dd2ad6c1e2d88c79a07ca82a4c752383c4b274b70abf24c2627b91511ca38c6827a85fb24bb1d405ef366f63d449475cc7e7021b2f42aea7973805ef690a099be12a8caa2ffdf6dbc9f6212144592fad5a584f16d9cbcc534663cce7d13c5205693b5799467cdca4f31b1eb3da117c4464e9d65e8d2ea086423bfac557b55b88f807ccf0b25016324b2051db850900f99f12708a26a6549e44778d76c46ce31d1a6d64c5e9d8db63da0630457acc014c67941c9a3f8ca646afc155801e88b3509b175e7ac010b442778b88935322dc16758351f90281084ecfd1b06f21cb5a1c4e1255c460c67ea328840963b1ad7b1f852cafe5fdc6953ede3c0673d806bfa3992f6dd31de32c90c355e64e61f782a01dd4ec9754b3e58ce682d7ebafa8936892e07cc0e9ad798833c0cef755a13e67ad45bb2fe8786847e49cd7f05b40f337d3fa9e88d4a34a1b40f82dbaf94cca5a1e56745f5d7142fd61df013d5559425344050fa67e0d3b8063cd0fca30baaa9953891ba1fb89a1c6bca41865c52fe33c02abb579bf67cbb95937dd057cc086349c1477d3b9afdc4f684a1fb23e181bca72b825f582f1e38c37cc156e788bb623f2a7d451e18ac030fa0c04cbd2b28a472519ff52826d31d4a013a00910a82a6432aca1d25277880315953a0b34158427562c6804989f1a32271460b6660c99bba95445298cc42709d2a56c12bfdf4c0faaea1588fb134f69f65935a5e0c6b1fc3518140bb26c35b9eb599fe47ebc63a9404b21daa7f89931e259baf01b7e5256c5450a57c29ce4a7ea7e457108666e8cf001800e44b04608d62c1ac06b4b4d5c1edb1b3aff8e74249fff98c699f8f9e8c998368a557c38c07584c809205c8138a91b6f774bf15582315a60e43736f7576da3f45e598c92f5292cedc7bee97c12c1c12e5b1b1f8e479f50b995ae13780a9e92b521165ce912519184d5c2642ed329d2c45dac2b0d90279103026deaa18b6d09c5553948bd70f892d9dcd04342f6cde9c9afa36c0fd3c852ae8f4386f49f12d8d20b72e80ebb7298bb440e67334e00a3c6b5d2ae9e4086906e8266a4732e6d6e9b38293d4ff9fc4df6fe4d72333d7faf76b8fc9cf2bfd2df68297b3dc9faeb46d52225b8477b45cdd1c58379b78fa2dceef18862ad6437942384d0257d070dca81740ba87f33fad03b7493cbbc159158406cecad04d0668ce8e21557b43e7d49d17f6c3c3636a4fd52ae0809666845a961f7bec20db60fc8e53ca4c508af57b58c242cde427bbf815cc36ad851a7eaad5ab7487bdd941da4ecb969dc7ec1689efb832e0ba990e2e7da29a9289cf093c9492978980bcebbf56a1ae6e402886b4ab7c8e97098655c0c607ca68af147e73cd337891a589f616f71a45cfce865d4c4ffe7dd7d5fddcfdb65059ddbbb27ff431cdb0f42833aae158e126a3886d57161fc24194f3d10a9470a04f76092c33ef060d2a72051d475a61fff2677e85a2b393399e795f287716f9e97228bbb14406c2eb7d904d6c05e90d6f7db9db768c7e2f9e84070e1aad55a34d6ca41538855c0493ac397cff052ba74c9752fb05f0026ed29711c5f18e85853b37f4cc3045338258e62b16dec88503353faf2a023244516c299dd8a696d58554c25f1e9f8d1a021a5550c73d0ebfadf1d4c5f60adadc95fa219e3ef8169f517a8e2988e8d9480da31dcdbcb3b414e4b55b2091ffb2c3079977a535de96e77562664f5d9ae8ddea1282e12f4c3d357fadb3a971588e9221d153ee8a0427920e21c810964bfce016d91c15fc4329eff47521e3159f96acd9e872b480cca17829e991979a3f8ea613a4f6935ae72bc7de3b154af2ac9eac970891f6ee4406dbb7a812044bf8455f7744805459c25698ba1c27cc0534ca85e502f147e1c0a266a5de64a3a20504230868188d86a7077dd7f8db289e1b722f5fcc39b41fddec8366061d06511dfdf939b23b944001b1167dae5b795292c03f686a3dc9dcdfcffc71dc35d12106735c5ff2ee3c447d97d6e0c883b06fab2ce76ca1953c6b5439b69f4fc3d6744fbe4fbb9b65fa05c1c27546cab816a617562057bec889979b53a72c0ebcf5b4f330054eeb7b4dc5e87b4ce959413794844bf0ab020e517fe241bd53a3be51181c72c39436e328484c3b6923c98031d889273af786fb6fca29fb5e6a4fc4ea25c98f94c4412a3e4e173a7b05772d1facdf0804b9e4261e79c71e3cfe468bc3072061530d405f1f3c4f0931b7632337304731d0df617732d1c803a663ba80e9462823b0e6243d4439abe0bbde13fbe1d671b6662f58ec2b3776ac454cf2cbb6582f46c4ad6cef499f91a3696ce6a764c83aca0daa1851265bbf71b4005939bd587ecf3c10c2cc7f87630138b13696a437de48aa63b83b69a7ee070444a2c87616450ea2e3a7f49aae14fb4c88ddee2fee213e77d8c7b25cdfa9a24dbbdc0574a10e7cb3d26bb1d692bc5bec27811a1594f7588b85fed273afbf9a019e6ca7cd1f17434d1f0e7c37f6d17ed85b779c34083aadb6a14d9b83bc6a41d2548ba6195b10310eff31afa17e6c6b0cbefa0fbce570624296d118ac491310ad9bfb31c4fa273a9a1c0b3fbfd5127b7c0e79177441ecac05ee58465f68a88ed82b422b252c2c74242718d84ac88ec08addf6af7588eb6fd7855ab9813d76941ff98df72cb0018f301a0000b09ba8ef3540444b7a08f6a85ce1885e28c0c4c42be1b1f593a7c6b3a9d60443187af13dba92356586abaa077e936867bbffd5f99d9070e6a5e4eebe329d7796b210b139b6243f70e4758b670f7656146b09c353c23de41626fcf9e0dc04893928a26c4415dc92c89d14eeae985a77603f29e92a2f64c3a4511f37c6810a6165eb70a6644b31cadf1f3aab8c90906626a9b907f5f81b31e8885442f224b3e477369e8630e9c5c6736cc3bf069cb6d09a55ba15f5f8a410d162e9899a7ae305c4e2f89fc9627eeae4e51fea6b1c4052ecf554506fc403464f1393050bf09bdec91c30f82caa0ee124b21f1f647d37a372f89f2f1e3b448f75a5755d455cf52c9422fff68a114c64c252831ca49839117b63dd5f0a148703faffdd43ddfe0053a7b1170ae42be4563fa110ce8642cafebc712a4c3e6a370ee8ac4c0114ebfc70b13ffd63e35840d47ddf9d2eacf1dfc05c38c36374a7bf7b6d0f81251a00b4a6950d9a604934782a14c2f4e57db11d780174abc28a4f073d6cc42adb164b46771fd2d1532ef8348548b0741fdc7a30ad38aec863f4c4fdeed4f8b51677d67ccb67e0469d6fc400b9bdf41bd47332a66db77c70ccbed3f96c671fd7657ad084e14e69405d344378a5f81385f4626158bd0d5f2c63b0df9d20b97b72b0616f7bc039aadcaf1d1142d2a2bb1a64c76d7815a270f006760ac65d523316e805f9c4d9028cc7f882377ab9e4e1a77981ea6703ab4fd00a4519e3ad0405d0944ec5fc8385bd2dc52dc615f36f6190f18faf867109d6fc8fddcae1924ea463af50efd905cf1d1f2f394151ad904e46ee6f03f8c14a294e1848190797d8fd3daf70f41eee0ee224d96ab6dead4af929500cb9e808b63b543c38171c0c6fa5c3646f6c2343bcb28e35f329557efcef2095c0b25a1f8199fefbfbc16e26ba23c51f0481a2975b6749b02ce6245e2ee6d668c1ee2b9b2b0d66268fd002c9793a7fd5558afde5113321eb00cd7a6dfa98a8ba9dad4eb74e406eed6e13f0b56964437f3f0383193f0522118457420bd2c8bf3d3a1b31010adff8237f1999e9053688bf5796403ff331cd94387ad3e7897aa3eced58da39a05e162ed3b3af4eaeb4cec6dcbd4ce5847d303f30c27b3e2b57c4cc65aac8474e23846fd9b7e4514122a9ac19dca922467feeb3b50a074f8fc1542ec9a79d8da0e1a47ee3ade2ae473ea295688c81dbab7a9ab34e0467a710aca232a40e04d6872fa2d675438751cf1fe888d6b48a3fcf3477142ccfe4adacffcd415a21d832b836198114b318eb86878f58c6bd0a8728b72d611d5b64013b31a9b814b4ac59cebe55bcc8902f048b81ac06fe049e272253d574881a448fcda568364ba643fc33d89dae6583ceb7c149b3c946a3c2513e06da4c8e9d948d210494c611a1c68020fc52b51c53430e0e6e838066b5d8d9c40557c5df2a04a4e60ff17e14c0dc0e97a04d2217cf85821f3ad194a1ae907e7335ddf37d823b50fc8cdebc8303adb3a4c6033119458a1eb539a7cd897ee02557a99d999ad5d9e2249d19c6a3edb85583c8bb5f2d3dab59bc65436e2b1bee6e305ef662b1b94d91c16ace8b</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 随笔/杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 莞尔日记 </tag>
            
            <tag> 考研 </tag>
            
            <tag> rain杂货 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>github-readme-stats制作个性GitHub简介page</title>
      <link href="/2020/07/20/github-readme-stats-Make-a-personalized-GitHub-profile-page/"/>
      <url>/2020/07/20/github-readme-stats-Make-a-personalized-GitHub-profile-page/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>在GitHub创建一个跟用户名一样的项目，最终会在自己的GitHub首页生成一个个性介绍板块。</p><blockquote><p>You found a secret! <strong>nxyrain/nxyrain</strong>is a ✨<em>special</em> ✨ repository that you can use to add a <code>README.md</code> to your GitHub profile. Make sure it’s public and initialize it with a <strong>README</strong> to get started.</p></blockquote><a id="more"></a><h3 id="一、创建项目"><a href="#一、创建项目" class="headerlink" title="一、创建项目"></a>一、创建项目</h3><p><a href="https://imgchr.com/i/UfzoAx" target="_blank" rel="noopener"><img src="/loading.gif" data-original="https://s1.ax1x.com/2020/07/20/UfzoAx.md.png" alt="创建项目"></a></p><p><strong>注意：</strong></p><p><strong>1、项目名和用户名要一致。</strong></p><p><strong>2、项目要公开，勾选Public。</strong></p><p><strong>3、项目需要初始化，勾选创建README。</strong></p><p>个人首页最上面就出现了个性介绍板块。</p><p><a href="https://imgchr.com/i/UhC2I1" target="_blank" rel="noopener"><img src="/loading.gif" data-original="https://s1.ax1x.com/2020/07/20/UhC2I1.md.png" alt="Hi there"></a></p><h3 id="二、编辑个性介绍板块"><a href="#二、编辑个性介绍板块" class="headerlink" title="二、编辑个性介绍板块"></a>二、编辑个性介绍板块</h3><p><a href="https://imgchr.com/i/UhFGrD" target="_blank" rel="noopener"><img src="/loading.gif" data-original="https://s1.ax1x.com/2020/07/20/UhFGrD.md.png" alt=""></a></p><p>添加内容</p><p><a href="https://imgchr.com/i/UhknOS" target="_blank" rel="noopener"><img src="/loading.gif" data-original="https://s1.ax1x.com/2020/07/20/UhknOS.md.png" alt=""></a></p><p>README支持Markdown语法，编辑完成点击Preview Changes预览编辑效果，编辑完成提交修改即可看见个性介绍页效果。</p><p>最后，安利一个GitHub Readme Stats项目，用来在你的 README 中 获取动态生成的GitHub统计信息！<a href="https://github.com/anuraghazra/github-readme-stats" target="_blank" rel="noopener">项目地址</a></p><p>实现效果：</p><p><img src="/loading.gif" data-original="https://s1.ax1x.com/2020/07/20/UhEmVg.png" alt=""></p><p><img src="/loading.gif" data-original="https://s1.ax1x.com/2020/07/20/UhEu5j.png" alt=""></p><p><img src="/loading.gif" data-original="https://s1.ax1x.com/2020/07/20/UhEnaQ.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> GitHub </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> GitHub </tag>
            
            <tag> 开源 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毕业季——大学路1号的时光</title>
      <link href="/2020/06/22/Graduation-season-Time-at-No.1-University-Road/"/>
      <url>/2020/06/22/Graduation-season-Time-at-No.1-University-Road/</url>
      
        <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Welcome to my blog, enter password to read.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="a9009c374d4b7cfb1d66a661a08dea589685c97ea8d62e599fb0b1c5ef40fe7c">d0d703fa332139beb12ceb85f23df7fc2dd2ad6c1e2d88c79a07ca82a4c752383c4b274b70abf24c2627b91511ca38c6827a85fb24bb1d405ef366f63d449475cc7e7021b2f42aea7973805ef690a099be12a8caa2ffdf6dbc9f6212144592fad5a584f16d9cbcc534663cce7d13c5205693b5799467cdca4f31b1eb3da117c4464e9d65e8d2ea086423bfac557b55b88f807ccf0b25016324b2051db850900f99f12708a26a6549e44778d76c46ce31d1a6d64c5e9d8db63da0630457acc014c67941c9a3f8ca646afc155801e88b3509b175e7ac010b442778b88935322dc16758351f90281084ecfd1b06f21cb5a1c4e1255c460c67ea328840963b1ad7b1f852cafe5fdc6953ede3c0673d806bfa009d3f5d6a00029084c1de6625e741a784f379c02f0721a131959f1754ef211784435f41555f56afffad6533146505632b14f921d8750f0e4c7c1c00230d7bf628979ea09ed966d3eb55372d38ff3bf805c1c77805ec55aba2a2aeb328eda1fe8b8169f03e8b9a67f46a326a164afca24fc5e4f68331ae95c4ace625a9715501c1f198e83f5a061c903b49d1b720ebd326b3fe72c0a073b053ba765a89d24dc176f1197e14d1acc1edbae8a2adceaf26af7f71d43eed341e7fabc01247053c938587d7882cc4f4d2312f08d6c1d3856ae6b39dd68e8a3b12db06d3f57467ef61ad68acd01050cfe046ad60a33908dc4904aff04670232a78751cf9607065641672daa569e559928628f784eb84fba585ba639dcee4ff4d2f17fb4aef454bfc4606bc37babe88146bb8d166260ab698a30c7370fa34c4cd9245872ca0276c2a1ecb235a19365668cfdc764907a1fc9337abd11e735c6ae36493d751da296cebaf47bd83dcd6d9d3e1698088b7bfafb1dde530cbdaec0ef7e395981db0ac70f38d9b93c0ea9235909716ebae4618fb20641f81a1709157837ce2062fbc60968004573d7e254edb23d7ad1540d8269d7ca1abef74fc6c257b73d3a031c15ec2ccbd66cb55a8eb7d8beb2dc712cb5e2a6f01420ce6b899e465e8a1336acce4304fda944a9e55f59d4a50786c3350dea77cf6fb6962eecea5d0b17e314ca50100e0da1b217d0d9fbe163fc1bb2c90697b4fdb0ec645efcf45d0f534d779a712f8d6503ac27c44783ef95a247944997e91efb1f74272e55d4ebab9e67333a64843f1081cd1dde55291d48d2632dfeb02aa30bd0ad4b9995d27496b12a7934a2907f635d8e847bb0f828cdfdfae317267d8f3d7d2efd4ed9c99c064d49778ede73d5aa93335110746f4e2acca0c0287e6fe9492060dcf7dccc1cec632cf3318ea4c410a198d24a71893d0ab57c105b268f2f5dd1cfc63bd52fdd54ae1ecd0c333e6f7554d5bc3bd9d6cefd4316954e9d142c398ff4b087609b2d154a5821df49cc15ad61b43660529fc4b2ebc2d4360d31636bf82b375820a4dcec56fcbca7f2daccf7581f37607856a5b6cefd54402a9d279b9e7a26e5298ede8df2d4c5c40ddcc9825b3d98ee7384d243bfb7e78796cb090635f38e406ce270998a698c8d43e21a9a6a9407a7a9f2e3d0c6de171b49876fdf1c848ae2d2f427c098a47e1fbbdac89f0cfdee868dc6c02f7b8462753fa245184245faee85f857c201b24b8704ec07328644f0377982ab9f01db118ec24d01a33e8977b417077daa07a8ae0ecee51500cb2b590cfccefee8b4c77e1f314aaabf5597290ae0d8d384e38c107502f8d5aad</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 随笔/杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 莞尔日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>要毕业了</title>
      <link href="/2020/05/30/School-celebration/"/>
      <url>/2020/05/30/School-celebration/</url>
      
        <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Welcome to my blog, enter password to read.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="04022c98e28eb804d78d6977517d525189fd6f278d9eba6271e33bc3795648a6">d0d703fa332139beb12ceb85f23df7fc2dd2ad6c1e2d88c79a07ca82a4c752383c4b274b70abf24c2627b91511ca38c6827a85fb24bb1d405ef366f63d449475cc7e7021b2f42aea7973805ef690a099be12a8caa2ffdf6dbc9f6212144592fad5a584f16d9cbcc534663cce7d13c5205693b5799467cdca4f31b1eb3da117c4464e9d65e8d2ea086423bfac557b55b88f807ccf0b25016324b2051db850900f99f12708a26a6549e44778d76c46ce31d1a6d64c5e9d8db63da0630457acc014c67941c9a3f8ca646afc155801e88b3509b175e7ac010b442778b88935322dc16758351f90281084ecfd1b06f21cb5a1c4e1255c460c67ea328840963b1ad7b1f852cafe5fdc6953ede3c0673d806bfab465055b76af0e55bfe15eea492ea750f9a0a07e1f42b385e4284b5c65df12f42604da7fab383df45f251f283e52995def43ebd728f6f41974639c9fd13d56ff246f847dbe18edb14c3416549ecd240c36fc7171724f671ff0c674be23902d3afff100a1a5cbd1e50a86512065b5bb8f74259b7ddd119983283ef678bb214d79937fb73c4ec90a09ac2e344eb4349b176b010dbd2ccd3b9361c981c69e072a00b46092b1b7cc4137d0ba09bf4810a9d678d3c124114184ad2f97060ce8f2073d</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 随笔/杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 莞尔日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++二维数组参数传递</title>
      <link href="/2020/05/01/C-or-C++_two-dimensional-array-parameter-transfer/"/>
      <url>/2020/05/01/C-or-C++_two-dimensional-array-parameter-transfer/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="C-C-语言中二维数组参数传递常用三种方法："><a href="#C-C-语言中二维数组参数传递常用三种方法：" class="headerlink" title="C/C++语言中二维数组参数传递常用三种方法："></a>C/C++语言中二维数组参数传递常用三种方法：</h3><ul><li><p>方法一：形参为二维数组并给出第二维的大小</p><p>如：<code>void sum(int a[][3])</code></p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a[][<span class="number">3</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line">s += a[<span class="number">0</span>][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">2</span>][<span class="number">3</span>] = &#123; &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125; &#125;;</span><br><span class="line">sum(b);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方法二：形参为指向数组的指针并给出数组的长度</p><p>如：<code>void sum(int (*a)[3])</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum1</span><span class="params">(<span class="keyword">int</span>(*a)[<span class="number">3</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line">s += a[<span class="number">0</span>][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方法三：形参为指针的指针且实参必须为指针，而不能是数组名</p><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> **a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line">s += a[<span class="number">0</span>][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *a[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">2</span>][<span class="number">3</span>] = &#123; &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125; &#125;;</span><br><span class="line">a[<span class="number">0</span>] = b[<span class="number">0</span>];</span><br><span class="line">a[<span class="number">1</span>] = b[<span class="number">1</span>];</span><br><span class="line">sum(a);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 二维数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>车辆轨迹追踪系统开发文档</title>
      <link href="/2020/04/29/Development-document-of-vehicle-trajectory-tracking-system/"/>
      <url>/2020/04/29/Development-document-of-vehicle-trajectory-tracking-system/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>车辆大规模GPS数据采集预处理系统</p><p>终端管理API接口：</p><div class="table-container"><table><thead><tr><th>模块</th><th>接口名称</th><th>功能说明</th></tr></thead><tbody><tr><td>entity</td><td>add</td><td>创建entity</td></tr><tr><td></td><td>update</td><td>更新entity</td></tr><tr><td></td><td>delete</td><td>删除entity</td></tr><tr><td></td><td>list</td><td>检索符合过滤条件的entity，返回entity属性信息和最新位置，可用于列出entity，也可用于批量查询多个entity的位置。</td></tr></tbody></table></div><p>API接口总览：<a href="http://lbsyun.baidu.com/index.php?title=yingyan/api/v3/entity" target="_blank" rel="noopener">http://lbsyun.baidu.com/index.php?title=yingyan/api/v3/entity</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>栈的应用——括号匹配</title>
      <link href="/2020/03/27/Stack-application-bracket-matching/"/>
      <url>/2020/03/27/Stack-application-bracket-matching/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>题目描述：编写程序，判定给定表达式中的括号是否匹配，表达式中的合法括号位 “(”，“)”，“[”，“]”，“{”，“}”，括号可按任意次序嵌套使用。</p><p>输入说明：有多个表达式，出入数据第一行是表达式的数目，每个表达式占一行。</p><p>输出说明：对每个表达式，若其括号匹配则输出“Yes”，否则输出“No”。</p><a id="more"></a><p>C++实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> ch[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;s;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">while</span> (n--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; ch;</span><br><span class="line">flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; ch[i] != <span class="string">'\0'</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ch[i] == <span class="string">'('</span> || ch[i] == <span class="string">'['</span> || ch[i] == <span class="string">'&#123;'</span>)</span><br><span class="line">&#123;</span><br><span class="line">s.push(ch[i]);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!s.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ch[i] == <span class="string">')'</span>&amp;&amp;s.top() == <span class="string">'('</span>)</span><br><span class="line">&#123;</span><br><span class="line">s.pop();</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ch[i] == <span class="string">']'</span>&amp;&amp;s.top() == <span class="string">'['</span>)</span><br><span class="line">&#123;</span><br><span class="line">s.pop();</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ch[i] == <span class="string">'&#125;'</span>&amp;&amp;s.top() == <span class="string">'&#123;'</span>)</span><br><span class="line">&#123;</span><br><span class="line">s.pop();</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ch[i] == <span class="string">')'</span>&amp;&amp;s.top() != <span class="string">'('</span>)</span><br><span class="line">&#123;</span><br><span class="line">flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ch[i] == <span class="string">']'</span>&amp;&amp;s.top() != <span class="string">'['</span>)</span><br><span class="line">&#123;</span><br><span class="line">flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ch[i] == <span class="string">'&#125;'</span>&amp;&amp;s.top() != <span class="string">'&#123;'</span>)</span><br><span class="line">&#123;</span><br><span class="line">flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (ch[i] == <span class="string">')'</span> || ch[i] == <span class="string">']'</span> || ch[i] == <span class="string">'&#125;'</span>)</span><br><span class="line">&#123;</span><br><span class="line">flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Yes"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"No"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>/<em>——测试用例——</em>/<br>/<em><br>[(d+f)</em>{}]<br>[(2+3)]<br>()}<br>[4(6]7)9<br>*/</p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 栈 </tag>
            
            <tag> 括号匹配 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈和队列的定义与使用</title>
      <link href="/2020/03/26/Definition-and-use-of-stacks-and-queues/"/>
      <url>/2020/03/26/Definition-and-use-of-stacks-and-queues/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>栈（Stack）：只允许在一端进行插入或删除操作的线性表。</p><p>队列（Queue）：只允许在表的一端进行插入，而在表的另一端进行删除的线性表。</p><p>栈的基本操作：</p><p><code>s.empty()               若栈为空返回true，否则返回false</code><br><code>s.size()                   返回栈中元素的个数</code><br><code>s.pop()                   弹出栈顶元素但不返回其值</code><br><code>s.top()                    若栈s非空，返回栈顶的元素</code><br><code>s.push()                 在栈顶压入新元素</code></p><a id="more"></a><p>队列的基本操作：</p><p><code>q.empty()               若队列为空返回true，否则返回false</code><br><code>q.size()                   返回队列中元素的个数</code><br><code>q.pop()                    弹出队列首元素但不返回其值</code><br><code>q.front()                   返回队首元素的值，但不删除该元素</code><br><code>q.push()                  在队尾压入新元素</code><br><code>q.back()                  返回队列尾元素的值，但不删除该元素</code></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>引入头文件：</p><p><code>#include&lt;stack&gt;</code></p><p><code>#include&lt;queue&gt;</code></p><p>定义栈：<code>stack&lt;int&gt; s;</code></p><p>定义队列：<code>queue&lt;int&gt; q;</code></p><p>举例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;s;<span class="comment">//定义一个栈  </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">s.push(i);</span><br><span class="line"><span class="keyword">while</span> (!s.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s.top() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">s.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"栈内的元素的个数为："</span> &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/tham_/article/details/44733101" target="_blank" rel="noopener">更多参考</a></p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 栈 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树构建与遍历——前序和中序或中序和后序确定二叉树</title>
      <link href="/2020/03/25/Bitree-construction-and-traversal/"/>
      <url>/2020/03/25/Bitree-construction-and-traversal/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="二叉树测试用例："><a href="#二叉树测试用例：" class="headerlink" title="二叉树测试用例："></a>二叉树测试用例：</h3><p><img src="/loading.gif" data-original="https://s1.ax1x.com/2020/04/04/GdqXuD.png" alt="二叉树"></p><p>preOrder: ABDGCEFH<br>inOrder: DGBAECHF<br>postOrder: GDBEHFCA</p><ol><li>已知二叉树前序遍历序列和中序遍历序列可以确定一颗二叉树。</li><li>已知二叉树中序遍历序列和后序遍历序列可以确定一颗二叉树。</li><li><u>已知二叉树前序遍历序列和后序遍历序列不能确定一颗二叉树。</u></li></ol><h3 id="已知二叉树前序和中序遍历序列，构造二叉树，C-实现："><a href="#已知二叉树前序和中序遍历序列，构造二叉树，C-实现：" class="headerlink" title="已知二叉树前序和中序遍历序列，构造二叉树，C++实现："></a>已知二叉树前序和中序遍历序列，构造二叉树，C++实现：</h3><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树结点定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> value;</span><br><span class="line">node *lchild;</span><br><span class="line">node *rchild;</span><br><span class="line">node(<span class="keyword">char</span> ch) &#123;</span><br><span class="line">value = ch;</span><br><span class="line">lchild = <span class="literal">NULL</span>;</span><br><span class="line">rchild = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归 二叉树前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(node *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; root-&gt;value;</span><br><span class="line">preOrder(root-&gt;lchild);</span><br><span class="line">preOrder(root-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归 二叉树中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(node *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root)</span><br><span class="line">&#123;</span><br><span class="line">inOrder(root-&gt;lchild);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; root-&gt;value;</span><br><span class="line">inOrder(root-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归 二叉树后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(node *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root)</span><br><span class="line">&#123;</span><br><span class="line">postOrder(root-&gt;lchild);</span><br><span class="line">postOrder(root-&gt;rchild);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; root-&gt;value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">node *<span class="title">buildBitree</span><span class="params">(<span class="built_in">string</span> pre, <span class="built_in">string</span> in)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = pre.length();</span><br><span class="line"><span class="keyword">if</span> (len &lt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">node *root = <span class="keyword">new</span> node(pre[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">int</span> n = in.<span class="built_in">find</span>(pre[<span class="number">0</span>]);</span><br><span class="line">root-&gt;lchild = buildBitree(pre.substr(<span class="number">1</span>, n), in.substr(<span class="number">0</span>, n));</span><br><span class="line">root-&gt;rchild = buildBitree(pre.substr(n + <span class="number">1</span>, len - n - <span class="number">1</span>), in.substr(n + <span class="number">1</span>, len - n - <span class="number">1</span>));</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> pre[<span class="number">100</span>], in[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; pre &gt;&gt; in)</span><br><span class="line">&#123;</span><br><span class="line">node *root = buildBitree(pre, in);</span><br><span class="line">postOrder(root);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//inOrder(root);</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//preOrder(root);</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="已知二叉树中序和后序遍历序列，构造二叉树，C-实现："><a href="#已知二叉树中序和后序遍历序列，构造二叉树，C-实现：" class="headerlink" title="已知二叉树中序和后序遍历序列，构造二叉树，C++实现："></a>已知二叉树中序和后序遍历序列，构造二叉树，C++实现：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">node *<span class="title">buildBitree</span><span class="params">(<span class="built_in">string</span> post, <span class="built_in">string</span> in)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = post.length();</span><br><span class="line"><span class="keyword">if</span> (len &lt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">node *root = <span class="keyword">new</span> node(post[len - <span class="number">1</span>]);</span><br><span class="line"><span class="keyword">int</span> n = in.<span class="built_in">find</span>(post[len - <span class="number">1</span>]);</span><br><span class="line">root-&gt;lchild = buildBitree(post.substr(<span class="number">0</span>, n), in.substr(<span class="number">0</span>, n));</span><br><span class="line">root-&gt;rchild = buildBitree(post.substr(n, len - n - <span class="number">1</span>), in.substr(n + <span class="number">1</span>, len - n - <span class="number">1</span>));</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Notes:</strong> </p><p>&emsp;&emsp;str.length()、str.size()均用来求取字符串的长度。</p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学校航拍</title>
      <link href="/2020/03/21/Cumt-aerial/"/>
      <url>/2020/03/21/Cumt-aerial/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>声明：视频资源来自网络，因为喜欢，所以上传到博客，如有侵权，请联系删除！</strong></p><script src='//player.polyv.net/script/polyvplayer.min.js'></script><div id='plv_8bb758cd63a75137b984b867c33dce10_8'></div><script>var player = polyvObject('#plv_8bb758cd63a75137b984b867c33dce10_8').videoPlayer({    'width':'900',  'height':'506',    'vid' : '8bb758cd63a75137b984b867c33dce10_8' , 'forceH5':true });</script>]]></content>
      
      
      <categories>
          
          <category> 随笔/杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 影音视频 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>金城兰州</title>
      <link href="/2020/03/20/Jincheng-lanzhou/"/>
      <url>/2020/03/20/Jincheng-lanzhou/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>声明：视频资源来自网络，因为喜欢，所以上传到博客，如有侵权，请联系删除！</strong></p><script src='//player.polyv.net/script/polyvplayer.min.js'></script><div id='plv_8bb758cd63e385239d8290fedb7e5dd7_8'></div><script>var player = polyvObject('#plv_8bb758cd63e385239d8290fedb7e5dd7_8').videoPlayer({    'width':'900',  'height':'506',    'vid' : '8bb758cd63e385239d8290fedb7e5dd7_8' , 'forceH5':true });</script>]]></content>
      
      
      <categories>
          
          <category> 随笔/杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 影音视频 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++十进制与二进制的互相转换</title>
      <link href="/2020/02/10/C++_decimal-and-binary-conversion/"/>
      <url>/2020/02/10/C++_decimal-and-binary-conversion/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>手动实现进制转换</p><p>十进制转换为二进制：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">decTobin</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> h,w=<span class="number">1</span>,sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (n)</span><br><span class="line">&#123;</span><br><span class="line">h = n % <span class="number">2</span>;</span><br><span class="line">sum += h * w;</span><br><span class="line">w *= <span class="number">10</span>;</span><br><span class="line">n = n / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>二进制转换为十进制：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binTodec</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> h,w=<span class="number">1</span>,sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (n)</span><br><span class="line">&#123;</span><br><span class="line">h = n % <span class="number">10</span>;</span><br><span class="line">sum += h * w;</span><br><span class="line">w *= <span class="number">2</span>;</span><br><span class="line">n = n / <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 进制转换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++动态数组</title>
      <link href="/2020/01/10/C-or-C++_dynamic-array/"/>
      <url>/2020/01/10/C-or-C++_dynamic-array/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>近来刷题，遇到好几道题目需要动态数组解决，现在整理一下。C++中动态开辟一维、二维数组很常见，也很实用。</p><ol><li><h5 id="动态开辟一维数组"><a href="#动态开辟一维数组" class="headerlink" title="动态开辟一维数组"></a>动态开辟一维数组</h5><p>动态开辟一维数组简单，代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DynamicCreate1Array</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;len;</span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;p[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[] p;         <span class="comment">//动态数组使用完一定要释放</span></span><br></pre></td></tr></table></figure><a id="more"></a></li><li><h5 id="动态开辟二维数组"><a href="#动态开辟二维数组" class="headerlink" title="动态开辟二维数组"></a>动态开辟二维数组</h5><ul><li><p>已知二维数组列数，未知行数。假设建立一个n行4列的动态数组（列已知）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DynamicCreate2Array</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">int</span>(*p)[<span class="number">4</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">4</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; p[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[] p;         <span class="comment">//动态数组使用完一定要释放</span></span><br></pre></td></tr></table></figure></li><li><p>二维数组行数、列数均未知</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DynamicCreate2Array</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> row, column;</span><br><span class="line"><span class="keyword">char</span> **p = <span class="keyword">new</span> <span class="keyword">char</span>*[row];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = <span class="keyword">new</span> <span class="keyword">char</span>[column];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; column; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; p[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//动态数组释放</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] p[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[]p;</span><br></pre></td></tr></table></figure><p>例：机器人走迷宫</p><p>迷宫由N W S E组成，踩到N向上走一格，踩到W向左走一格，踩到S向下走一格，踩到E向右走一格。</p><p>输入迷宫行数、列数、机器人开始的初试列数（不大于10，列数从1开始数），判断能否走出迷宫。能走出输出步数，不能走出输出”NO”，多组输入，遇 0 0 0 结束输入。</p><p>例：</p><p>输入：</p><p>4 5 6</p><p>NNNNSN</p><p>NNNSWN</p><p>NNSWNN</p><p>NSWNNN</p><p>3 6 2</p><p>NSNNNN</p><p>NSWNNN</p><p>NENNNN</p><p>0 0 0</p><p>输出：</p><p>7</p><p>No</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*----机器人走迷宫----*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> row, column, <span class="built_in">begin</span>, <span class="built_in">step</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; row &gt;&gt; column &gt;&gt; <span class="built_in">begin</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (row == <span class="number">0</span> &amp;&amp; column == <span class="number">0</span> &amp;&amp; <span class="built_in">begin</span> == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">step</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> **p = <span class="keyword">new</span> <span class="keyword">char</span>*[row];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">&#123;</span><br><span class="line">p[i] = <span class="keyword">new</span> <span class="keyword">char</span>[column];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; column; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; p[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="built_in">begin</span> - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; row &amp;&amp; i &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (j &lt; column &amp;&amp; j &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (p[i][j] == <span class="string">'N'</span>)</span><br><span class="line">&#123;</span><br><span class="line">p[i][j] = <span class="string">'0'</span>;</span><br><span class="line"><span class="built_in">step</span>++;</span><br><span class="line">i--;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p[i][j] == <span class="string">'S'</span>)</span><br><span class="line">&#123;</span><br><span class="line">p[i][j] = <span class="string">'0'</span>;</span><br><span class="line"><span class="built_in">step</span>++;</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">break</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p[i][j] == <span class="string">'W'</span>)</span><br><span class="line">&#123;</span><br><span class="line">p[i][j] = <span class="string">'0'</span>;</span><br><span class="line">j--;</span><br><span class="line"><span class="built_in">step</span>++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p[i][j] == <span class="string">'E'</span>)</span><br><span class="line">&#123;</span><br><span class="line">p[i][j] = <span class="string">'0'</span>;</span><br><span class="line">j++;</span><br><span class="line"><span class="built_in">step</span>++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">step</span> = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">step</span> == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">step</span> != <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">step</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"No"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span>[] p[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[]p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">```</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 动态数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 100天</title>
      <link href="/2019/11/02/Python-100-days/"/>
      <url>/2019/11/02/Python-100-days/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="【程序1】"><a href="#【程序1】" class="headerlink" title="【程序1】"></a>【程序1】</h3><p>题目：有1、2、3、4个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python函数存储在模块中的函数调用</title>
      <link href="/2019/10/04/Python-function-call-and-module/"/>
      <url>/2019/10/04/Python-function-call-and-module/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>python中常见将函数存储在被称为模块的独立文件中，再将模块导入到主程序中，import语句实现当前运行的程序文件中导入模块中的代码。</p><p>要让函数是可导入的，得先创建模块。模块是扩展名为.py的文件，包含要导入到程序中的代码。</p><a id="more"></a><h2 id="1-导入整个模块"><a href="#1-导入整个模块" class="headerlink" title="1.导入整个模块"></a>1.导入整个模块</h2><p>语法规则：</p><p>module_name.function_name()</p><h2 id="2-导入特定的函数"><a href="#2-导入特定的函数" class="headerlink" title="2.导入特定的函数"></a>2.导入特定的函数</h2><p>语法规则：</p><p>from module_name import function_name</p><p>通过用逗号分隔函数名，可根据需要从模块中导入任意数量的函数：</p><p>from module_name import function_0, function_1, function_2</p><h2 id="3-使用as给函数指定别名"><a href="#3-使用as给函数指定别名" class="headerlink" title="3.使用as给函数指定别名"></a>3.使用as给函数指定别名</h2><p>语法规则：</p><p>from module_name import function_name as fn</p><h2 id="4-使用as给模块指定别名"><a href="#4-使用as给模块指定别名" class="headerlink" title="4.使用as给模块指定别名"></a>4.使用as给模块指定别名</h2><p>语法规则：</p><p>import module_name as mn</p><h2 id="5-导入模块中的所有函数"><a href="#5-导入模块中的所有函数" class="headerlink" title="5.导入模块中的所有函数"></a>5.导入模块中的所有函数</h2><p>语法规则：</p><p>from module_name import * </p><p>（不建议使用此方法）</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 函数调用 </tag>
            
            <tag> 模块 </tag>
            
            <tag> import </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux socket通信编程</title>
      <link href="/2019/07/01/Linux-socket-communication-programming/"/>
      <url>/2019/07/01/Linux-socket-communication-programming/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>示例：用C语言，基于linux提供的socket函数，编写一个实现“从客户端输入十个字符串，在服务器端完成字符数和单词数统计，并按首位字母排序”的远程计算的网络服务程序。 </p><a id="more"></a><h3 id="1、UDP编程说明"><a href="#1、UDP编程说明" class="headerlink" title="1、UDP编程说明"></a>1、UDP编程说明</h3><p>UDP协议的服务器端流程：</p><p>(1)建立套接字文件描述符，使用函数socket()，生成套接字文件描述符。</p><p>(2)设置服务器地址和侦听端口，初始化要绑定的网络地址结构。</p><p>(3)绑定侦听端口，使用bind()函数，将套接字文件描述符和一个地址类型变量进行绑定。</p><p>(4)接收客户端的数据，使用recvfrom()函数接收客户端的网络数据。</p><p>(5)向客户端发送数据，使用sendto()函数向服务器主机发送数据。</p><p>(6)关闭套接字，使用close()函数释放资源。UDP协议的客户端流程</p><p>UDP协议的客户端流程：</p><p>(1)建立套接字文件描述符，socket()；</p><p>(2)设置服务器地址和端口，struct sockaddr；</p><p>(3)向服务器发送数据，sendto()；</p><p>(4)接收服务器的数据，recvfrom()；</p><p>(5)关闭套接字，close()。</p><p><img src="/loading.gif" data-original="https://i.loli.net/2019/12/31/kU7i4GObXKWndrw.png" alt="UDP编程流程"></p><h3 id="2、相关函数"><a href="#2、相关函数" class="headerlink" title="2、相关函数"></a>2、相关函数</h3><p>(1)  int socket(AF_INET, SOCK_DGRAM, 0);</p><p>创建udp socket，返回套接字描述符，UDP协议建立套接字的方式同TCP方式一样，使用socket()函数，只不过协议的类型使用SOCK_DGRAM，而不是SOCK_STREAM。</p><p>(2) int sendto(int sockfd, const void <em>data, int data_len, unsigned int flags, struct sockaddr </em>remaddr,sock_lenremaddr_len)</p><p>功能：基于UDP发送数据报，返回实际发送的数据长度，出错时返回－1</p><p>参数说明：</p><p>sockfd:套接字描述符</p><p>data:指向要发送数据的指针</p><p>data_len:数据长度</p><p>flags:通常为0</p><p>remaddr:远端地址：IP地址和端口号</p><p>remaddr_len:地址长度</p><p>(3) int recvfrom(int sockfd, void <em>buf,int buf_len,unsigned int flags,struct sockaddr </em>from,sock_len *fromlen);</p><p>功能：从UDP接收数据，返回实际接收的字节数，失败时返回－1</p><p>参数说明：</p><p>Sockfd:套接字描述符</p><p>buf:指向内存块的指针</p><p>buf_len:内存块大小，以字节为单位</p><p>flags:一般为0</p><p>from:远端的地址，IP地址和端口号</p><p>fromlen:远端地址长度</p><h3 id="3、程序编写"><a href="#3、程序编写" class="headerlink" title="3、程序编写"></a>3、程序编写</h3><p>(1) 用C语言编写客户端程序，创建一个socket通信，从客户端输入十个字符串。</p><p>(2) 编译客户端程序生成可执行文件</p><p>输入命令：gcc client1.c -o client1</p><p>​              ./client1</p><p><img src="/loading.gif" data-original="https://i.loli.net/2019/12/31/nDbKUhktrEle2AM.png" alt="编译客户端程序"></p><p>(3) 用C语言编写服务器端程序，绑定客户端通信，接收从客户端输入的十个字符串，显示在屏幕上，并统计输入的字符串中总的单词数和字符数，并按首位字母的ASCII码值从高到低进行排列，输出显示到屏幕。</p><p>(4) 编译服务器端程序生成可执行文件</p><p>输入命令：gcc server1.c -o server1</p><p>​              ./server1</p><p><img src="/loading.gif" data-original="https://i.loli.net/2019/12/31/P57M3ksLFhqHdyK.png" alt="编译服务器端程序"></p><h3 id="4、程序运行效果"><a href="#4、程序运行效果" class="headerlink" title="4、程序运行效果"></a>4、程序运行效果</h3><p>(1) 客户端输入十个字符串。</p><p>注：输入10个字符串时每行代表1个字符串，10字符串10行，由于字符串的输入是由 fgets() 函数实现的，所以获取字符串的时候会将空格符和换行符也进行保存，这点在后面进行总字符数的统计时也体现了出来，获取的字符串由结构体sendbuf[10]进行存储。</p><p><img src="/loading.gif" data-original="https://i.loli.net/2019/12/31/HqKkpUYsr7o6OVA.png" alt="客户端运行效果"></p><p>(2) 服务器端接收数据，显示在屏幕上，并统计输入的字符串中总的单词数和字符数，并按首位字母的ASCII码值从高到低进行排列，输出显示到屏幕。</p><p>注：统计总单词数相当于统计总空格数，空格数+1即为总单词数，字符数的统计结果包括了每个字符串的空格和换行符，每个字符串都有一个换行符，如图9，可以看到得到的总字符数85中包含了所有的空格符和换行符。利用冒泡排序，直接比较输入的10个字符串的首字母，实现字符串按首字母ASCII码值从大到小排列。</p><p><img src="/loading.gif" data-original="https://i.loli.net/2019/12/31/ezErBTlbW7FoQSx.png" alt="服务器端运行效果"></p><h3 id="5、字符串排序说明"><a href="#5、字符串排序说明" class="headerlink" title="5、字符串排序说明"></a>5、字符串排序说明</h3><p>(1) 实现将10个字符串按首字母的ASCII码值从高到低进行排列并依次输出显示在屏幕上。</p><p>功能实现：输入的10个字符串设置结构体sendbuf[10]保存，再服务器端设置结构体recvbuf[10]接收数据，利用冒泡排序，先将每个字符串的首字母取出来，将其值赋给服务端接收缓冲区结构体的recvbuf[i].init成员（专门用于存储字符串的首字母），再直接比较recvbuf[i].init成员值的ASCII码值大小，实现从高到底排列并输出到屏幕上。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; <span class="number">10</span>; n++)</span><br><span class="line">​    &#123;</span><br><span class="line">​        <span class="keyword">int</span> k = n;</span><br><span class="line">​        <span class="keyword">for</span> (<span class="keyword">int</span> m = n + <span class="number">1</span>; m &lt; <span class="number">10</span>; m++)</span><br><span class="line">​        &#123;</span><br><span class="line">​            <span class="keyword">if</span> (recvbuf[k].init &lt; recvbuf[m].init)</span><br><span class="line">​                k = m;</span><br><span class="line">​        &#125;</span><br><span class="line">​        <span class="keyword">if</span> (k != n)</span><br><span class="line">​        &#123;</span><br><span class="line">​            temp = recvbuf[n];</span><br><span class="line">​            recvbuf[n] = recvbuf[k];</span><br><span class="line">​            recvbuf[k] = temp;</span><br><span class="line">​        &#125;</span><br><span class="line">​    &#125;</span><br><span class="line">​    <span class="built_in">printf</span>(<span class="string">"字符串按首字母ASCII码值从大到小排列为：\n"</span>);</span><br><span class="line">​    <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; <span class="number">10</span>; n++)</span><br><span class="line">​    &#123;</span><br><span class="line">​        <span class="built_in">printf</span>(<span class="string">"%s"</span>, recvbuf[n].string_client);</span><br><span class="line">​    &#125;</span><br></pre></td></tr></table></figure><h3 id="6、完整客户端、服务器端程序代码"><a href="#6、完整客户端、服务器端程序代码" class="headerlink" title="6、完整客户端、服务器端程序代码"></a>6、完整客户端、服务器端程序代码</h3><p>客户端程序源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">define</span> MYPORT 8886</span></span><br><span class="line"><span class="keyword">char</span>* SERVERIP = <span class="string">"127.0.0.1"</span>;</span><br><span class="line">\<span class="meta">#<span class="meta-keyword">define</span> ERR_EXIT(m) \</span></span><br><span class="line">​    <span class="keyword">do</span> \</span><br><span class="line">&#123; \</span><br><span class="line">​    perror(m); \</span><br><span class="line">​    <span class="built_in">exit</span>(EXIT_FAILURE); \</span><br><span class="line">​    &#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">echo_cli</span><span class="params">(<span class="keyword">int</span> sock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">​    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">​    <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">​    servaddr.sin_family = AF_INET;</span><br><span class="line">​    servaddr.sin_port = htons(MYPORT);</span><br><span class="line">​    servaddr.sin_addr.s_addr = inet_addr(SERVERIP);</span><br><span class="line">​    <span class="keyword">int</span> ret;</span><br><span class="line">​    <span class="class"><span class="keyword">struct</span> <span class="title">client</span></span></span><br><span class="line"><span class="class">​    &#123;</span></span><br><span class="line">​        <span class="keyword">char</span> string_client[<span class="number">100</span>];</span><br><span class="line">​    &#125;sendbuf[<span class="number">10</span>];</span><br><span class="line">​    <span class="class"><span class="keyword">struct</span> <span class="title">server</span></span></span><br><span class="line"><span class="class">​    &#123;</span></span><br><span class="line">​        <span class="keyword">char</span> string_client[<span class="number">100</span>];</span><br><span class="line">​    &#125;recvbuf[<span class="number">10</span>];</span><br><span class="line">​    <span class="comment">//struct client temp;</span></span><br><span class="line">​    <span class="comment">//struct server temp;</span></span><br><span class="line">​    <span class="keyword">int</span> i;</span><br><span class="line">​    <span class="built_in">printf</span>(<span class="string">"请输入10字符串：\n"</span>);</span><br><span class="line">​    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">​    &#123;</span><br><span class="line">​        fgets(sendbuf[i].string_client,<span class="number">100</span>,<span class="built_in">stdin</span>);</span><br><span class="line">​    &#125;</span><br><span class="line">​    <span class="built_in">printf</span>(<span class="string">"向服务器发送：\n"</span>);</span><br><span class="line">​    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">​    &#123;</span><br><span class="line">​        <span class="built_in">printf</span>(<span class="string">"%s"</span>, sendbuf[i].string_client);</span><br><span class="line">​        sendto(sock, sendbuf[i].string_client, <span class="built_in">strlen</span>(sendbuf[i].string_client), <span class="number">0</span>, (struct sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">​        <span class="built_in">memset</span>(sendbuf, <span class="number">0</span>, <span class="keyword">sizeof</span>(sendbuf[i].string_client));</span><br><span class="line">​    &#125;</span><br><span class="line">​    <span class="built_in">close</span>(sock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">​    <span class="keyword">int</span> sock;</span><br><span class="line">​    <span class="keyword">if</span> ((sock = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">​        ERR_EXIT(<span class="string">"socket"</span>);</span><br><span class="line">​    echo_cli(sock);</span><br><span class="line">​    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器端程序源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">define</span> MYPORT 8886</span></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">define</span> ERR_EXIT(m) \</span></span><br><span class="line">​    <span class="keyword">do</span> &#123; \</span><br><span class="line">​    perror(m); \</span><br><span class="line">​    <span class="built_in">exit</span>(EXIT_FAILURE); \</span><br><span class="line">​    &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">echo_ser</span><span class="params">(<span class="keyword">int</span> sock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">​    <span class="comment">//char recvbuf[1024] = &#123;0&#125;;</span></span><br><span class="line">​    <span class="class"><span class="keyword">struct</span> <span class="title">server</span></span></span><br><span class="line"><span class="class">​    &#123;</span></span><br><span class="line">​        <span class="keyword">char</span> string_client[<span class="number">100</span>];</span><br><span class="line">​        <span class="keyword">char</span> init;</span><br><span class="line">​    &#125;recvbuf[<span class="number">10</span>];</span><br><span class="line">​    <span class="class"><span class="keyword">struct</span> <span class="title">server</span> <span class="title">temp</span>;</span></span><br><span class="line">​    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">peeraddr</span>;</span></span><br><span class="line">​    <span class="keyword">socklen_t</span> peerlen;</span><br><span class="line">​    <span class="keyword">int</span> n;</span><br><span class="line">​    <span class="keyword">int</span> i, nword=<span class="number">0</span>, nchar=<span class="number">0</span>;</span><br><span class="line">​    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">​    &#123;       </span><br><span class="line">​        peerlen = <span class="keyword">sizeof</span>(peeraddr);</span><br><span class="line">​        <span class="built_in">memset</span>(recvbuf[i].string_client, <span class="number">0</span>, <span class="keyword">sizeof</span>(recvbuf[i].string_client));</span><br><span class="line">​        n = recvfrom(sock, recvbuf[i].string_client, <span class="keyword">sizeof</span>(recvbuf[i].string_client), <span class="number">0</span>,</span><br><span class="line">​                     (struct sockaddr *)&amp;peeraddr, &amp;peerlen);</span><br><span class="line">​        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">​        &#123;            </span><br><span class="line">​            <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">​                <span class="keyword">continue</span>;          </span><br><span class="line">​            ERR_EXIT(<span class="string">"recvfrom error"</span>);</span><br><span class="line">​        &#125;</span><br><span class="line">​        <span class="keyword">else</span> <span class="keyword">if</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">​        &#123;</span><br><span class="line">​            <span class="built_in">printf</span>(<span class="string">"接收到的数据：%s"</span>,recvbuf[i].string_client);</span><br><span class="line">​            <span class="comment">//printf("%s",recvbuf[i].string_client);</span></span><br><span class="line">​            <span class="comment">//sendto(sock, recvbuf, n, 0,</span></span><br><span class="line">​            <span class="comment">//       (struct sockaddr *)&amp;peeraddr, peerlen);</span></span><br><span class="line">​            <span class="comment">//printf("回送的数据：%s\n",recvbuf[i].string_client);</span></span><br><span class="line">​        &#125;</span><br><span class="line">​    &#125;</span><br><span class="line">​    <span class="keyword">int</span> numWhiteSpace = <span class="number">0</span>;</span><br><span class="line">​    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">​    <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; <span class="number">10</span>; n++)</span><br><span class="line">​    &#123;</span><br><span class="line">​        <span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line">​        <span class="built_in">strcpy</span>(str, recvbuf[n].string_client);</span><br><span class="line">​        <span class="comment">//printf("字符串：%s\n", str);</span></span><br><span class="line">​        recvbuf[n].init = str[<span class="number">0</span>];</span><br><span class="line">​        <span class="keyword">while</span> (<span class="string">'\0'</span> != str[j])</span><br><span class="line">​        &#123;</span><br><span class="line">​            <span class="keyword">if</span> (<span class="string">' '</span> == str[j])&#123;</span><br><span class="line">​                ++numWhiteSpace;   <span class="comment">//空格数</span></span><br><span class="line">​            &#125;</span><br><span class="line">​            ++j; <span class="comment">//字符数</span></span><br><span class="line">​        &#125;</span><br><span class="line">​        nchar = j + nchar;</span><br><span class="line">​        nword = numWhiteSpace + <span class="number">1</span>+nword;</span><br><span class="line">​        j = <span class="number">0</span>;</span><br><span class="line">​        numWhiteSpace = <span class="number">0</span>;</span><br><span class="line">​    &#125;</span><br><span class="line">​    <span class="built_in">printf</span>(<span class="string">"输入字符串的总单词数：%d\n"</span>, nword);</span><br><span class="line">​    <span class="built_in">printf</span>(<span class="string">"输入字符串的总字符数（包括空格、换行符）：%d\n"</span>, nchar); </span><br><span class="line">​    <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; <span class="number">10</span>; n++)</span><br><span class="line">​    &#123;</span><br><span class="line">​        <span class="keyword">int</span> k = n;</span><br><span class="line">​        <span class="keyword">for</span> (<span class="keyword">int</span> m = n + <span class="number">1</span>; m &lt; <span class="number">10</span>; m++)</span><br><span class="line">​        &#123;</span><br><span class="line">​            <span class="keyword">if</span> (recvbuf[k].init &lt; recvbuf[m].init)</span><br><span class="line">​                k = m;</span><br><span class="line">​        &#125;</span><br><span class="line">​        <span class="keyword">if</span> (k != n)</span><br><span class="line">​        &#123;</span><br><span class="line">​            temp = recvbuf[n];</span><br><span class="line">​            recvbuf[n] = recvbuf[k];</span><br><span class="line">​            recvbuf[k] = temp;</span><br><span class="line">​        &#125;</span><br><span class="line">​    &#125;</span><br><span class="line">​    <span class="built_in">printf</span>(<span class="string">"字符串按首字母ASCII码值从大到小排列为：\n"</span>);</span><br><span class="line">​    <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; <span class="number">10</span>; n++)</span><br><span class="line">​    &#123;</span><br><span class="line">​        <span class="built_in">printf</span>(<span class="string">"%s"</span>, recvbuf[n].string_client);</span><br><span class="line">​    &#125;</span><br><span class="line">​    <span class="built_in">close</span>(sock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">​    <span class="keyword">int</span> sock;</span><br><span class="line">​    <span class="keyword">if</span> ((sock = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">​        ERR_EXIT(<span class="string">"socket error"</span>);</span><br><span class="line">​    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">​    <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">​    servaddr.sin_family = AF_INET;</span><br><span class="line">​    servaddr.sin_port = htons(MYPORT);</span><br><span class="line">​    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);  </span><br><span class="line">​    <span class="built_in">printf</span>(<span class="string">"监听%d端口\n"</span>,MYPORT);</span><br><span class="line">​    <span class="keyword">if</span> (bind(sock, (struct sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr)) &lt; <span class="number">0</span>)</span><br><span class="line">​        ERR_EXIT(<span class="string">"bind error"</span>);   </span><br><span class="line">​    echo_ser(sock);  </span><br><span class="line">​    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> socket通信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务器基础知识与配置</title>
      <link href="/2019/06/10/Server-basics-and-configuration/"/>
      <url>/2019/06/10/Server-basics-and-configuration/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>1、什么是守护进程？守护进程的类型和作用有哪些？</p><p>Linux 服务器在启动时需要启动很多系统服务，它们向本地和网络用户提供了Linux的系统功能接口，直接面向应用程序和用户。提供这些服务的程序是由运行在后台的守护进程来执行的。守护进程是生存期长的一种进程。它们独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件。他们常常在系统引导装入时启动，在系统关闭时终止。linux系统有很多守护进程，大多数服务器都是用守护进程实现的。同时，守护进程完成许多系统任务，比如，作业规划进程crond、打印进程lqd等。</p><a id="more"></a><p>根据守护进程的启动和管理方式，可以分为独立启动守护进程和超级守护进程两类：</p><p>独立启动（stand_alone):该类进程启动后就常驻内存，所以会一直占用系统资源。其最大的优点就是它会一直启动，当外界有要求时相应速度较快，像httpd等进程。</p><p>超级守护进程：系统启动时由一个统一的守护进程xinet来负责管理一些进程，当相应请求到来时需要通过xinet的转接才可以唤醒被xinet管理的进 程。这种进程的优点时最初只有xinet这一守护进程占有系统资源，其他的内部服务并不一直占有系统资源，只有数据包到来时才会被xinet管理员来唤醒。并且我们还可以通过xinet来对它所管理的进程设置一些访问权限，相当于多了一层管理机制。</p><p>2.linux的init进程是怎样的进程？细说init和linux上的各服务进程之间的关系？</p><p>init是Linux系统操作中不可缺少的程序之一。所谓的init进程，它是一个由内核启动的用户级进程。内核自行启动（已经被载入内存，开始运行，并已初始化所有的设备驱动程序和数据结构等）之后，就通过启动一个用户级程序init的方式，完成引导进程。</p><p>所以,init始终是第一个进程（其进程编号始终为1）。内核会在过去曾使用过init的几个地方查找它，它的正确位置（对Linux系统来说）是/sbin/init。如果内核找不到init，它就会试着运行/bin/sh，如果运行失败，系统的启动也会失败。</p><p>init进程由0进程创建，完成系统的初始化，是系统中所有其他用户进程的祖先进程。</p><p>3.Apache服务器的配置文件httpd.conf中有很多内容，请解释如下配置项：</p><p>（1）MaxKeepAliveRequests 200 </p><p>允许每次连接的最大请求数目，此为200。</p><p>（2）UserDir public_html</p><p>设定用户放置网页的目录。</p><p>（3）DefaultType text/plain </p><p>设置服务器对于不认识的文件类型的预设格式。</p><p>（4）AddLanguare en.en</p><p>设置可传送语言的文件给浏览器。</p><p>（5）DocumentRoot“/usr/local/httpd/htdocs”</p><p>该目录为Apache放置网页的地方。</p><p>（6）AddType application/x-httpd-php.php.php.php4</p><p>服务器选择使用php4。</p><p>（7）port 1080 </p><p>将apache服务器的端口号设定为1080。</p><p>（8）UserDir userdoc</p><p>设定用户网页目录为userdoc。</p><p>（9）DocumentRoot “/home/htdocs”</p><p>设定apache服务器的网页根目录:/home/htdocs。</p><p>（10）Options Indexes FollowSymLinks   AllowOverride None </p><p>Order deny,allow     deny from all     allow from 192.168.1.5</p><p>在此apache服务器上设定一个目录/home/htdocs/inside，且此目录只允许IP地址为192.168.1.5的主机访问。</p><p>（11）Server Type Standlone</p><p>定义apache服务器以独立进程的方式运行。</p><p>4.什么是Apache的虚拟主机？其作用是什么？Apache虚拟主机实现方法有哪些？</p><p>Apache是开源的web服务软件之一，也是现在开源系统比如centos上安装web服务常见软件；虚拟主机是提供网站服务的集成环境，比如：linux Apache+php+mysq、LAMP。就是常说的建站开通的虚拟空间，所以Apache服务器只是虚拟空间的一种架构。在一个Apache服务器上可以配置多个虚拟主机，实现一个服务器提供多站点服务，其实就是访问同一个服务器上的不同目录。</p><p>Apache虚拟主机的配置方式主要有三种，即基于IP、基于port、以及基于域名。</p><p>5.简述使用ftp进行文件传输时的两种登录方式？它们的区别是什么？常用的ftp文件传输命令有哪些？</p><p>ftp有两种登录方式：匿名登录和授权登录。使用匿名登录时，用户名为：anonymous，密码为：任何合法email地址；使用授权登录时，用户名为用户在远程系统中的用户帐号，密码为用户在远程系统中的用户密码。</p><p>区别：使用匿名登录只能访问ftp目录下的资源，默认配置下只能下载；而授权登录访问的权限大于匿名登录，且上载、下载均可。</p><p>ftp文件传输有两种文件传输模式：ASCII模式和二进制数据模式。ASCII模式用来传输文本文件，其他文件的传输使用binary模式。</p><p>常用的ftp文件传输命令为：bin、asc、put、get、mput、mget、prompt、bye。</p>]]></content>
      
      
      <categories>
          
          <category> Linux 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 编程实例</title>
      <link href="/2019/06/03/Linux-programming-examples/"/>
      <url>/2019/06/03/Linux-programming-examples/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>示例：用C语言编写一个从键盘输入10名学生的姓名、性别、学号和家庭住址，然后按照学号排序，并将排序后的结果在屏幕上按对齐的方式打印输出的程序。</p><a id="more"></a><p>C语言排序程序源码 (学号按从高到低排序)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//输入10名学生的姓名，性别，学号，家庭住址；</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line">​    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">char</span> sex[<span class="number">4</span>];  </span><br><span class="line"></span><br><span class="line">​    <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">char</span> address[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">&#125;info[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">​    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">temp</span>;</span></span><br><span class="line"></span><br><span class="line">​    <span class="keyword">int</span> i,j, k;</span><br><span class="line"></span><br><span class="line">​    <span class="built_in">printf</span>(<span class="string">"请输入10个学生的信息:姓名、性别、学号、家庭住址\n"</span>);</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​       <span class="comment">//printf("请输入第%d位学生的信息:姓名、性别、学号、家庭住址\n", i + 1);</span></span><br><span class="line"></span><br><span class="line">​       <span class="built_in">scanf</span>(<span class="string">"%s%s%d%s"</span>, info[i].name, &amp;info[i].sex, &amp;info[i].id, &amp;info[i].address);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​       k = i;</span><br><span class="line"></span><br><span class="line">​       <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line"></span><br><span class="line">​       &#123;</span><br><span class="line"></span><br><span class="line">​              <span class="keyword">if</span> (info[k].id &lt; info[j].id)</span><br><span class="line"></span><br><span class="line">​                     k = j;</span><br><span class="line"></span><br><span class="line">​       &#125;</span><br><span class="line"></span><br><span class="line">​       <span class="keyword">if</span> (k != i)</span><br><span class="line"></span><br><span class="line">​       &#123;</span><br><span class="line"></span><br><span class="line">​              temp = info[i];</span><br><span class="line"></span><br><span class="line">​              info[i] = info[k];</span><br><span class="line"></span><br><span class="line">​              info[k] = temp;</span><br><span class="line"></span><br><span class="line">​       &#125;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    <span class="built_in">printf</span>(<span class="string">"10个学生的信息按序号由高到低排序为\n"</span>);</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​       <span class="built_in">printf</span>(<span class="string">"%s\t%s\t%d\t%s\n"</span>, info[i].name, info[i].sex, info[i].id, info[i].address);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象语言的缺点和问题</title>
      <link href="/2019/01/01/Disadvantages-and-problems-of-object-oriented-languages/"/>
      <url>/2019/01/01/Disadvantages-and-problems-of-object-oriented-languages/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>面向对象编程是一种计算机编程架构。面向对象编程的一条基本原则是计算机程序是由单个能够起到子程序作用的单元或对象组合而成。面向对象编程达到了软件工程的三个主要目标：重用性、灵活性和扩展性。为了实现整体运算，每个对象都能够接收信息、处理数据和向其它对象发送信息。</p><a id="more"></a><p>刚开始学习C++ 时，我们首先了解到的就是面向对象语言的四个基本特征：抽象、继承、封装、多态、以及一大堆面向对象语言的优点包括代码重用，权限控制，易扩展，开发效率高之类的。毫无疑问面向对象编程的出现使人们的编程与实际的世界更加接近，所有的对象被赋予属性和方法，结果编程就更加富有人性化，但同时面向对象语言从诞生之日起就一直伴随着许多的缺陷。 </p><h3 id="1、运行速度慢"><a href="#1、运行速度慢" class="headerlink" title="1、运行速度慢"></a>1、运行速度慢</h3><p>就 C++ 而言，由于面向更高的逻辑抽象层，使得 C++ 在实现的时候，不得不做出性能上面的牺牲，有时候甚至是致命的 ( 所有对象的属性都经过内置多重指针的间接引用是其性能损失的主要原因之一)。<br>在计算机速度飞速发展的今天，你可能会说，一丁点的性能牺牲没什么大不了。是的，从面向对象的角度，使的编程的结构更加清晰完整，数据更加独立和易于管理，性能的牺牲可以带来这么多的好处，没有理由不做稳赚的生意吧？<br>不过，在某些对速度要求极高特殊场合，例如你做的是电信的交换系统，每秒钟有超过百万的人同时进行电话交换，如果，每一个数据交换过程都是一个对象，那么总的性能损失将是天文数字！！<br>或者这个例子不够贴身，再举个例子吧。假如你受聘于一个游戏设计公司，老板希望做出来的游戏可以更多的兼顾到更多的电脑使用者，游戏每秒钟的运行的帧可以 更多，子弹和爆炸物可以更多、更华丽。那么，你会发现使用 C++ 会使你的程序变得笨拙，无法满足你的需求。</p><h3 id="2、继承的代价庞大，增加了代码量"><a href="#2、继承的代价庞大，增加了代码量" class="headerlink" title="2、继承的代价庞大，增加了代码量"></a>2、继承的代价庞大，增加了代码量</h3><p>对于面向过程语言来说，编程时需要哪些变量和方法就只编写这些变量和方法，而对于面向对象语言来说，每次无论你要使用什么都要先写一个类，并且每一个类都要有独立的变量和方法，这样就会造成可能很简单的问题也要很多的类代码，为了解决这个缺点，继承便出现了，继承可以让类与类可以共享代码，获得代码的可重用性，一定程度上降低了代码量。但是，随着继承层次的增加，代码的复杂性会加速增长，随之而来的bug也会越来越难以发现。</p><h3 id="3、对象与对象之间相互依赖，耦合性太高"><a href="#3、对象与对象之间相互依赖，耦合性太高" class="headerlink" title="3、对象与对象之间相互依赖，耦合性太高"></a>3、对象与对象之间相互依赖，耦合性太高</h3><p>由于面向对象语言中一切都是对象，我们必须使用一个对象去创建另外一个对象，才能使用其内部方法，这样就造成了这些对象之间相互依赖，为了消除这些依赖，我们可以把创建对象的代码全部集中到一个对象之中，其他的对象都通过调用该对象的方法来动态的获取所需要的对象，这也就是我们所说的工厂模式。进一步地，我们可以不使用工厂，而是编写一个插件，该插件可以把我们所需要的对象在运行时动态地“塞”给我们，这就是依赖注入，也就是控制反转。这个插件就相当于Spring IOC。</p><h3 id="4、失去了灵活性"><a href="#4、失去了灵活性" class="headerlink" title="4、失去了灵活性"></a>4、失去了灵活性</h3><p>面向对象语言代码都很死板，继承也没有运行时动态，但是java的多态机制，其不同于面向过程语言的方法后期绑定，在运行时才能确定具体调用的是哪个方法一定程度上增加了其灵活性。面向对象语言一直提倡的组合大于继承的思想诞生了许许多多的设计模式，这些设计模式通过对组合和多态的奇妙运用大大的增加了面向对象语言的灵活性。</p><h3 id="5、需要一定的软件支持环境"><a href="#5、需要一定的软件支持环境" class="headerlink" title="5、需要一定的软件支持环境"></a>5、需要一定的软件支持环境</h3><p>面向对象方法学把分析、设计和实现很自然地联系在一起了。虽然面向对象设计原则上不依赖于特定的实现环境，但是实现结果和实现成本却在很大程度上取决于实现环境。因此，直接支持面向对象设计范式的面向对象程序语言、开发环境及类库，对于面向对象实现来说是非常重要的。<br>综上所述，其实在我们的学习过程中可以看到面向对象语言有许多优秀的地方，但也有一些缺陷，而我们一直都在努力地想尽各种办法去弥补这些缺陷，通过一些机制让面向对象语言越来越来趋于完善。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔/杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 程序设计语言原理 </tag>
            
            <tag> 面向对象 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>入坑</title>
      <link href="/2017/02/01/Begin-Hexo/"/>
      <url>/2017/02/01/Begin-Hexo/</url>
      
        <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Welcome to my blog, enter password to read.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="6f243a2e385d84d5ccc11900fcb31266158822ebce9a6a801ddb57f32c6608e4">d0d703fa332139beb12ceb85f23df7fc2dd2ad6c1e2d88c79a07ca82a4c752383c4b274b70abf24c2627b91511ca38c6827a85fb24bb1d405ef366f63d449475cc7e7021b2f42aea7973805ef690a099be12a8caa2ffdf6dbc9f6212144592fad5a584f16d9cbcc534663cce7d13c5205693b5799467cdca4f31b1eb3da117c4464e9d65e8d2ea086423bfac557b55b88f807ccf0b25016324b2051db850900f99f12708a26a6549e44778d76c46ce31d1a6d64c5e9d8db63da0630457acc014c67941c9a3f8ca646afc155801e88b3509b175e7ac010b442778b88935322dc16758351f90281084ecfd1b06f21cb5a1c4e1255c460c67ea328840963b1ad7b1f852cafe5fdc6953ede3c0673d806bfabe27886bcda6e231bc5cd1f5cb677b296f51da1bb1989bfaa6cf0b0660f35891bbd99b26a0896e78d57842dee264d016baceb99e3f13092237c93684670c6e88cfff33da6d7349a6cf40be699e8284ef10b4eb241453682469c77ad2f090a4e373b2180742907a573045ec4249741ead90025684de14d2c211fe00e6607198734334ea439dae591f201d9490b798cbfd6d3587ac9b9ad81396def3061e6a23e6c7f9ccdbb7275a2809aef139d0a9c9778d50c2180804a2063d7974f0290a762bdb2f9ab0a607f00dc611f48b6c45ad7a18fb4b0531aafa273afa651a226af26f05b880027af884671dec90c608d7654df07ed93288cb5ef405b58fd5836a91aeba11d07a72696ca368791b14474e45a25ee9c4d515f02b78b4bff644290ac0cffe4cf1ef6c1dd1e44107ebabe897fe81d6288a1a427bae0728eead5416c712ebadf1518b2d30149d7e0dc4b75fecb6994f618f69f0c2c45338af3e35f7cf2e3acbba3222363f11403d04e2fbd73ea3ed57170c8a5d1038d5d9c2b314a05e4b2793aa3cec2ed7e22ef6ea5bcef5b4121fc3b2383c08c835fa47d03ba9715ccbe2eb07d83a91eca74a3ef651e17c1f55e1</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> github </tag>
            
            <tag> npm </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2017/02/01/hello-world/"/>
      <url>/2017/02/01/hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> github </tag>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
